<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>内核驱动中拦截USB设备接入(1)</title>
    <url>/2019/12/12/USB%E7%9B%B8%E5%85%B3/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E4%B8%AD%E6%8B%A6%E6%88%AAUSB%E8%AE%BE%E5%A4%87%E6%8E%A5%E5%85%A5-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>有时候我们想对某一类设备进行统一管理，比如常见的磁盘设备、卷设备、USB设备等等。<br>在WDM驱动模型中，就可以通过对某类设备，设置 <code>上层过滤驱动</code> 和 <code>下层过滤驱动</code> 的方式来实现。</p>
<h4 id="WDM驱动模型"><a href="#WDM驱动模型" class="headerlink" title="WDM驱动模型"></a>WDM驱动模型</h4><p>WDM模型中设备和驱动程序的层次结构如下图所示：</p>
<p><img src="01.png" alt="层次结构"></p>
<p>我们这里不讨论复杂的 <code>WDM设备驱动</code> 如何开发，只考虑过滤驱动逻辑相对简单。<br>添加某类设备的过滤驱动的方法，就是在对应设备类的注册表键下，创建 <code>LowerFilters</code> 值来表示<br><code>下层过滤驱动</code>，创建 <code>UpperFilters</code> 值来表示 <code>上层过滤驱动</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKLM\SYSTEM\CurrentControlSet\Control\Class\&#123;36fc9e60-c465-11cf-8056-444553540000&#125;</span><br></pre></td></tr></table></figure>

<p>以 <code>USB设备类</code> 为例，假定我们过滤驱动的服务名为 <code>MyUsbFltDrv</code> ，在如上所示注册表路径下，创建<br> <code>LowerFilters</code> 值，并设定其内容为 <code>MyUsbFltDrv</code> ，注意该值为 <code>REG_MULTI_SZ</code> 类型。</p>
<p><img src="02.png" alt="注册表路径"></p>
<p>创建完毕后，新接入USB设备时，操作系统就会启动我们的过滤驱动。<br>注意：假如过滤驱动启动失败，会导致IRP无法继续传递，从而所有新接入USB设备都无法识别。</p>
<h4 id="USB设备类过滤"><a href="#USB设备类过滤" class="headerlink" title="USB设备类过滤"></a>USB设备类过滤</h4><p>在WDM过滤驱动中，我们在 <code>AddDevice</code> 函数中附加过滤设备。USB设备的启动和停止都在<br> <code>IRP_MJ_PNP</code> 中处理，为了同时兼容XP和WIN7系统，我们还要处理 <code>IRP_MJ_POWER</code> 功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG Index = <span class="number">0</span>;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegPath);</span><br><span class="line">    <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt;= IRP_MJ_MAXIMUM_FUNCTION; Index++)</span><br><span class="line">    &#123;</span><br><span class="line">        DriverObject-&gt;MajorFunction[Index] = DispatchCommon;</span><br><span class="line">    &#125;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_POWER] = DispatchPower;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_PNP] = DispatchPnp;</span><br><span class="line">    DriverObject-&gt;DriverExtension-&gt;AddDevice = MyAddDevice;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125; <span class="comment">// 驱动入口函数</span></span><br></pre></td></tr></table></figure>

<p>如下为我们关注的USB关键信息结构体定义，放入到每个设备的扩展内容中</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">#define EXALLOCATE(x) ExAllocatePoolWithTag(NonPagedPool, (x), &#x27;MEM&#x27;);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USB_INFO</span> &#123;</span></span><br><span class="line">    UCHAR  iType; <span class="comment">// 设备类型</span></span><br><span class="line">    USHORT idVendor; <span class="comment">// VID信息</span></span><br><span class="line">    USHORT idProduct; <span class="comment">// PID信息</span></span><br><span class="line">    WCHAR  szSerial[<span class="number">128</span>]; <span class="comment">// 序列号</span></span><br><span class="line">&#125; USB_INFO, *PUSB_INFO;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_EXTENSION</span> &#123;</span></span><br><span class="line">    PDEVICE_OBJECT TargetDevice; <span class="comment">// 附加的设备</span></span><br><span class="line">    UCHAR iSerialOffset; <span class="comment">// 序列号偏移</span></span><br><span class="line">    USB_INFO UsbInfo; <span class="comment">// USB关键信息</span></span><br><span class="line">&#125; DEVICE_EXTENSION, *PDEVICE_EXTENSION;</span><br></pre></td></tr></table></figure>

<p>每个新设备接入时，都会触发 <code>AddDevice</code> 函数，我们在这里创建过滤设备，并进行附加绑定</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MyAddDevice</span><span class="params">(PDRIVER_OBJECT DriverObject, PDEVICE_OBJECT PhysicalDevice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PDEVICE_EXTENSION DevExt = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PDEVICE_OBJECT FilterDevice = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 创建过滤设备</span></span><br><span class="line">    Status = IoCreateDevice(</span><br><span class="line">        DriverObject, <span class="keyword">sizeof</span>(DEVICE_EXTENSION),</span><br><span class="line">        <span class="literal">NULL</span>, PhysicalDevice-&gt;DeviceType,</span><br><span class="line">        PhysicalDevice-&gt;Characteristics, FALSE, &amp;FilterDevice);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">return</span> Status;</span><br><span class="line">    FilterDevice-&gt;Flags |= PhysicalDevice-&gt;Flags;</span><br><span class="line">    <span class="comment">// 设备扩展处理</span></span><br><span class="line">    DevExt = (PDEVICE_EXTENSION)(FilterDevice-&gt;DeviceExtension);</span><br><span class="line">    RtlZeroMemory(DevExt, <span class="keyword">sizeof</span>(DEVICE_EXTENSION));</span><br><span class="line">    <span class="comment">// 绑定物理设备</span></span><br><span class="line">    Status = IoAttachDeviceToDeviceStackSafe(</span><br><span class="line">        FilterDevice, <span class="comment">// 创建的过滤设备</span></span><br><span class="line">        PhysicalDevice, <span class="comment">// 目标设备栈中的设备</span></span><br><span class="line">        &amp;DevExt-&gt;TargetDevice); <span class="comment">// 最终绑定的设备</span></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        IoDeleteDevice(FilterDevice);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    FilterDevice-&gt;Flags &amp;= ~DO_DEVICE_INITIALIZING;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>DispatchCommon</code> 中不做任何处理，直接转发到下层设备</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DispatchCommon</span><span class="params">(PDEVICE_OBJECT DeviceObject, PIRP Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PDEVICE_EXTENSION DevExt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 转发到下层设备</span></span><br><span class="line">    DevExt = (PDEVICE_EXTENSION)(DeviceObject-&gt;DeviceExtension);</span><br><span class="line">    IoSkipCurrentIrpStackLocation(Irp);</span><br><span class="line">    <span class="keyword">return</span> IoCallDriver(DevExt-&gt;TargetDevice, Irp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>DispatchPower</code> 中，针对不同的操作系统，使用的函数有所区别</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DispatchPower</span><span class="params">(PDEVICE_OBJECT DeviceObject, PIRP Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PDEVICE_EXTENSION DevExt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 转发到下层设备</span></span><br><span class="line">    DevExt = (PDEVICE_EXTENSION)(DeviceObject-&gt;DeviceExtension);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NTDDI_VERSION &lt; NTDDI_VISTA)</span></span><br><span class="line">    PoStartNextPowerIrp(Irp);</span><br><span class="line">    IoSkipCurrentIrpStackLocation(Irp);</span><br><span class="line">    <span class="keyword">return</span> PoCallDriver(DevExt-&gt;TargetDevice, Irp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    IoSkipCurrentIrpStackLocation(Irp);</span><br><span class="line">    <span class="keyword">return</span> IoCallDriver(DevExt-&gt;TargetDevice, Irp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>DispatchPnp</code> 中，我们只关注子功能 <code>IRP_MN_START_DEVICE</code> 和 <code>IRP_MN_REMOVE_DEVICE</code> 的处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DispatchPnp</span><span class="params">(PDEVICE_OBJECT DeviceObject, PIRP Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PDEVICE_EXTENSION DevExt = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PDEVICE_OBJECT TargetDevice = <span class="literal">NULL</span>;</span><br><span class="line">    PIO_STACK_LOCATION IrpStack = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 删除设备后，设备扩展内容可能会无效</span></span><br><span class="line">    DevExt = (PDEVICE_EXTENSION)(DeviceObject-&gt;DeviceExtension);</span><br><span class="line">    TargetDevice = DevExt-&gt;TargetDevice; <span class="comment">// 保存下层设备</span></span><br><span class="line">    <span class="comment">// 处理子功能</span></span><br><span class="line">    IrpStack = IoGetCurrentIrpStackLocation(Irp);</span><br><span class="line">    <span class="keyword">switch</span> (IrpStack-&gt;MinorFunction)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> IRP_MN_START_DEVICE: <span class="comment">// 设备启动</span></span><br><span class="line">        Status = GetUsbType(DeviceObject); <span class="comment">// 获取设备类型</span></span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        Status = GetUsbSerial(DeviceObject); <span class="comment">// 获取序列号</span></span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 可以发送给应用层，来自行决定如何处理USB信息</span></span><br><span class="line">        <span class="keyword">if</span> (DevExt-&gt;UsbInfo.iType == <span class="number">0x8</span>) <span class="comment">// 大容量存储类型</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 拦截本次IRP请求</span></span><br><span class="line">            Irp-&gt;IoStatus.Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">            IoCompleteRequest(Irp, IO_NO_INCREMENT);</span><br><span class="line">            <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// case IRP_MN_QUERY_REMOVE_DEVICE: // 安全移除</span></span><br><span class="line">    <span class="comment">// case IRP_MN_SURPRISE_REMOVAL: // 异常移除</span></span><br><span class="line">    <span class="comment">// 安全移除和异常移除，最终都触发设备移除</span></span><br><span class="line">    <span class="keyword">case</span> IRP_MN_REMOVE_DEVICE: <span class="comment">// 设备移除</span></span><br><span class="line">        IoDetachDevice(DevExt-&gt;TargetDevice); <span class="comment">// 解绑设备</span></span><br><span class="line">        IoDeleteDevice(DeviceObject); <span class="comment">// 删除过滤设备</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 转发到下层设备</span></span><br><span class="line">    IoSkipCurrentIrpStackLocation(Irp);</span><br><span class="line">    <span class="keyword">return</span> IoCallDriver(TargetDevice, Irp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="如何查询USB信息"><a href="#如何查询USB信息" class="headerlink" title="如何查询USB信息"></a>如何查询USB信息</h4><p>查询USB信息，需要向 <code>总线设备驱动</code> 发送 <code>URB</code> 请求，所以在 <code>下层过滤驱动</code> 处进行处理。<br>具体查询步骤为，首先申请一段 <code>URB</code> 空间，初始化 <code>URB</code> 为查询相关信息的请求，<br>然后创建一个 <code>IRP</code> 请求，把 <code>URB</code> 绑定到 <code>IRP</code> 中，发送到 <code>总线控制设备</code> 进行查询。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">UsbCallUSBDI</span><span class="params">(PDEVICE_OBJECT DeviceObject, PURB Urb)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIRP Irp = <span class="literal">NULL</span>;</span><br><span class="line">    KEVENT Event = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    IO_STATUS_BLOCK IoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PIO_STACK_LOCATION IrpStack = <span class="literal">NULL</span>;</span><br><span class="line">    PDEVICE_EXTENSION DevExt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 构建IRP请求</span></span><br><span class="line">    KeInitializeEvent(&amp;Event, NotificationEvent, FALSE);</span><br><span class="line">    DevExt = (PDEVICE_EXTENSION)(DeviceObject-&gt;DeviceExtension);</span><br><span class="line">    Irp = IoBuildDeviceIoControlRequest(</span><br><span class="line">        IOCTL_INTERNAL_USB_SUBMIT_URB, DevExt-&gt;TargetDevice,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, TRUE, &amp;Event, &amp;IoStatus);</span><br><span class="line">    <span class="keyword">if</span> (Irp == <span class="literal">NULL</span>) Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="comment">// 设置URB并发送IRP请求</span></span><br><span class="line">    IrpStack = IoGetNextIrpStackLocation(Irp);</span><br><span class="line">    IrpStack-&gt;Parameters.Others.Argument1 = Urb;</span><br><span class="line">    Status = IoCallDriver(DevExt-&gt;TargetDevice, Irp);</span><br><span class="line">    <span class="comment">// 调用IoCallDriver时，其实并没有结束本函数</span></span><br><span class="line">    <span class="keyword">if</span> (Status == STATUS_PENDING)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = KeWaitForSingleObject(&amp;Event, Executive, KernelMode, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">        Status = IoStatus.Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125; <span class="comment">// 构建IRP并发送</span></span><br></pre></td></tr></table></figure>

<p>如下为获取 <code>设备描述符</code> 信息的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">UsbGetDeviceDescriptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PDEVICE_OBJECT DeviceObject,</span></span></span><br><span class="line"><span class="function"><span class="params">    PUSB_DEVICE_DESCRIPTOR *pDeviceDescriptor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PURB Urb = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    <span class="comment">// 申请URB内存空间</span></span><br><span class="line">    Urb = (PURB)EXALLOCATE(<span class="keyword">sizeof</span>(struct _URB_CONTROL_DESCRIPTOR_REQUEST));</span><br><span class="line">    <span class="keyword">if</span> (Urb == <span class="literal">NULL</span>) <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="comment">// 申请Device Descriptor信息内存空间</span></span><br><span class="line">    *pDeviceDescriptor = (PUSB_DEVICE_DESCRIPTOR)EXALLOCATE(</span><br><span class="line">        <span class="keyword">sizeof</span>(USB_DEVICE_DESCRIPTOR));</span><br><span class="line">    <span class="keyword">if</span> (*pDeviceDescriptor == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePool(Urb);</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造URB请求，并获取设备描述信息</span></span><br><span class="line">    UsbBuildGetDescriptorRequest(</span><br><span class="line">        Urb, <span class="keyword">sizeof</span>(struct _URB_CONTROL_DESCRIPTOR_REQUEST),</span><br><span class="line">        USB_DEVICE_DESCRIPTOR_TYPE, <span class="number">0</span>, <span class="number">0</span>, *pDeviceDescriptor,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(USB_DEVICE_DESCRIPTOR), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 发送内部IRP请求</span></span><br><span class="line">    Status = UsbCallUSBDI(DeviceObject, Urb);</span><br><span class="line">    ExFreePool(Urb); <span class="comment">// 先释放URB空间</span></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">return</span> Status;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下为获取 <code>配置描述符</code> 信息的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">UsbGetConfigDescriptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PDEVICE_OBJECT DeviceObject,</span></span></span><br><span class="line"><span class="function"><span class="params">    PUSB_CONFIGURATION_DESCRIPTOR *pConfigDescriptor)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PURB Urb = <span class="literal">NULL</span>;</span><br><span class="line">    USHORT wTotalLength = <span class="number">0</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    <span class="comment">// 申请URB内存空间</span></span><br><span class="line">    Urb = (PURB)EXALLOCATE(<span class="keyword">sizeof</span>(struct _URB_CONTROL_DESCRIPTOR_REQUEST));</span><br><span class="line">    <span class="keyword">if</span> (Urb == <span class="literal">NULL</span>) <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="comment">// 申请Config Descriptor内存空间</span></span><br><span class="line">    *pConfigDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR)EXALLOCATE(</span><br><span class="line">        <span class="keyword">sizeof</span>(USB_CONFIGURATION_DESCRIPTOR));</span><br><span class="line">    <span class="keyword">if</span> (*pConfigDescriptor == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePool(Urb);</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造URB请求，并获取配置描述信息</span></span><br><span class="line">    UsbBuildGetDescriptorRequest(</span><br><span class="line">        Urb, <span class="keyword">sizeof</span>(struct _URB_CONTROL_DESCRIPTOR_REQUEST),</span><br><span class="line">        USB_CONFIGURATION_DESCRIPTOR_TYPE, <span class="number">0</span>, <span class="number">0</span>, *pConfigDescriptor,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(USB_CONFIGURATION_DESCRIPTOR), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 发送内部IRP请求</span></span><br><span class="line">    Status = UsbCallUSBDI(DeviceObject, Urb);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePool(Urb);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第2次申请Config Descriptor信息内存空间</span></span><br><span class="line">    wTotalLength = (*pConfigDescriptor)-&gt;wTotalLength;</span><br><span class="line">    ExFreePool(*pConfigDescriptor);</span><br><span class="line">    *pConfigDescriptor = (PUSB_CONFIGURATION_DESCRIPTOR)EXALLOCATE(wTotalLength);</span><br><span class="line">    <span class="keyword">if</span> (*pConfigDescriptor == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePool(Urb);</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第2次构造URB请求，并获取配置描述信息</span></span><br><span class="line">    UsbBuildGetDescriptorRequest(</span><br><span class="line">        Urb, <span class="keyword">sizeof</span>(struct _URB_CONTROL_DESCRIPTOR_REQUEST),</span><br><span class="line">        USB_CONFIGURATION_DESCRIPTOR_TYPE, <span class="number">0</span>, <span class="number">0</span>, *pConfigDescriptor,</span><br><span class="line">        <span class="literal">NULL</span>, wTotalLength, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 第2次发送内部IRP请求</span></span><br><span class="line">    Status = UsbCallUSBDI(DeviceObject, Urb);</span><br><span class="line">    ExFreePool(Urb); <span class="comment">// 先释放URB空间</span></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">return</span> Status;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过 <code>设备描述符</code> 和 <code>配置描述符</code> 可以得到该设备的VID、PID和设备类型信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">GetUsbType</span><span class="params">(PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PDEVICE_EXTENSION DevExt = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    PUSB_DEVICE_DESCRIPTOR DeviceDescriptor = <span class="literal">NULL</span>;</span><br><span class="line">    PUSB_INTERFACE_DESCRIPTOR InterfaceDescriptor = <span class="literal">NULL</span>;</span><br><span class="line">    PUSB_CONFIGURATION_DESCRIPTOR ConfigDescriptor = <span class="literal">NULL</span>;</span><br><span class="line">    DevExt = (PDEVICE_EXTENSION)(DeviceObject-&gt;DeviceExtension);</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取Device Descriptor信息</span></span><br><span class="line">        Status = UsbGetDeviceDescriptor(DeviceObject, &amp;DeviceDescriptor);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 保存关键的USB信息</span></span><br><span class="line">        DevExt-&gt;UsbInfo.idVendor = DeviceDescriptor-&gt;idVendor; <span class="comment">// VID信息</span></span><br><span class="line">        DevExt-&gt;UsbInfo.idProduct = DeviceDescriptor-&gt;idProduct; <span class="comment">// PID信息</span></span><br><span class="line">        DevExt-&gt;iSerialOffice = DeviceDescriptor-&gt;iSerialNumber; <span class="comment">// 序列号偏移</span></span><br><span class="line">        <span class="comment">// 获取Configuration Descriptor信息(有可能不存在)</span></span><br><span class="line">        Status = UsbGetConfigDescriptor(DeviceObject, &amp;ConfigDescriptor);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 分析Interface Descriptor信息</span></span><br><span class="line">        InterfaceDescriptor = USBD_ParseConfigurationDescriptorEx(</span><br><span class="line">            ConfigDescriptor, ConfigDescriptor,</span><br><span class="line">            <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0x8</span>, <span class="number">-1</span>, <span class="number">-1</span>); <span class="comment">// 查询大容量存储类型</span></span><br><span class="line">        <span class="keyword">if</span> (InterfaceDescriptor != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DevExt-&gt;UsbInfo.iType = <span class="number">0x8</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        InterfaceDescriptor = USBD_ParseConfigurationDescriptorEx(</span><br><span class="line">            ConfigDescriptor, ConfigDescriptor,</span><br><span class="line">            <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">0xFF</span>, <span class="number">-1</span>, <span class="number">-1</span>); <span class="comment">// 查询自定义设备类型</span></span><br><span class="line">        <span class="keyword">if</span> (InterfaceDescriptor != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            DevExt-&gt;UsbInfo.iType = <span class="number">0xFF</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Status = STATUS_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 释放申请的空间</span></span><br><span class="line">    <span class="keyword">if</span> (DeviceDescriptor != <span class="literal">NULL</span>) ExFreePool(DeviceDescriptor);</span><br><span class="line">    <span class="keyword">if</span> (ConfigDescriptor != <span class="literal">NULL</span>) ExFreePool(ConfigDescriptor);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下为获取 <code>字符串描述符</code> 信息的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">UsbGetStringDescriptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PDEVICE_OBJECT DeviceObject,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN UCHAR DescriptorIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN USHORT LanguageID,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PUSB_STRING_DESCRIPTOR StringDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN UCHAR StringSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PURB Urb = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;;</span><br><span class="line">    <span class="comment">// 判断参数是否是空指针</span></span><br><span class="line">    <span class="keyword">if</span> ((StringDescriptor == <span class="literal">NULL</span>) || (StringSize == <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="comment">// 申请URB内存空间</span></span><br><span class="line">    Urb = (PURB)EXALLOCATE(<span class="keyword">sizeof</span>(struct _URB_CONTROL_DESCRIPTOR_REQUEST));</span><br><span class="line">    <span class="keyword">if</span> (Urb == <span class="literal">NULL</span>) STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="comment">// 构造URB请求，并获取设备描述信息</span></span><br><span class="line">    UsbBuildGetDescriptorRequest(</span><br><span class="line">        Urb, <span class="keyword">sizeof</span>(struct _URB_CONTROL_DESCRIPTOR_REQUEST),</span><br><span class="line">        USB_STRING_DESCRIPTOR_TYPE, DescriptorIndex, LanguageID,</span><br><span class="line">        StringDescriptor, <span class="literal">NULL</span>, StringSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 发送内部IRP请求</span></span><br><span class="line">    Status = UsbCallUSBDI(DeviceObject, Urb);</span><br><span class="line">    ExFreePool(Urb); <span class="comment">// 先释放URB空间</span></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">return</span> Status;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>字符串描述符</code> 中可能存在 <code>多种语言</code> 字符串，我们这里只获取 <code>第1种语言</code> 的信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">GetUsbString</span><span class="params">(PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PDEVICE_EXTENSION DevExt = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    PUSB_STRING_DESCRIPTOR StringLanguage = <span class="literal">NULL</span>;</span><br><span class="line">    PUSB_STRING_DESCRIPTOR StringDescriptor = <span class="literal">NULL</span>;</span><br><span class="line">    USHORT NumLanguageIDs = <span class="number">0</span>; <span class="comment">// 语言的数量</span></span><br><span class="line">    PUSHORT LanguageIDs = <span class="literal">NULL</span>; <span class="comment">// 语言ID的指针</span></span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        DevExt = (PDEVICE_EXTENSION)(DeviceObject-&gt;DeviceExtension);</span><br><span class="line">        <span class="comment">// 首先检验序列号偏移是否为空</span></span><br><span class="line">        <span class="keyword">if</span> (DevExt-&gt;iSerialOffset == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 申请String Descriptor的语言列表内存空间</span></span><br><span class="line">        StringLanguage = (PUSB_STRING_DESCRIPTOR)EXALLOCATE(<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringLanguage == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 获取String Descriptor的语言列表</span></span><br><span class="line">        Status = UsbGetStringDescriptor(</span><br><span class="line">            DeviceObject, <span class="number">0</span>, <span class="number">0</span>, StringLanguage, <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 检测语言列表信息长度</span></span><br><span class="line">        <span class="keyword">if</span> (StringLanguage-&gt;bLength &lt; <span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 语言ID的换算处理</span></span><br><span class="line">        NumLanguageIDs = (StringLanguage-&gt;bLength - <span class="number">2</span>) / <span class="number">2</span>; <span class="comment">// 数量</span></span><br><span class="line">        LanguageIDs = (PUSHORT)&amp;(StringLanguage-&gt;bString[<span class="number">0</span>]); <span class="comment">// 地址</span></span><br><span class="line">        <span class="comment">// 申请String Descriptor的内存空间</span></span><br><span class="line">        StringDescriptor = (PUSB_STRING_DESCRIPTOR)EXALLOCATE(<span class="number">256</span>);</span><br><span class="line">        <span class="keyword">if</span> (StringDescriptor == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 循环语言ID数量，去读取USB的序列号（这里只1次）</span></span><br><span class="line">        Status = UsbGetStringDescriptor(</span><br><span class="line">            DeviceObject, DevExt-&gt;iSerialOffset,</span><br><span class="line">            *LanguageIDs, StringDescriptor, <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 复制序列号（需要减2个字节，bLength指总长度，而不是字符串长度）</span></span><br><span class="line">        <span class="keyword">if</span> (StringDescriptor-&gt;bLength &gt; <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            RtlCopyMemory(DevExt-&gt;UsbInfo.szSerial,</span><br><span class="line">                StringDescriptor-&gt;bString, StringDescriptor-&gt;bLength - <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        Status = STATUS_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 释放申请的空间</span></span><br><span class="line">    <span class="keyword">if</span> (StringLanguage != <span class="literal">NULL</span>) ExFreePool(StringLanguage);</span><br><span class="line">    <span class="keyword">if</span> (StringDescriptor != <span class="literal">NULL</span>) ExFreePool(StringDescriptor);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>USB相关</category>
      </categories>
      <tags>
        <tag>USB相关</tag>
      </tags>
  </entry>
  <entry>
    <title>在服务中监控U盘接入并获取盘符(1)</title>
    <url>/2021/08/06/USB%E7%9B%B8%E5%85%B3/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E4%B8%AD%E7%9B%91%E6%8E%A7U%E7%9B%98%E6%8E%A5%E5%85%A5%E5%B9%B6%E8%8E%B7%E5%8F%96%E7%9B%98%E7%AC%A6-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在窗口程序中，我们可以通过 <code>WM_DEVICECHANGE</code> 消息获取到接入的U盘设备，<br>某些情况下，我们需要在服务中去监控U盘设备接入，并获取对应盘符，来进行其他操作。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>创建服务的本身框架，这里不再复述，主要介绍如何监控U盘相关。<br>在使用 <code>StartServiceCtrlDispatcher</code> 注册的服务入口函数 <code>ServiceMain</code> 中，我们需要使用<br><code>RegisterServiceCtrlHandlerEx</code> 注册服务的 <code>HandlerProc</code> 消息处理函数，然后使用注册后<br>得到的 <code>SERVICE_STATUS_HANDLE</code> 句柄，来注册U盘设备监控的通知函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winioctl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dbt.h&gt;</span></span></span><br><span class="line">SERVICE_STATUS_HANDLE g_hServiceStatus = <span class="literal">NULL</span>;</span><br><span class="line">HDEVNOTIFY g_hDevNotify = <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>

<h5 id="1-服务入口函数"><a href="#1-服务入口函数" class="headerlink" title="1.服务入口函数"></a>1.服务入口函数</h5><p>注册监控时，我们只能使用 <code>DBT_DEVTYP_DEVICEINTERFACE</code> 或 <code>DBT_DEVTYP_HANDLE</code> 类型，<br>其中 <code>DBT_DEVTYP_HANDLE</code> 是针对某个设备的各种IO行为的监控，不符合我们的预期</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">ServiceMain</span><span class="params">(DWORD argc, LPWSTR *argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注册服务的消息处理函数</span></span><br><span class="line">    g_hServiceStatus = RegisterServiceCtrlHandlerExW(<span class="string">L&quot;MyService&quot;</span>, &amp;HandlerProc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!g_hServiceStatus) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 监控GUID_DEVINTERFACE_VOLUME设备</span></span><br><span class="line">    DEV_BROADCAST_DEVICEINTERFACE stDbdi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    stDbdi.dbcc_size = <span class="keyword">sizeof</span>(DEV_BROADCAST_DEVICEINTERFACE);</span><br><span class="line">    stDbdi.dbcc_devicetype = DBT_DEVTYP_DEVICEINTERFACE;</span><br><span class="line">    stDbdi.dbcc_classguid = GUID_DEVINTERFACE_VOLUME;</span><br><span class="line">    <span class="comment">// 注册设备监控通知函数</span></span><br><span class="line">    g_hDevNotify = RegisterDeviceNotificationW(</span><br><span class="line">        g_hServiceStatus, &amp;stDbdi, DEVICE_NOTIFY_SERVICE_HANDLE);</span><br><span class="line">    <span class="keyword">if</span> (!g_hDevNotify) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 设置为运行状态</span></span><br><span class="line">    ChangeServiceStatus(SERVICE_RUNNING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-服务消息处理函数"><a href="#2-服务消息处理函数" class="headerlink" title="2.服务消息处理函数"></a>2.服务消息处理函数</h5><p>在消息处理函数中，当Volume设备接入时，会触发 <code>SERVICE_CONTROL_DEVICEEVENT</code> 消息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">HandlerProc</span><span class="params">(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (dwControl)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> SERVICE_CONTROL_STOP:</span><br><span class="line">    <span class="keyword">case</span> SERVICE_CONTROL_SHUTDOWN:</span><br><span class="line">        <span class="comment">// 取消注册设备监控通知函数</span></span><br><span class="line">        UnregisterDeviceNotification(g_hDevNotify);</span><br><span class="line">        ChangeServiceStatus(SERVICE_STOPPED);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> SERVICE_CONTROL_DEVICEEVENT:</span><br><span class="line">        <span class="keyword">if</span> (!lpEventData) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">switch</span> (dwEventType)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> DBT_DEVICEARRIVAL: <span class="comment">// 设备接入</span></span><br><span class="line">            &#123;</span><br><span class="line">                PDEV_BROADCAST_HDR pDbch = (PDEV_BROADCAST_HDR)lpEventData;</span><br><span class="line">                <span class="keyword">if</span> (pDbch-&gt;dbch_devicetype != DBT_DEVTYP_DEVICEINTERFACE) <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">// 根据Volume获取对应盘符</span></span><br><span class="line">                GetVolumeDriveName(((PDEV_BROADCAST_DEVICEINTERFACE)pDbch)-&gt;dbcc_name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> DBT_DEVICEREMOVECOMPLETE: <span class="comment">// 设备移除</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NO_ERROR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-根据Volume获取盘符"><a href="#3-根据Volume获取盘符" class="headerlink" title="3.根据Volume获取盘符"></a>3.根据Volume获取盘符</h5><p>监控到U盘接入时，获取到的设备是 <code>DBT_DEVTYP_DEVICEINTERFACE</code> 类型的，而不是在窗口中<br>的 <code>DBT_DEVTYP_VOLUME</code> 类型，而 <code>DEV_BROADCAST_DEVICEINTERFACE</code> 的 <code>dbcc_name</code> 成员是<br><code>\\?\STORAGE#Volume#_??_USBSTOR#Disk&amp;Ven_Kingston&amp;Prod_DataTraveler_3.0 ...</code><br>的样式，通过使用 <code>WinObj</code> 工具查询，发现这个名称对应到了 <code>\Device\HarddiskVolume???</code><br>的符号链接，我们知道盘符其实也是对应到这样的符号链接上，所以我们可以使用 <code>ntdll.dll</code><br>导出的 <code>NtOpenSymbolicLinkObject</code> 和 <code>NtQuerySymbolicLinkObject</code> 函数来查询符号链接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">WCHAR <span class="title">GetVolumeDriveName</span><span class="params">(PCWSTR pDevName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pDevName || !pDevName[<span class="number">0</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    WCHAR wszBuffer[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    wcscpy_s(wszBuffer, pDevName);</span><br><span class="line">    <span class="comment">// 把前缀&quot;\\\\?\\&quot;修改为&quot;\\??\\&quot;</span></span><br><span class="line">    <span class="keyword">if</span> (wcsncmp(wszBuffer, <span class="string">L&quot;\\\\?\\&quot;</span>, <span class="number">4</span>)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    wszBuffer[<span class="number">1</span>] = <span class="string">L&#x27;?&#x27;</span>;</span><br><span class="line">    <span class="comment">// 获取ntdll.dll的导出函数</span></span><br><span class="line">    HMODULE hNtdll = LoadLibraryW(<span class="string">L&quot;ntdll.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hNtdll) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    NTOPENSYMBOLICLINKOBJECT fnNtOpenSymbolicLinkObject =</span><br><span class="line">        (NTOPENSYMBOLICLINKOBJECT)GetProcAddress(hNtdll, <span class="string">&quot;NtOpenSymbolicLinkObject&quot;</span>);</span><br><span class="line">    NTQUERYSYMBOLICLINKOBJECT fnNtQuerySymbolicLinkObject =</span><br><span class="line">        (NTQUERYSYMBOLICLINKOBJECT)GetProcAddress(hNtdll, <span class="string">&quot;NtQuerySymbolicLinkObject&quot;</span>);</span><br><span class="line">    NTCLOSE fnNtClose = (NTCLOSE)GetProcAddress(hNtdll, <span class="string">&quot;NtClose&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!fnNtOpenSymbolicLinkObject || !fnNtQuerySymbolicLinkObject || !fnNtClose)</span><br><span class="line">    &#123;</span><br><span class="line">        FreeLibrary(hNtdll);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化UNICODE_STRING信息</span></span><br><span class="line">    UNICODE_STRING strDevName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OBJECT_ATTRIBUTES objAttrib = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    strDevName.Buffer = wszBuffer;</span><br><span class="line">    strDevName.MaximumLength = <span class="keyword">sizeof</span>(wszBuffer);</span><br><span class="line">    strDevName.Length = (USHORT)wcslen(wszBuffer) * <span class="keyword">sizeof</span>(WCHAR);</span><br><span class="line">    InitializeObjectAttributes(&amp;objAttrib, &amp;strDevName, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 打开Volume设备</span></span><br><span class="line">    HANDLE hSymLink = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS ntStatus = fnNtOpenSymbolicLinkObject(&amp;hSymLink, SYMBOLIC_LINK_QUERY, &amp;objAttrib);</span><br><span class="line">    <span class="keyword">if</span> (ntStatus != STATUS_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        FreeLibrary(hNtdll);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询符号链接</span></span><br><span class="line">    ULONG dwLength = <span class="number">0</span>;</span><br><span class="line">    strDevName.Length = <span class="number">0</span>;</span><br><span class="line">    ZeroMemory(wszBuffer, <span class="keyword">sizeof</span>(wszBuffer));</span><br><span class="line">    ntStatus = fnNtQuerySymbolicLinkObject(hSymLink, &amp;strDevName, &amp;dwLength);</span><br><span class="line">    fnNtClose(hSymLink); <span class="comment">// 关闭句柄</span></span><br><span class="line">    FreeLibrary(hNtdll); <span class="comment">// 关闭句柄</span></span><br><span class="line">    <span class="keyword">if</span> (ntStatus != STATUS_SUCCESS) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 查询现有的盘符和对应的Volume信息</span></span><br><span class="line">    WCHAR wszDrive[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 32 * L&quot;C:\\&quot;</span></span><br><span class="line">    WCHAR wszVolume[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// L&quot;\\Device\\HarddiskVolume?????&quot;</span></span><br><span class="line">    DWORD dwNum = GetLogicalDriveStringsW(<span class="number">128</span>, wszDrive);</span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; dwNum; i += <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        wszDrive[i + <span class="number">2</span>] = <span class="number">0</span>; <span class="comment">// 去掉&#x27;\\&#x27;只保留&quot;C:&quot;</span></span><br><span class="line">        <span class="comment">// 检测当前盘符是不是U盘</span></span><br><span class="line">        <span class="keyword">if</span> (GetDriveType(&amp;wszDrive[i]) != DRIVE_REMOVABLE) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (!QueryDosDeviceW(&amp;wszDrive[i], wszVolume, <span class="number">32</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 当Volume信息匹配时返回当前盘符</span></span><br><span class="line">        <span class="keyword">if</span> (!_wcsicmp(wszVolume, wszBuffer)) <span class="keyword">return</span> wszDrive[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>USB相关</category>
      </categories>
      <tags>
        <tag>USB相关</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层删除USB存储设备历史记录(1)</title>
    <url>/2019/09/29/USB%E7%9B%B8%E5%85%B3/%E5%BA%94%E7%94%A8%E5%B1%82%E5%88%A0%E9%99%A4USB%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>当我们把一个U盘插入到电脑的USB接口后，操作系统会读取U盘相关信息，并在注册表中生成对应注册表项，<br>而我们拔掉这个U盘后，相关注册表项并不会自动删除，操作系统会保留对应信息，用以再次接入时使用。</p>
<p>某些安全检测软件，可以检测到这些历史记录信息。有时候，我们并不想让这些安全软件检测到，这就需要<br>我们主动的清除这些信息。</p>
<h4 id="手动操作"><a href="#手动操作" class="headerlink" title="手动操作"></a>手动操作</h4><p>首先我们需要在 <code>环境变量</code> 中新建一个 <code>DEVMGR_SHOW_NONPRESENT_DEVICES</code> 项，并设置变量值为 <code>1</code></p>
<p><img src="01.png" alt="环境变量"></p>
<p>然后打开 <code>设备管理器</code> ，并在 <code>查看</code> 菜单里勾选上 <code>显示隐藏的设备</code> 的选项</p>
<p><img src="02.png" alt="设备管理器"></p>
<p>在 <code>磁盘驱动器</code> 和 <code>通用串行总线控制器</code> 两处可以看到 <code>半透明图标</code> 的历史设备记录</p>
<p><img src="03.png" alt="磁盘驱动器"></p>
<p><img src="04.png" alt="通用串行总线控制器"></p>
<p>在 <code>半透明图标</code> 的设备上，单击鼠标右键选择 <code>卸载</code> 就会删除该条设备记录</p>
<p><img src="05.png" alt="卸载设备"></p>
<h4 id="编程操作"><a href="#编程操作" class="headerlink" title="编程操作"></a>编程操作</h4><p>写代码实现手动卸载操作，需要用 <code>SetupDiRemoveDevice</code> 函数来实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetupDiRemoveDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    HDEVINFO         DeviceInfoSet,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ PSP_DEVINFO_DATA DeviceInfoData</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其他相关函数都在 <code>setupapi.h</code> 头文件中定义，所以需要加载该头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setupapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;setupapi.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<p>方法为：遍历所有 <code>USB</code> 设备，检查设备使用的服务是否是 <code>USBSTOR</code>，是的话就删除。<br>对应到手动操作：在 <code>设备管理器</code> 中卸载 <code>通用串行总线控制器</code> 中的 <code>USB 大容量存储设备</code> 项。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeleteUsbHistory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 删除USB设备相关记录</span></span><br><span class="line">    HDEVINFO hDevInfo = SetupDiGetClassDevs(<span class="literal">NULL</span>, <span class="string">&quot;USB&quot;</span>, <span class="literal">NULL</span>, DIGCF_ALLCLASSES);</span><br><span class="line">    <span class="keyword">if</span> (hDevInfo == INVALID_HANDLE_VALUE) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 根据设备类信息句柄枚举设备信息</span></span><br><span class="line">    DWORD dwDevIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> szBuffer[<span class="number">40</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SP_DEVINFO_DATA DevInfoData = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查询设备信息</span></span><br><span class="line">        ZeroMemory(&amp;DevInfoData, <span class="keyword">sizeof</span>(SP_DEVINFO_DATA));</span><br><span class="line">        DevInfoData.cbSize = <span class="keyword">sizeof</span>(SP_DEVINFO_DATA);</span><br><span class="line">        <span class="keyword">if</span> (!SetupDiEnumDeviceInfo(hDevInfo, dwDevIndex, &amp;DevInfoData)) <span class="keyword">break</span>;</span><br><span class="line">        dwDevIndex++;</span><br><span class="line">        <span class="comment">// 获取服务信息</span></span><br><span class="line">        ZeroMemory(szBuffer, <span class="keyword">sizeof</span>(szBuffer));</span><br><span class="line">        <span class="keyword">if</span> (!SetupDiGetDeviceRegistryProperty(hDevInfo, &amp;DevInfoData,</span><br><span class="line">            SPDRP_SERVICE, <span class="literal">NULL</span>, (PBYTE)szBuffer, <span class="keyword">sizeof</span>(szBuffer), <span class="literal">NULL</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 判断是不是USBSTOR和UASPStor</span></span><br><span class="line">        <span class="keyword">if</span> ((_stricmp(szBuffer, <span class="string">&quot;USBSTOR&quot;</span>) != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">            (_stricmp(szBuffer, <span class="string">&quot;UASPStor&quot;</span>) != <span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 卸载该设备</span></span><br><span class="line">        SetupDiRemoveDevice(hDevInfo, &amp;DevInfoData);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 获取的设备列表要手动销毁</span></span><br><span class="line">    SetupDiDestroyDeviceInfoList(hDevInfo);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除 <code>磁盘驱动器</code> 中的USB相关存储设备，需要遍历所有 <code>USBSTOR</code> 设备，直接删除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeleteUsbStorHistory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 删除USBSTOR设备相关记录</span></span><br><span class="line">    HDEVINFO hDevInfo = SetupDiGetClassDevs(<span class="literal">NULL</span>, <span class="string">&quot;USBSTOR&quot;</span>, <span class="literal">NULL</span>, DIGCF_ALLCLASSES);</span><br><span class="line">    <span class="keyword">if</span> (hDevInfo == INVALID_HANDLE_VALUE) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 根据设备类信息句柄枚举设备信息</span></span><br><span class="line">    DWORD dwDevIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> szBuffer[<span class="number">40</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SP_DEVINFO_DATA DevInfoData = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查询设备信息</span></span><br><span class="line">        ZeroMemory(&amp;DevInfoData, <span class="keyword">sizeof</span>(SP_DEVINFO_DATA));</span><br><span class="line">        DevInfoData.cbSize = <span class="keyword">sizeof</span>(SP_DEVINFO_DATA);</span><br><span class="line">        <span class="keyword">if</span> (!SetupDiEnumDeviceInfo(hDevInfo, dwDevIndex, &amp;DevInfoData)) <span class="keyword">break</span>;</span><br><span class="line">        dwDevIndex++;</span><br><span class="line">        <span class="comment">// 卸载该设备</span></span><br><span class="line">        SetupDiRemoveDevice(hDevInfo, &amp;DevInfoData);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 获取的设备列表要手动销毁</span></span><br><span class="line">    SetupDiDestroyDeviceInfoList(hDevInfo);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从Win8开始，操作系统提供了一种新的UASP协议。使用该协议时，对应的服务就变为 <code>UASPStor</code>，<br>该协议没有专门的设备类，需要在 <code>SCSI</code> 类中处理，然后再查询对应的<code>父设备</code>是否是 <code>UASPStor</code> 服务</p>
<p>获取父设备以及查询对应服务，相关函数在 <code>cfgmgr32.h</code> 中定义，但是使用 <code>VS2013</code> 时，选择兼容XP系统<br>编译，就会提示找不到 <code>cfgmgr32.lib</code>，所以就需要我们从WDK7.1中手动拷贝对应XP系统的库到工程中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cfgmgr32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;cfgmgr32.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeleteUaspStorHistory</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 删除UASPSTOR设备相关记录</span></span><br><span class="line">    HDEVINFO hDevInfo = SetupDiGetClassDevs(<span class="literal">NULL</span>, <span class="string">&quot;SCSI&quot;</span>, <span class="literal">NULL</span>, DIGCF_ALLCLASSES);</span><br><span class="line">    <span class="keyword">if</span> (hDevInfo == INVALID_HANDLE_VALUE) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 根据设备类信息句柄枚举设备信息</span></span><br><span class="line">    DWORD dwDevIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> szBuffer[<span class="number">40</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SP_DEVINFO_DATA DevInfoData = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    DEVINST DevInstParent = <span class="number">0</span>;</span><br><span class="line">    ULONG ulLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查询设备信息</span></span><br><span class="line">        ZeroMemory(&amp;DevInfoData, <span class="keyword">sizeof</span>(SP_DEVINFO_DATA));</span><br><span class="line">        DevInfoData.cbSize = <span class="keyword">sizeof</span>(SP_DEVINFO_DATA);</span><br><span class="line">        <span class="keyword">if</span> (!SetupDiEnumDeviceInfo(hDevInfo, dwDevIndex, &amp;DevInfoData)) <span class="keyword">break</span>;</span><br><span class="line">        dwDevIndex++;</span><br><span class="line">        <span class="comment">// 获取父设备实例</span></span><br><span class="line">        DevInstParent = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (CM_Get_Parent(&amp;DevInstParent, DevInfoData.DevInst, <span class="number">0</span>) != CR_SUCCESS) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 获取服务信息</span></span><br><span class="line">        ulLength = <span class="keyword">sizeof</span>(szBuffer);</span><br><span class="line">        <span class="keyword">if</span> (CM_Get_DevNode_Registry_Property(DevInstParent,</span><br><span class="line">            CM_DRP_SERVICE, <span class="literal">NULL</span>, szBuffer, &amp;ulLength, <span class="number">0</span>) != CR_SUCCESS) <span class="keyword">continue</span>;;</span><br><span class="line">        <span class="comment">// 判断是不是UASPStor</span></span><br><span class="line">        <span class="keyword">if</span> ((_stricmp(szBuffer, <span class="string">&quot;UASPStor&quot;</span>) != <span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 卸载该设备</span></span><br><span class="line">        SetupDiRemoveDevice(hDevInfo, &amp;DevInfoData);</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 获取的设备列表要手动销毁</span></span><br><span class="line">    SetupDiDestroyDeviceInfoList(hDevInfo);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>USB相关</category>
      </categories>
      <tags>
        <tag>USB相关</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层禁止USB存储设备写入功能(1)</title>
    <url>/2019/08/16/USB%E7%9B%B8%E5%85%B3/%E5%BA%94%E7%94%A8%E5%B1%82%E7%A6%81%E6%AD%A2USB%E5%AD%98%E5%82%A8%E8%AE%BE%E5%A4%87%E5%86%99%E5%85%A5%E5%8A%9F%E8%83%BD-1/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在应用层禁用USB存储设备有两个方向：一个是完全的禁用USB存储设备，既不能读也不能写。<br>另一个是限制USB存储设备只能读不能写。</p>
<h4 id="完全禁用"><a href="#完全禁用" class="headerlink" title="完全禁用"></a>完全禁用</h4><p>所有的USB存储设备都要挂接 <code>usbstor.sys</code> 驱动中，所以我们只要禁止这个驱动启动，就可以<br>禁止所有的USB存储设备，禁止的方法包括：直接把这个驱动改个名字，或者移动到别的文件夹，<br>还可以去注册表把 <code>usbstor</code> 服务的启动方式改为 <code>禁用</code> 等等。</p>
<p>在Win10系统中，某些USB存储设备会挂接到 <code>uaspstor.sys</code> 驱动中，也是同样的禁用方式。</p>
<p>以上方法是在USB存储设备 <code>加载之前</code> 进行拦截，我们还可以在 <code>加载之后</code> 再去阻止。比如：去掉<br>USB存储设备分区的盘符，主动弹出USB存储设备等。</p>
<p>那么如何知道USB存储设备已接入了呢，在有硬件设备加载后会触发 <code>WM_DEVICECHANGE</code> 消息，其<br><code>wParam</code> 参数为 <code>DBT_DEVICEARRIVAL</code>  时，表示设备接入，对应的 <code>lParam</code> 参数是描述设备信息的<br>结构体 <code>DEV_BROADCAST_HDR</code>，其成员 <code>dbch_devicetype</code> 描述的就是设备类型。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEV_BROADCAST_HDR</span> &#123;</span></span><br><span class="line">  DWORD dbch_size;</span><br><span class="line">  DWORD dbch_devicetype;</span><br><span class="line">  DWORD dbch_reserved;</span><br><span class="line">&#125; DEV_BROADCAST_HDR, *PDEV_BROADCAST_HDR;</span><br></pre></td></tr></table></figure>

<p>当 <code>dbch_devicetype</code> 类型为 <code>DEV_BROADCAST_VOLUME</code> 时，表示 <code>DEV_BROADCAST_HDR</code> 结构体实际上是<br><code>DEV_BROADCAST_VOLUME</code>  类型的结构体。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEV_BROADCAST_VOLUME</span> &#123;</span></span><br><span class="line">  DWORD dbcv_size;</span><br><span class="line">  DWORD dbcv_devicetype;</span><br><span class="line">  DWORD dbcv_reserved;</span><br><span class="line">  DWORD dbcv_unitmask;</span><br><span class="line">  WORD  dbcv_flags;</span><br><span class="line">&#125; DEV_BROADCAST_VOLUME, *PDEV_BROADCAST_VOLUME;</span><br></pre></td></tr></table></figure>

<p>其中 <code>dbcv_unitmask</code> 参数，按位表示加载设备的 <code>盘符</code>，即bit[0]表示A盘符，bit[1]表示B盘符，以此类推。<br>删除分区的盘符使用 <code>DeleteVolumeMountPoint</code> 函数，参数例如 <code>&quot;C:\&quot;</code> 的形式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">DeleteVolumeMountPoint</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPCTSTR lpszVolumeMountPoint</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> WM_DEVICECHANGE:</span><br><span class="line">    <span class="keyword">if</span> (wParam == DBT_DEVICEARRIVAL)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (((PDEV_BROADCAST_HDR)lParam)-&gt;dbch_devicetype == DBT_DEVTYP_VOLUME)</span><br><span class="line">        &#123;</span><br><span class="line">            DWORD dwUnit = ((PDEV_BROADCAST_VOLUME)lParam)-&gt;dbcv_unitmask;</span><br><span class="line">            <span class="keyword">char</span> szDriver[<span class="number">4</span>] = <span class="string">&quot;C:\\&quot;</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                szDriver[<span class="number">0</span>] = ((dwUnit &gt;&gt; i) &amp; <span class="number">1</span>) * (<span class="string">&#x27;A&#x27;</span> + i);</span><br><span class="line">                <span class="keyword">if</span> (szDriver[<span class="number">0</span>] != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    UINT uiType = GetDriveType(szDriver);</span><br><span class="line">                    <span class="keyword">if</span> (uiType == DRIVE_REMOVABLE)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 删除分区对应的盘符</span></span><br><span class="line">                        DeleteVolumeMountPoint(szDriver);</span><br><span class="line">                        <span class="comment">// 弹出对应盘符的设备</span></span><br><span class="line">                        EjectUsbStorVolume(szDriver[<span class="number">0</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (INT_PTR)TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure>

<p>弹出USB存储设备使用 <code>CM_Request_Device_Eject</code> 函数，但是这个函数使用的是 <code>设备实例</code> 来进行弹出，<br>所以就需要查找到 <code>盘符</code> 对应的 <code>设备实例</code>，我们可以通过 <code>STORAGE_DEVICE_NUMBER</code> 数据进行匹配。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CMAPI</span><br><span class="line">CONFIGRET</span><br><span class="line"><span class="function">WINAPI <span class="title">CM_Request_Device_Eject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      DEVINST        dnDevInst,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_opt_ PPNP_VETO_TYPE pVetoType,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_opt_ LPTSTR         pszVetoName,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      ULONG          ulNameLength,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      ULONG          ulFlags</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">STORAGE_DEVICE_NUMBER</span> &#123;</span></span><br><span class="line">  DEVICE_TYPE DeviceType;</span><br><span class="line">  ULONG       DeviceNumber;</span><br><span class="line">  ULONG       PartitionNumber;</span><br><span class="line">&#125; STORAGE_DEVICE_NUMBER, *PSTORAGE_DEVICE_NUMBER;</span><br></pre></td></tr></table></figure>

<p>如下为使用 <code>盘符</code> 查询 <code>STORAGE_DEVICE_NUMBER</code> 和枚举所有 <code>GUID_DEVINTERFACE_DISK</code> 设备查询的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;WinIoCtl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Setupapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Cfgmgr32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;Setupapi.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;Cfgmgr32.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EjectUsbStorVolume</span><span class="params">(<span class="keyword">char</span> Ch)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((Ch &lt; <span class="string">&#x27;A&#x27;</span>) || (Ch &gt; <span class="string">&#x27;Z&#x27;</span>)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 打开目标卷</span></span><br><span class="line">    <span class="keyword">char</span> szDriverVolume[<span class="number">8</span>] = <span class="string">&quot;\\\\.\\C:&quot;</span>;</span><br><span class="line">    szDriverVolume[<span class="number">4</span>] = Ch;</span><br><span class="line">    HANDLE hDevice = CreateFile(</span><br><span class="line">        szDriverVolume, GENERIC_WRITE | GENERIC_READ,</span><br><span class="line">        FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 查询目标卷的设备数字</span></span><br><span class="line">    DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">    STORAGE_DEVICE_NUMBER stDevNum = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    BOOL bRet = DeviceIoControl(hDevice, IOCTL_STORAGE_GET_DEVICE_NUMBER,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="number">0</span>, &amp;stDevNum, <span class="keyword">sizeof</span>(stDevNum), &amp;dwRet, <span class="literal">NULL</span>);</span><br><span class="line">    CloseHandle(hDevice); <span class="comment">// 先关句柄</span></span><br><span class="line">    <span class="keyword">if</span> (!bRet) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 根据设备数字查询对应设备实例</span></span><br><span class="line">    DEVINST DevInst = GetDevInstByDevNum(stDevNum);</span><br><span class="line">    <span class="keyword">if</span> (DevInst == <span class="number">0</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 获取父设备实例</span></span><br><span class="line">    DEVINST DevInstParent = <span class="number">0</span>;</span><br><span class="line">    CONFIGRET cr = CM_Get_Parent(&amp;DevInstParent, DevInst, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (cr != CR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 弹出设备实例对应的设备</span></span><br><span class="line">    ULONG ulStatus = <span class="number">0</span>;</span><br><span class="line">    ULONG ulProblemNum = <span class="number">0</span>;</span><br><span class="line">    cr = CM_Get_DevNode_Status(&amp;ulStatus, &amp;ulProblemNum, DevInstParent, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> ((cr == CR_SUCCESS) &amp;&amp; (ulStatus &amp; DN_REMOVABLE))</span><br><span class="line">    &#123;</span><br><span class="line">        CM_Request_Device_Eject(DevInstParent, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DEVINST <span class="title">GetDevInstByDevNum</span><span class="params">(STORAGE_DEVICE_NUMBER &amp;stDevNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取设备类信息的句柄</span></span><br><span class="line">    DWORD dwFlag = DIGCF_PRESENT | DIGCF_DEVICEINTERFACE;</span><br><span class="line">    HDEVINFO hDevInfo = SetupDiGetClassDevs(</span><br><span class="line">        &amp;GUID_DEVINTERFACE_DISK, <span class="literal">NULL</span>, <span class="literal">NULL</span>, dwFlag);</span><br><span class="line">    <span class="keyword">if</span> (hDevInfo == INVALID_HANDLE_VALUE) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 根据设备类信息句柄枚举设备信息</span></span><br><span class="line">    DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">    BOOL bRet = FALSE;</span><br><span class="line">    DWORD dwDevInst = <span class="number">0</span>;</span><br><span class="line">    DWORD dwDevIndex = <span class="number">0</span>;</span><br><span class="line">    HANDLE hDevice = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">char</span> Buffer[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SP_DEVINFO_DATA DevInfoData = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SP_DEVICE_INTERFACE_DATA DevInterfaceData = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PSP_DEVICE_INTERFACE_DETAIL_DATA pDevDetailData =</span><br><span class="line">        (PSP_DEVICE_INTERFACE_DETAIL_DATA)Buffer;</span><br><span class="line">    STORAGE_DEVICE_NUMBER stDevNumTemp = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查询设备信息</span></span><br><span class="line">        ZeroMemory(&amp;DevInfoData, <span class="keyword">sizeof</span>(SP_DEVINFO_DATA));</span><br><span class="line">        DevInfoData.cbSize = <span class="keyword">sizeof</span>(SP_DEVINFO_DATA);</span><br><span class="line">        <span class="keyword">if</span> (!SetupDiEnumDeviceInfo(hDevInfo, dwDevIndex, &amp;DevInfoData)) <span class="keyword">break</span>;</span><br><span class="line">        dwDevIndex++;</span><br><span class="line">        <span class="comment">// 获取服务信息</span></span><br><span class="line">        ZeroMemory(Buffer, <span class="keyword">sizeof</span>(Buffer));</span><br><span class="line">        <span class="keyword">if</span> (!SetupDiGetDeviceRegistryProperty(hDevInfo, &amp;DevInfoData,</span><br><span class="line">            SPDRP_ENUMERATOR_NAME, <span class="literal">NULL</span>, (PBYTE)Buffer, <span class="keyword">sizeof</span>(Buffer), <span class="literal">NULL</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 判断是不是USBSTOR和UASPStor服务</span></span><br><span class="line">        <span class="keyword">if</span> ((_stricmp(Buffer, <span class="string">&quot;USBSTOR&quot;</span>) != <span class="number">0</span>) &amp;&amp;</span><br><span class="line">            (_stricmp(Buffer, <span class="string">&quot;UASPStor&quot;</span>) != <span class="number">0</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 查询设备接口信息</span></span><br><span class="line">        ZeroMemory(&amp;DevInterfaceData, <span class="keyword">sizeof</span>(SP_DEVICE_INTERFACE_DATA));</span><br><span class="line">        DevInterfaceData.cbSize = <span class="keyword">sizeof</span>(SP_DEVICE_INTERFACE_DATA);</span><br><span class="line">        <span class="keyword">if</span> (!SetupDiEnumDeviceInterfaces(hDevInfo, <span class="literal">NULL</span>,</span><br><span class="line">            &amp;GUID_DEVINTERFACE_DISK, dwDevIndex - <span class="number">1</span>, &amp;DevInterfaceData)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 查询设备的路径</span></span><br><span class="line">        ZeroMemory(Buffer, <span class="keyword">sizeof</span>(Buffer));</span><br><span class="line">        pDevDetailData-&gt;cbSize = <span class="keyword">sizeof</span>(SP_DEVICE_INTERFACE_DETAIL_DATA);</span><br><span class="line">        <span class="keyword">if</span> (!SetupDiGetDeviceInterfaceDetail(hDevInfo,</span><br><span class="line">            &amp;DevInterfaceData, pDevDetailData, <span class="keyword">sizeof</span>(Buffer), <span class="literal">NULL</span>, <span class="literal">NULL</span>)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 打开目标设备</span></span><br><span class="line">        hDevice = CreateFile(</span><br><span class="line">            pDevDetailData-&gt;DevicePath, GENERIC_WRITE | GENERIC_READ,</span><br><span class="line">            FILE_SHARE_READ | FILE_SHARE_WRITE, <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (hDevice == INVALID_HANDLE_VALUE) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 查询目标的设备数字</span></span><br><span class="line">        ZeroMemory(&amp;stDevNumTemp, <span class="keyword">sizeof</span>(STORAGE_DEVICE_NUMBER));</span><br><span class="line">        bRet = DeviceIoControl(hDevice, IOCTL_STORAGE_GET_DEVICE_NUMBER,</span><br><span class="line">            <span class="literal">NULL</span>, <span class="number">0</span>, &amp;stDevNumTemp, <span class="keyword">sizeof</span>(stDevNumTemp), &amp;dwRet, <span class="literal">NULL</span>);</span><br><span class="line">        CloseHandle(hDevice); <span class="comment">// 先关句柄</span></span><br><span class="line">        <span class="keyword">if</span> (!bRet) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 对比设备类型和设备号</span></span><br><span class="line">        <span class="keyword">if</span> ((stDevNumTemp.DeviceType == stDevNum.DeviceType) &amp;&amp;</span><br><span class="line">            (stDevNumTemp.DeviceNumber == stDevNum.DeviceNumber))</span><br><span class="line">        &#123;</span><br><span class="line">            dwDevInst = DevInfoData.DevInst;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 获取的设备列表要手动销毁</span></span><br><span class="line">    SetupDiDestroyDeviceInfoList(hDevInfo);</span><br><span class="line">    <span class="keyword">return</span> dwDevInst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="限制只读"><a href="#限制只读" class="headerlink" title="限制只读"></a>限制只读</h4><p>我们可以通过配置注册表的方式来使U盘只读，打开注册表以下路径</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\StorageDevicePolicies</span><br></pre></td></tr></table></figure>

<p>如果未找到 <code>StorageDevicePolicies</code> 项，就手动创建该注册表项，然后在该项创建一个 <code>DWORD</code> 类型<br>的 <code>WriteProtect</code> 注册表值，配置这个值为 <code>0</code> 时，不限制只读，而配置成 <code>1</code> 时，U盘就变成只读的了。</p>
<p><img src="01.png" alt="注册表路径"></p>
<p>注意：改策略不是实时生效的，在改完以后新接入的U盘才受控制。</p>
]]></content>
      <categories>
        <category>USB相关</category>
      </categories>
      <tags>
        <tag>USB相关</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层遍历所有接入的USB设备(1)</title>
    <url>/2019/08/14/USB%E7%9B%B8%E5%85%B3/%E5%BA%94%E7%94%A8%E5%B1%82%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E6%8E%A5%E5%85%A5%E7%9A%84USB%E8%AE%BE%E5%A4%87-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>USB技术是一个庞大而复杂的技术体系，需要常年的深入研究才能窥探其中的一角。我们这里先从相对简单<br>的入手点开始介绍，实现在应用层遍历所有USB接口上的设备。代码基于 <code>WDK</code> 中的 <code>usbview</code> 来实现。</p>
<h4 id="USB描述符"><a href="#USB描述符" class="headerlink" title="USB描述符"></a>USB描述符</h4><p>在开始动手之前，我们需要先了解一下USB描述符的概念。USB描述符本身是一组数据的结构体，用来<br>记录USB设备本身的信息，以及该设备可以用于什么功能。系统会根据这些描述，来加载相关的驱动。</p>
<h4 id="描述符的分类"><a href="#描述符的分类" class="headerlink" title="描述符的分类"></a>描述符的分类</h4><p>共分为三大类：标准描述符、设备类描述符、厂商描述符。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>描述符</th>
<th>数值</th>
</tr>
</thead>
<tbody><tr>
<td>标准描述符</td>
<td>设备描述符（Device Descriptor)</td>
<td>0x01</td>
</tr>
<tr>
<td></td>
<td>配置描述符（Configuration Descriptor）</td>
<td>0x02</td>
</tr>
<tr>
<td></td>
<td>字符串描述符（String Descriptor）</td>
<td>0x03</td>
</tr>
<tr>
<td></td>
<td>接口描述符（Interface Descriptor）</td>
<td>0x04</td>
</tr>
<tr>
<td></td>
<td>端点描述符（EndPont Descriptor）</td>
<td>0x05</td>
</tr>
<tr>
<td>设备类描述符</td>
<td>人机接口类描述符（HID）</td>
<td>0x21</td>
</tr>
<tr>
<td></td>
<td>集线器类描述符（Hub Descriptor）</td>
<td>0x29</td>
</tr>
<tr>
<td>厂商描述符</td>
<td></td>
<td>0xFF</td>
</tr>
</tbody></table>
<p>更详细的信息可以从USB标准的相关网站获取（<a href="https://www.usb.org),这里只介绍部分信息./">https://www.usb.org），这里只介绍部分信息。</a></p>
<h5 id="设备描述符"><a href="#设备描述符" class="headerlink" title="设备描述符"></a>设备描述符</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USB_DEVICE_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    UCHAR bLength;</span><br><span class="line">    UCHAR bDescriptorType;</span><br><span class="line">    USHORT bcdUSB;</span><br><span class="line">    UCHAR bDeviceClass;</span><br><span class="line">    UCHAR bDeviceSubClass;</span><br><span class="line">    UCHAR bDeviceProtocol;</span><br><span class="line">    UCHAR bMaxPacketSize0;</span><br><span class="line">    USHORT idVendor;</span><br><span class="line">    USHORT idProduct;</span><br><span class="line">    USHORT bcdDevice;</span><br><span class="line">    UCHAR iManufacturer;</span><br><span class="line">    UCHAR iProduct;</span><br><span class="line">    UCHAR iSerialNumber;</span><br><span class="line">    UCHAR bNumConfigurations;</span><br><span class="line">&#125; USB_DEVICE_DESCRIPTOR, *PUSB_DEVICE_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>域</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bLength</td>
<td>数字</td>
<td>此描述符的字节数。</td>
</tr>
<tr>
<td>bDecriptorType</td>
<td>常量</td>
<td>描述符类型（此处应为0x01，即设备描述符）。</td>
</tr>
<tr>
<td>bcdUSB</td>
<td>BCD码</td>
<td>USB版本号（BCD码）。</td>
</tr>
<tr>
<td>bDeviceClass</td>
<td>设备类</td>
<td>bDeviceClass = 0 时，表示设备类型使用接口描述符中定义<br />的类型，且各个接口独立工作。<br />bDeviceClass = 0xFF 时，表示设备类型是由厂商自定义的。<br />bDeviceClass = 1 ~ 0xFE 时，查表可得对应设备类值，<br />该设备在不同的接口上支持不同的类。且这些接口可能<br />不能独立工作。此值指出了这些接口集体的类定义。</td>
</tr>
<tr>
<td>bDeviceSubClass</td>
<td>设备子类</td>
<td>这些码值的具体含义根据bDeviceClass 域来看。 <br/>如bDeviceClass 域为0，此域也须为0。 <br/>如bDeviceClass 域为0xFF，此域的所有值保留。</td>
</tr>
<tr>
<td>bDeviceProtocol</td>
<td>设备协议</td>
<td>这些码的值视bDeviceClass 和 bDeviceSubClass 的值而定。 <br/>如果设备支持设备类相关的协议，此码标志了设备类的值。<br />如果此域的值为0，则此设备不支持设备类相关的协议，<br />然而，可能它的接口支持设备类相关的协议。<br />如果此域的值为0xFF，此设备使用厂商定义的协议。</td>
</tr>
<tr>
<td>bMaxPacketSize0</td>
<td>数字</td>
<td>端点0的最大包大小（仅8,16,32,64为合法值）。</td>
</tr>
<tr>
<td>idVendor</td>
<td>ID</td>
<td>厂商标志（由USB-IF组织赋值）。</td>
</tr>
<tr>
<td>idProduct</td>
<td>ID</td>
<td>产品标志（由厂商赋值）。</td>
</tr>
<tr>
<td>bcdDevice</td>
<td>BCD码</td>
<td>设备版本号（BCD 码）。</td>
</tr>
<tr>
<td>iManufacturer</td>
<td>索引</td>
<td>描述厂商信息的字符串描述符的索引值。</td>
</tr>
<tr>
<td>iProduct</td>
<td>索引</td>
<td>描述产品信息的字串描述符的索引值。</td>
</tr>
<tr>
<td>iSerialNumber</td>
<td>索引</td>
<td>描述设备序列号信息的字串描述符的索引值。</td>
</tr>
<tr>
<td>bNumConfigurations</td>
<td>数字</td>
<td>可能的配置描述符数目。</td>
</tr>
</tbody></table>
<h5 id="配置描述符"><a href="#配置描述符" class="headerlink" title="配置描述符"></a>配置描述符</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USB_CONFIGURATION_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    UCHAR bLength;</span><br><span class="line">    UCHAR bDescriptorType;</span><br><span class="line">    USHORT wTotalLength;</span><br><span class="line">    UCHAR bNumInterfaces;</span><br><span class="line">    UCHAR bConfigurationValue;</span><br><span class="line">    UCHAR iConfiguration;</span><br><span class="line">    UCHAR bmAttributes;</span><br><span class="line">    UCHAR MaxPower;</span><br><span class="line">&#125; USB_CONFIGURATION_DESCRIPTOR, *PUSB_CONFIGURATION_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>域</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bLength</td>
<td>数字</td>
<td>此描述表的字节数长度。</td>
</tr>
<tr>
<td>bDescriptorType</td>
<td>常量</td>
<td>配置描述符类型（此处为0x02）。</td>
</tr>
<tr>
<td>wTotalLength</td>
<td>数字</td>
<td>此配置信息的总长（包括配置，接口，端点和设备类及<br />厂商定义的描述符），即：将要返回的配置信息总长度。</td>
</tr>
<tr>
<td>bNumInterfaces</td>
<td>数字</td>
<td>此配置所支持的接口个数。</td>
</tr>
<tr>
<td>bConfigurationValue</td>
<td>数字</td>
<td>在 SetConfiguration() 请求中用作参数来选定此配置。</td>
</tr>
<tr>
<td>iConfiguration</td>
<td>索引</td>
<td>描述此配置的字串描述符的索引。</td>
</tr>
<tr>
<td>bmAttributes</td>
<td>位图</td>
<td>D7： 保留（设为1） <br/>D6： 自给电源 <br/>D5： 远程唤醒 <br/>D4 ~ D0：保留（设为1） <br/>一个既用总线电源又有自给电源的设备会在MaxPower域<br />指出需要从总线取的电量。并设置D6为1。运行时期的实际<br />电源模式可由GetStatus(DEVICE) 请求得到。</td>
</tr>
<tr>
<td>MaxPower</td>
<td>毫安</td>
<td>在此配置下的总线电源耗费量。以 2mA 为一个单位。</td>
</tr>
</tbody></table>
<h5 id="字符串描述符"><a href="#字符串描述符" class="headerlink" title="字符串描述符"></a>字符串描述符</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USB_STRING_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    UCHAR bLength;</span><br><span class="line">    UCHAR bDescriptorType;</span><br><span class="line">    WCHAR bString[<span class="number">1</span>];</span><br><span class="line">&#125; USB_STRING_DESCRIPTOR, *PUSB_STRING_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>域</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bLength</td>
<td>数字</td>
<td>此描述表的字节数（bString域的数值N＋2）</td>
</tr>
<tr>
<td>bDescriptorType</td>
<td>常量</td>
<td>字符串描述符类型（此处应为0x03）</td>
</tr>
<tr>
<td>bString</td>
<td>字符串</td>
<td>宽字符字符串（WCHAR）类型</td>
</tr>
</tbody></table>
<p><code>显示语言</code> 的字符串描述符与 <code>显示信息</code> 的字符串描述符的区别在于<code>bStrings</code>项的不同。<br>对于 <code>显示语言</code> 的字符串描述符来说 <code>bStrings</code> 项由多个 <code>wLANGID[n]</code> 数组元素组成，<br>每个 <code>wLANGID[n]</code> 是一个双字节的代表语言的ID值。一般都是 <code>英语(美国)0x0409</code>。<br>而对于显示信息的字符串描述符而言，<code>bStrings</code> 则是描述信息的一组 <code>UNICODE</code> 编码。</p>
<h5 id="接口描述符"><a href="#接口描述符" class="headerlink" title="接口描述符"></a>接口描述符</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USB_INTERFACE_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    UCHAR bLength;</span><br><span class="line">    UCHAR bDescriptorType;</span><br><span class="line">    UCHAR bInterfaceNumber;</span><br><span class="line">    UCHAR bAlternateSetting;</span><br><span class="line">    UCHAR bNumEndpoints;</span><br><span class="line">    UCHAR bInterfaceClass;</span><br><span class="line">    UCHAR bInterfaceSubClass;</span><br><span class="line">    UCHAR bInterfaceProtocol;</span><br><span class="line">    UCHAR iInterface;</span><br><span class="line">&#125; USB_INTERFACE_DESCRIPTOR, *PUSB_INTERFACE_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>域</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bLength</td>
<td>数字</td>
<td>接口描述符的字节数大小</td>
</tr>
<tr>
<td>bDescriptorType</td>
<td>常量</td>
<td>接口描述符的类型编号</td>
</tr>
<tr>
<td>bInterfaceNumber</td>
<td>数字</td>
<td>接口的编号</td>
</tr>
<tr>
<td>bAlternateSetting</td>
<td>数字</td>
<td>可替换的接口描述符编号。实际就是接口的描述符的编号。</td>
</tr>
<tr>
<td>bNumEndpoints</td>
<td>数字</td>
<td>该接口使用的端点数，不包括端点0</td>
</tr>
<tr>
<td>bInterfaceClass</td>
<td>接口类</td>
<td>接口类，可以通过查表获知</td>
</tr>
<tr>
<td>bInterfaceSubClass</td>
<td>接口子类</td>
<td>接口子类</td>
</tr>
<tr>
<td>bInterfaceProtocol</td>
<td>接口协议</td>
<td>接口遵循的协议</td>
</tr>
<tr>
<td>iInterface</td>
<td>索引</td>
<td>描述该接口的字符串索引值</td>
</tr>
</tbody></table>
<h5 id="端点描述符"><a href="#端点描述符" class="headerlink" title="端点描述符"></a>端点描述符</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USB_ENDPOINT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    UCHAR bLength;</span><br><span class="line">    UCHAR bDescriptorType;</span><br><span class="line">    UCHAR bEndpointAddress;</span><br><span class="line">    UCHAR bmAttributes;</span><br><span class="line">    USHORT wMaxPacketSize;</span><br><span class="line">    UCHAR bInterval;</span><br><span class="line">&#125; USB_ENDPOINT_DESCRIPTOR, *PUSB_ENDPOINT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>域</th>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bLength</td>
<td>数字</td>
<td>端点描述符字节数大小</td>
</tr>
<tr>
<td>bDescriptorType</td>
<td>常量</td>
<td>端点描述符类型编号</td>
</tr>
<tr>
<td>bEndpointAddress</td>
<td>数字</td>
<td>端点地址及输入输出属性</td>
</tr>
<tr>
<td>bmAttributes</td>
<td>位图</td>
<td>端点的传输类型属性：0~1bit定义了传输类型<br />00=控制传输、01=同步传输、10=批量传输、11=中断传输。</td>
</tr>
<tr>
<td>wMaxPacketSize</td>
<td>数字</td>
<td>端点收、发的最大包大小</td>
</tr>
<tr>
<td>bInterval</td>
<td>毫秒</td>
<td>对周期性端点的访问间隔：同步传输，其值必须为1</td>
</tr>
</tbody></table>
<h4 id="设备类型的种类"><a href="#设备类型的种类" class="headerlink" title="设备类型的种类"></a>设备类型的种类</h4><h5 id="设备类别bDeviceClass"><a href="#设备类别bDeviceClass" class="headerlink" title="设备类别bDeviceClass"></a>设备类别bDeviceClass</h5><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>使用接口描述符中提供的类别</td>
</tr>
<tr>
<td>0x02</td>
<td>通信类（CDC）</td>
</tr>
<tr>
<td>0x09</td>
<td>集线器类</td>
</tr>
<tr>
<td>0xDC</td>
<td>用于诊断用途的设备类</td>
</tr>
<tr>
<td>0xFE</td>
<td>混杂类型设备类</td>
</tr>
<tr>
<td>0xFF</td>
<td>厂商定义的设备类</td>
</tr>
</tbody></table>
<h5 id="接口类别bInterfaceClass"><a href="#接口类别bInterfaceClass" class="headerlink" title="接口类别bInterfaceClass"></a>接口类别bInterfaceClass</h5><table>
<thead>
<tr>
<th>值</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0x01</td>
<td>音频类</td>
</tr>
<tr>
<td>0x02</td>
<td>通信类（CDC）</td>
</tr>
<tr>
<td>0x03</td>
<td>人机接口类（HID）</td>
</tr>
<tr>
<td>0x05</td>
<td>物理类</td>
</tr>
<tr>
<td>0x06</td>
<td>图像类</td>
</tr>
<tr>
<td>0x07</td>
<td>打印机类</td>
</tr>
<tr>
<td>0x08</td>
<td>大数据存储类</td>
</tr>
<tr>
<td>0x09</td>
<td>集线器类</td>
</tr>
<tr>
<td>0x0A</td>
<td>CDC数据类</td>
</tr>
<tr>
<td>0x0B</td>
<td>智能卡类</td>
</tr>
<tr>
<td>0x0D</td>
<td>安全类</td>
</tr>
<tr>
<td>0x0E</td>
<td>视频类</td>
</tr>
<tr>
<td>0x0F</td>
<td>个人医疗护理类</td>
</tr>
<tr>
<td>0x10</td>
<td>音频/视频设备类</td>
</tr>
<tr>
<td>0xDC</td>
<td>诊断设备类</td>
</tr>
<tr>
<td>0xE0</td>
<td>无线控制器类</td>
</tr>
<tr>
<td>0xEF</td>
<td>混杂设备类</td>
</tr>
<tr>
<td>0xFE</td>
<td>特定应用类（包括红外的桥接器等）</td>
</tr>
<tr>
<td>0xFF</td>
<td>厂商定义的设备</td>
</tr>
</tbody></table>
<h5 id="类别的交叉和独享"><a href="#类别的交叉和独享" class="headerlink" title="类别的交叉和独享"></a>类别的交叉和独享</h5><table>
<thead>
<tr>
<th>Base Class</th>
<th>Usage</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>0x00</td>
<td>Device</td>
<td>Use class information in the Interface Descriptors</td>
</tr>
<tr>
<td>0x01</td>
<td>Interface</td>
<td>Audio</td>
</tr>
<tr>
<td>0x02</td>
<td>Both</td>
<td>Communications and CDC Control</td>
</tr>
<tr>
<td>0x03</td>
<td>Interface</td>
<td>HID (Human Interface Device)</td>
</tr>
<tr>
<td>0x05</td>
<td>Interface</td>
<td>Physical</td>
</tr>
<tr>
<td>0x06</td>
<td>Interface</td>
<td>Image</td>
</tr>
<tr>
<td>0x07</td>
<td>Interface</td>
<td>Printer</td>
</tr>
<tr>
<td>0x08</td>
<td>Interface</td>
<td>Mass Storage</td>
</tr>
<tr>
<td>0x09</td>
<td>Device</td>
<td>Hub</td>
</tr>
<tr>
<td>0x0A</td>
<td>Interface</td>
<td>CDC-Data</td>
</tr>
<tr>
<td>0x0B</td>
<td>Interface</td>
<td>Smart Card</td>
</tr>
<tr>
<td>0x0D</td>
<td>Interface</td>
<td>Content Security</td>
</tr>
<tr>
<td>0x0E</td>
<td>Interface</td>
<td>Video</td>
</tr>
<tr>
<td>0x0F</td>
<td>Interface</td>
<td>Personal Healthcare</td>
</tr>
<tr>
<td>0x10</td>
<td>Interface</td>
<td>Audio/Video Devices</td>
</tr>
<tr>
<td>0xDC</td>
<td>Both</td>
<td>Diagnostic Device</td>
</tr>
<tr>
<td>0xE0</td>
<td>Interface</td>
<td>Wireless Controller</td>
</tr>
<tr>
<td>0xEF</td>
<td>Both</td>
<td>Miscellaneous</td>
</tr>
<tr>
<td>0xFE</td>
<td>Interface</td>
<td>Application Specific</td>
</tr>
<tr>
<td>0xFF</td>
<td>Both</td>
<td>Vendor Specific</td>
</tr>
</tbody></table>
<p>（此表也适用于标准命令Get_Descriptor中wValue域高字节的取值含义）</p>
]]></content>
      <categories>
        <category>USB相关</category>
      </categories>
      <tags>
        <tag>USB相关</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层遍历所有接入的USB设备(2)</title>
    <url>/2019/08/15/USB%E7%9B%B8%E5%85%B3/%E5%BA%94%E7%94%A8%E5%B1%82%E9%81%8D%E5%8E%86%E6%89%80%E6%9C%89%E6%8E%A5%E5%85%A5%E7%9A%84USB%E8%AE%BE%E5%A4%87-2/</url>
    <content><![CDATA[<h4 id="查询描述符"><a href="#查询描述符" class="headerlink" title="查询描述符"></a>查询描述符</h4><p>USB驱动对外提供了一系列用来查询描述符的控制码，所有控制码在 <code>usbioctl.h</code> 头文件中定义。</p>
<p>从结构上来说，所有的USB设备起始于 <code>根控制器(Host Controller)</code>，然后下边挂接 <code>HUB</code> 进行扩展，<br>整体是一个树形结构。<code>根控制器</code> 可以同时存在多个，但一般情况下只有一个 <code>根控制器</code>，每个 <code>根控制器</code><br>对外提供的访问名称为 <code>&quot;\\.\HCDx&quot;</code> ，x为数字，比如第一个 <code>根控制器</code> 为 <code>&quot;\\.\HCD0&quot;</code>。</p>
<h4 id="查询的流程"><a href="#查询的流程" class="headerlink" title="查询的流程"></a>查询的流程</h4><p>工作流程：<br>1、从 <code>根控制器</code> 开始，查询 <code>RootHub</code> 名称，然后打开 <code>RootHub</code> 设备。<br>2、查询 <code>RootHub</code> 设备 <code>端口</code> 的数量，查询每个 <code>端口</code> 连接的设备信息。<br>3、如果 <code>端口</code> 连接的是 <code>扩展Hub</code> 设备，跟 <code>RootHub</code> 一样查询并打开设备。<br>4、如果 <code>端口</code> 连接的不是Hub设备，就可以查询这个设备的所有信息。</p>
<p><img src="01.png" alt="工作流程"></p>
<p>如下为相关代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUBNAME_LEN 128</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HUBNAME_LEN_WIDE 256</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">HUB_NAME</span> &#123;</span></span><br><span class="line">    WCHAR szNameW[HUBNAME_LEN];</span><br><span class="line">&#125; HUB_NAME, *PHUB_NAME;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EnumHost</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开HCD0设备</span></span><br><span class="line">    HANDLE hHCDevice = CreateFileW(</span><br><span class="line">        <span class="string">L&quot;\\\\.\\HCD0&quot;</span>,</span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">        FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">        <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hHCDevice == INVALID_HANDLE_VALUE) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 查询RootHub设备名</span></span><br><span class="line">    HUB_NAME stRootHub = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 例如:\\.\USB#ROOT_HUB30#4&amp;5375334&amp;0&amp;0#&#123;f18a0e88-c30c-11d0-8815-00a0c906bed8&#125;</span></span><br><span class="line">    BOOL bRet = GetRootHubName(hHCDevice, stRootHub);</span><br><span class="line">    CloseHandle(hHCDevice); <span class="comment">// 先关句柄</span></span><br><span class="line">    <span class="keyword">if</span> (!bRet) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 遍历RootHub下的设备</span></span><br><span class="line">    <span class="keyword">if</span> (!EnumHub(stRootHub)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetRootHubName</span><span class="params">(HANDLE hHCDevice, HUB_NAME &amp;stRootHub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> szBuffer[HUBNAME_LEN_WIDE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PUSB_ROOT_HUB_NAME pHubName = (PUSB_ROOT_HUB_NAME)szBuffer;</span><br><span class="line">    HUB_NAME stTemp = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 获取连接到Host Controller的Root Hub名称</span></span><br><span class="line">    BOOL isSuccess = DeviceIoControl(</span><br><span class="line">        hHCDevice,</span><br><span class="line">        IOCTL_USB_GET_ROOT_HUB_NAME,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="number">0</span>,</span><br><span class="line">        pHubName, HUBNAME_LEN_WIDE,</span><br><span class="line">        &amp;dwSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!isSuccess) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">if</span> (pHubName-&gt;ActualLength &gt; HUBNAME_LEN_WIDE) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 拼接字符串</span></span><br><span class="line">    wcscpy_s(stRootHub.szwName, HUBNAME_LEN, <span class="string">L&quot;\\\\.\\&quot;</span>);</span><br><span class="line">    wcscat_s(stRootHub.szwName, HUBNAME_LEN, pHubName-&gt;RootHubName);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EnumHub</span><span class="params">(HUB_NAME &amp;stHubName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 尝试打开Hub设备</span></span><br><span class="line">    HANDLE hHubDevice = CreateFileW(</span><br><span class="line">        stHubName.szwName,</span><br><span class="line">        GENERIC_READ | GENERIC_WRITE,</span><br><span class="line">        FILE_SHARE_READ | FILE_SHARE_WRITE,</span><br><span class="line">        <span class="literal">NULL</span>, OPEN_EXISTING, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hHubDevice == INVALID_HANDLE_VALUE) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 遍历Hub设备的节点信息，用来获取端口数量</span></span><br><span class="line">    ULONG nSize = <span class="number">0</span>;</span><br><span class="line">    USB_NODE_INFORMATION stHubInfo = &#123; UsbHub &#125;;</span><br><span class="line">    BOOL isSuccess = DeviceIoControl(</span><br><span class="line">        hHubDevice,</span><br><span class="line">        IOCTL_USB_GET_NODE_INFORMATION,</span><br><span class="line">        &amp;stHubInfo, <span class="keyword">sizeof</span>(USB_NODE_INFORMATION),</span><br><span class="line">        &amp;stHubInfo, <span class="keyword">sizeof</span>(USB_NODE_INFORMATION),</span><br><span class="line">        &amp;nSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!isSuccess)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hHubDevice);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检索Hub的所有端口内容</span></span><br><span class="line">    isSuccess = EnumHubPorts(hHubDevice,</span><br><span class="line">        stHubInfo.u.HubInformation.HubDescriptor.bNumberOfPorts);</span><br><span class="line">    CloseHandle(hHubDevice);</span><br><span class="line">    <span class="keyword">return</span> isSuccess;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EnumHubPorts</span><span class="params">(HANDLE hHubDevice, UCHAR nNumPorts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 申请连接节点信息的空间</span></span><br><span class="line">    DWORD dwSize = <span class="keyword">sizeof</span>(USB_NODE_CONNECTION_INFORMATION) +</span><br><span class="line">        <span class="keyword">sizeof</span>(USB_PIPE_INFO) * <span class="number">30</span>;</span><br><span class="line">    PUSB_NODE_CONNECTION_INFORMATION pConnInfo =</span><br><span class="line">        (PUSB_NODE_CONNECTION_INFORMATION)<span class="built_in">malloc</span>(dwSize);</span><br><span class="line">    <span class="keyword">if</span> (pConnInfo == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 循环检索端口，端口从1开始，没有0端口</span></span><br><span class="line">    BOOL isSuccess = FALSE;</span><br><span class="line">    HUB_NAME stExtHub = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PUSB_DESCRIPTOR_REQUEST pDescRequest = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (UCHAR i = <span class="number">1</span>; i &lt;= nNumPorts; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(pConnInfo, <span class="number">0</span>, dwSize);</span><br><span class="line">        pConnInfo-&gt;ConnectionIndex = i;</span><br><span class="line">        <span class="comment">// 获取对应端口连接设备的信息</span></span><br><span class="line">        isSuccess = DeviceIoControl(</span><br><span class="line">            hHubDevice,</span><br><span class="line">            IOCTL_USB_GET_NODE_CONNECTION_INFORMATION,</span><br><span class="line">            pConnInfo, dwSize,</span><br><span class="line">            pConnInfo, dwSize,</span><br><span class="line">            &amp;dwSize, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 访问失败，进入下次循环</span></span><br><span class="line">        <span class="keyword">if</span> (!isSuccess) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 端口未连接设备，进入下次循环</span></span><br><span class="line">        <span class="keyword">if</span> (pConnInfo-&gt;ConnectionStatus != DeviceConnected) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 如果端口连接的是HUB</span></span><br><span class="line">        <span class="keyword">if</span> (pConnInfo-&gt;DeviceIsHub)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">memset</span>(&amp;stExtHub, <span class="number">0</span>, <span class="keyword">sizeof</span>(HUB_NAME));</span><br><span class="line">            <span class="keyword">if</span> (GetExtHubName(hHubDevice, i, stExtHub))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 遍历扩展Hub下的设备</span></span><br><span class="line">                EnumHub(stExtHub);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line">        <span class="comment">// 设备描述符信息</span></span><br><span class="line">        pConnInfo-&gt;DeviceDescriptor;</span><br><span class="line">        <span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line">        <span class="comment">// 获取配置描述符信息</span></span><br><span class="line">        pDescRequest = GetConfigDescriptor(hHubDevice, i);</span><br><span class="line">        <span class="keyword">if</span> (pDescRequest == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line">        <span class="comment">// 配置描述符中包含接口描述符</span></span><br><span class="line">        GetInterfaceDescriptor(pDescRequest);</span><br><span class="line">        <span class="built_in">free</span>(pDescRequest);</span><br><span class="line">        <span class="comment">//////////////////////////////////////////////////////</span></span><br><span class="line">        <span class="comment">// 获取字符串描述符描述信息</span></span><br><span class="line">        GetStringDescriptor(hHubDevice, i, pConnInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历完毕</span></span><br><span class="line">    <span class="built_in">free</span>(pConnInfo);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetExtHubName</span><span class="params">(HANDLE hHubDevice, UCHAR bPortIndex, HUB_NAME &amp;stExtHub)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 设置访问的端口</span></span><br><span class="line">    <span class="keyword">char</span> szBuffer[HUBNAME_LEN_WIDE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PUSB_NODE_CONNECTION_NAME pNodeName = (PUSB_NODE_CONNECTION_NAME)szBuffer;</span><br><span class="line">    pNodeName-&gt;ConnectionIndex = bPortIndex;</span><br><span class="line">    <span class="comment">// 获取扩展Hub名称</span></span><br><span class="line">    ULONG dwSize = <span class="number">0</span>;</span><br><span class="line">    BOOL isSuccess = DeviceIoControl(</span><br><span class="line">        hHubDevice,</span><br><span class="line">        IOCTL_USB_GET_NODE_CONNECTION_NAME,</span><br><span class="line">        pNodeName, HUBNAME_LEN_WIDE,</span><br><span class="line">        pNodeName, HUBNAME_LEN_WIDE,</span><br><span class="line">        &amp;dwSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!isSuccess) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">if</span> (pNodeName-&gt;ActualLength &gt; HUBNAME_LEN_WIDE) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 拼接字符串</span></span><br><span class="line">    wcscpy_s(stExtHub.szwName, HUBNAME_LEN, <span class="string">L&quot;\\\\.\\&quot;</span>);</span><br><span class="line">    wcscat_s(stExtHub.szwName, HUBNAME_LEN, pNodeName-&gt;NodeName);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PUSB_DESCRIPTOR_REQUEST <span class="title">GetConfigDescriptor</span><span class="params">(HANDLE hHubDevice, UCHAR bPortIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构造第1次发送的请求内容</span></span><br><span class="line">    UCHAR bBuffer[<span class="keyword">sizeof</span>(USB_DESCRIPTOR_REQUEST) +</span><br><span class="line">        <span class="keyword">sizeof</span>(USB_CONFIGURATION_DESCRIPTOR)] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PUSB_DESCRIPTOR_REQUEST pDescReq = (PUSB_DESCRIPTOR_REQUEST)bBuffer;</span><br><span class="line">    <span class="comment">// 当前HUB下访问的端口索引</span></span><br><span class="line">    pDescReq-&gt;ConnectionIndex = bPortIndex;</span><br><span class="line">    <span class="comment">// USBD will automatically initialize these fields:</span></span><br><span class="line">    <span class="comment">//     bmRequest = 0x80</span></span><br><span class="line">    <span class="comment">//     bRequest  = 0x06</span></span><br><span class="line">    <span class="comment">// We must inititialize these fields:</span></span><br><span class="line">    <span class="comment">//     wValue    = Descriptor Type (high) and Descriptor Index (low byte)</span></span><br><span class="line">    <span class="comment">//     wIndex    = Zero (or Language ID for String Descriptors)</span></span><br><span class="line">    <span class="comment">//     wLength   = Length of descriptor buffer</span></span><br><span class="line">    pDescReq-&gt;SetupPacket.wValue = (USB_CONFIGURATION_DESCRIPTOR_TYPE &lt;&lt; <span class="number">8</span>) | <span class="number">0</span>;</span><br><span class="line">    pDescReq-&gt;SetupPacket.wLength = <span class="keyword">sizeof</span>(USB_CONFIGURATION_DESCRIPTOR);</span><br><span class="line">    <span class="comment">// 第1次发送请求获取实际的长度</span></span><br><span class="line">    DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">    BOOL isSuccess = DeviceIoControl(</span><br><span class="line">        hHubDevice,</span><br><span class="line">        IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION,</span><br><span class="line">        pDescReq, <span class="keyword">sizeof</span>(bBuffer),</span><br><span class="line">        pDescReq, <span class="keyword">sizeof</span>(bBuffer),</span><br><span class="line">        &amp;dwSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 获取失败则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!isSuccess) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 构造第2次发送的请求内容</span></span><br><span class="line">    PUSB_CONFIGURATION_DESCRIPTOR pConfigDesc =</span><br><span class="line">        (PUSB_CONFIGURATION_DESCRIPTOR)(pDescReq + <span class="number">1</span>);</span><br><span class="line">    dwSize = <span class="keyword">sizeof</span>(USB_DESCRIPTOR_REQUEST) + pConfigDesc-&gt;wTotalLength;</span><br><span class="line">    <span class="comment">// 申请实际需要的内存空间</span></span><br><span class="line">    pDescReq = (PUSB_DESCRIPTOR_REQUEST)<span class="built_in">malloc</span>(dwSize);</span><br><span class="line">    <span class="keyword">if</span> (pDescReq == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pDescReq, <span class="number">0</span>, dwSize);</span><br><span class="line">    <span class="comment">// 当前HUB下访问的端口索引</span></span><br><span class="line">    pDescReq-&gt;ConnectionIndex = bPortIndex;</span><br><span class="line">    <span class="comment">// USBD will automatically initialize these fields:</span></span><br><span class="line">    <span class="comment">//     bmRequest = 0x80</span></span><br><span class="line">    <span class="comment">//     bRequest  = 0x06</span></span><br><span class="line">    <span class="comment">// We must inititialize these fields:</span></span><br><span class="line">    <span class="comment">//     wValue    = Descriptor Type (high) and Descriptor Index (low byte)</span></span><br><span class="line">    <span class="comment">//     wIndex    = Zero (or Language ID for String Descriptors)</span></span><br><span class="line">    <span class="comment">//     wLength   = Length of descriptor buffer</span></span><br><span class="line">    pDescReq-&gt;SetupPacket.wValue = (USB_CONFIGURATION_DESCRIPTOR_TYPE &lt;&lt; <span class="number">8</span>) | <span class="number">0</span>;</span><br><span class="line">    pDescReq-&gt;SetupPacket.wLength = pConfigDesc-&gt;wTotalLength;</span><br><span class="line">    <span class="comment">// 第2次发送请求获取实际的内容</span></span><br><span class="line">    isSuccess = DeviceIoControl(</span><br><span class="line">        hHubDevice,</span><br><span class="line">        IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION,</span><br><span class="line">        pDescReq, dwSize,</span><br><span class="line">        pDescReq, dwSize,</span><br><span class="line">        &amp;dwSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 获取失败则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!isSuccess)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pDescReq);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pDescReq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PUSB_INTERFACE_DESCRIPTOR <span class="title">GetInterfaceDescriptor</span><span class="params">(PUSB_DESCRIPTOR_REQUEST pDescReq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化数据</span></span><br><span class="line">    PUSB_CONFIGURATION_DESCRIPTOR pConfigDesc =</span><br><span class="line">        PUSB_CONFIGURATION_DESCRIPTOR(pDescReq + <span class="number">1</span>);</span><br><span class="line">    PUCHAR pDescEnd = (PUCHAR)pConfigDesc + pConfigDesc-&gt;wTotalLength;</span><br><span class="line">    PUSB_COMMON_DESCRIPTOR pCommonDesc = (PUSB_COMMON_DESCRIPTOR)pConfigDesc;</span><br><span class="line">    <span class="comment">// 循环获取Interface Descriptor信息</span></span><br><span class="line">    <span class="keyword">while</span> (((PUCHAR)pCommonDesc + <span class="keyword">sizeof</span>(USB_COMMON_DESCRIPTOR) &lt; pDescEnd)</span><br><span class="line">        &amp;&amp; ((PUCHAR)pCommonDesc + pCommonDesc-&gt;bLength &lt;= pDescEnd))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pCommonDesc-&gt;bDescriptorType == USB_INTERFACE_DESCRIPTOR_TYPE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 目前只获取第1个（默认）接口信息</span></span><br><span class="line">            <span class="keyword">return</span> (PUSB_INTERFACE_DESCRIPTOR)pCommonDesc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下一个描述信息</span></span><br><span class="line">        pCommonDesc = (PUSB_COMMON_DESCRIPTOR)</span><br><span class="line">            ((PUCHAR)pCommonDesc + pCommonDesc-&gt;bLength);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetAllStringDescriptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN HANDLE hHubDevice, IN UCHAR  bPortIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PUSB_NODE_CONNECTION_INFORMATION pConnInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取String Descriptor的语言列表</span></span><br><span class="line">    PUSB_DESCRIPTOR_REQUEST pLangReq =</span><br><span class="line">        GetStringDescriptor(hHubDevice, bPortIndex, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pLangReq == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 语言ID的处理(语言ID是USHORT大小)</span></span><br><span class="line">    PUSB_STRING_DESCRIPTOR pStringLang =</span><br><span class="line">        (PUSB_STRING_DESCRIPTOR)(pLangReq + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 检测语言信息长度</span></span><br><span class="line">    <span class="keyword">if</span> (pStringLang-&gt;bLength &lt; <span class="keyword">sizeof</span>(USB_STRING_DESCRIPTOR))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    USHORT numLanguageIDs = (pStringLang-&gt;bLength -</span><br><span class="line">        <span class="keyword">sizeof</span>(USB_STRING_DESCRIPTOR) + <span class="keyword">sizeof</span>(WCHAR)) / <span class="number">2</span>;</span><br><span class="line">    PUSHORT pLanguageIDs = (PUSHORT)&amp;pStringLang-&gt;bString[<span class="number">0</span>];</span><br><span class="line">    <span class="comment">// 根据语言列表获取描述信息(这里只获取第1个)</span></span><br><span class="line">    PUSB_DESCRIPTOR_REQUEST pDescReq = <span class="literal">NULL</span>;</span><br><span class="line">    PUSB_STRING_DESCRIPTOR  pStringDesc = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 获取序列号信息</span></span><br><span class="line">    <span class="keyword">if</span> (pConnInfo-&gt;DeviceDescriptor.iSerialNumber != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pDescReq = GetStringDescriptor(</span><br><span class="line">            hHubDevice, bPortIndex,</span><br><span class="line">            pConnInfo-&gt;DeviceDescriptor.iSerialNumber,</span><br><span class="line">            pLanguageIDs[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">if</span> (pDescReq != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 跳过描述请求的头部</span></span><br><span class="line">            pStringDesc = (PUSB_STRING_DESCRIPTOR)(pDescReq + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// ……</span></span><br><span class="line">            <span class="built_in">free</span>(pDescReq);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pLangReq);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PUSB_DESCRIPTOR_REQUEST <span class="title">GetStringDescriptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HANDLE hHubDevice, UCHAR  bPortIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">    UCHAR  bDescIndex, USHORT wLanguageID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 构造发送的请求内容</span></span><br><span class="line">    DWORD dwSize = <span class="keyword">sizeof</span>(USB_DESCRIPTOR_REQUEST) + <span class="number">256</span>;</span><br><span class="line">    PUSB_DESCRIPTOR_REQUEST pDescReq = (PUSB_DESCRIPTOR_REQUEST)<span class="built_in">malloc</span>(dwSize);</span><br><span class="line">    <span class="keyword">if</span> (pDescReq == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pDescReq, <span class="number">0</span>, dwSize);</span><br><span class="line">    <span class="comment">// 当前HUB下访问的端口索引</span></span><br><span class="line">    pDescReq-&gt;ConnectionIndex = bPortIndex;</span><br><span class="line">    <span class="comment">// USBD will automatically initialize these fields:</span></span><br><span class="line">    <span class="comment">//     bmRequest = 0x80</span></span><br><span class="line">    <span class="comment">//     bRequest  = 0x06</span></span><br><span class="line">    <span class="comment">// We must inititialize these fields:</span></span><br><span class="line">    <span class="comment">//     wValue    = Descriptor Type (high) and Descriptor Index (low byte)</span></span><br><span class="line">    <span class="comment">//     wIndex    = Zero (or Language ID for String Descriptors)</span></span><br><span class="line">    <span class="comment">//     wLength   = Length of descriptor buffer</span></span><br><span class="line">    pDescReq-&gt;SetupPacket.wValue = (USB_STRING_DESCRIPTOR_TYPE &lt;&lt; <span class="number">8</span>) | bDescIndex;</span><br><span class="line">    pDescReq-&gt;SetupPacket.wIndex = wLanguageID;</span><br><span class="line">    pDescReq-&gt;SetupPacket.wLength = <span class="number">256</span>;</span><br><span class="line">    <span class="comment">// 获取连接设备的描述信息</span></span><br><span class="line">    BOOL isSuccess = DeviceIoControl(</span><br><span class="line">        hHubDevice,</span><br><span class="line">        IOCTL_USB_GET_DESCRIPTOR_FROM_NODE_CONNECTION,</span><br><span class="line">        pDescReq, dwSize,</span><br><span class="line">        pDescReq, dwSize,</span><br><span class="line">        &amp;dwSize, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 获取失败则返回</span></span><br><span class="line">    <span class="keyword">if</span> (!isSuccess)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pDescReq);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pDescReq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>USB相关</category>
      </categories>
      <tags>
        <tag>USB相关</tag>
      </tags>
  </entry>
  <entry>
    <title>内核驱动VMWARE调试环境搭建(1)</title>
    <url>/2019/07/04/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8VMWARE%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-1/</url>
    <content><![CDATA[<h4 id="VMWARE的配置"><a href="#VMWARE的配置" class="headerlink" title="VMWARE的配置"></a>VMWARE的配置</h4><p>VMWARE软件的安装和操作系统的安装这里不再介绍，假定已经全部安装完毕。<br>在虚拟机配置页面进行串口配置，如图所示</p>
<p><img src="01.png" alt="虚拟机设置"></p>
<h4 id="WINDBG的配置"><a href="#WINDBG的配置" class="headerlink" title="WINDBG的配置"></a>WINDBG的配置</h4><p>安装WINDBG时，需要注意的是调试WIN10系统，需要WINDBG的10.0及以上版本才能正常识别。<br>创建WINDBG程序的快捷方式，然后在 <code>目标</code> 栏处，程序路径的后边附加调试参数，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;C:\Program Files\Debuggers\windbg.exe&quot; -b -k com:port&#x3D;\\.\pipe\com_1,baud&#x3D;115200,pipe</span><br></pre></td></tr></table></figure>

<p><img src="02.png" alt="WINDBG参数"></p>
<h4 id="WINXP的配置"><a href="#WINXP的配置" class="headerlink" title="WINXP的配置"></a>WINXP的配置</h4><p>WINXP中需要对 <code>boot.ini</code> 进行修改，这里提供一种方式。<br>在 <code>我的电脑</code> 右键，单击选择 <code>属性</code> 栏</p>
<p><img src="03.png" alt="我的电脑"></p>
<p>选择 <code>高级</code> 选项卡，然后单击 <code>启动和故障恢复</code> 里边的 <code>设置</code> 按钮</p>
<p><img src="04.png" alt="系统属性"></p>
<p>在 <code>启动和故障恢复</code> 窗口中单击 <code>编辑</code> 按钮</p>
<p><img src="05.png" alt="启动和故障恢复"></p>
<p>到这里就打开了 <code>boot.ini</code> 文件，复制 <code>[operating systems]</code> 里边的信息到新的一行</p>
<p><img src="06.png" alt="boot.ini文件"></p>
<p>然后在新复制的信息末尾增加调试参数，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">multi(0)disk(0)rdisk(0)partition(1)\WINDOWS&#x3D;&quot;WinXP&quot; &#x2F;noexecute&#x3D;optin &#x2F;fastdetect &#x2F;debug &#x2F;debugport&#x3D;com1 &#x2F;baudrate&#x3D;115200</span><br></pre></td></tr></table></figure>

<p><img src="07.png" alt="调试参数"></p>
<p>保存 <code>boot.ini</code> 文件并关闭，然后重启操作系统，在开机界面要选择 <code>[启用调试程序]</code> 项</p>
<p><img src="08.png" alt="开机选择项"></p>
<p>选择完毕后，同步打开具有调试参数的WINDBG快捷方式，至此搭建完成。</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>内核驱动VMWARE调试环境搭建(2)</title>
    <url>/2019/07/08/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8VMWARE%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA-2/</url>
    <content><![CDATA[<h4 id="VISTA及以上系统配置"><a href="#VISTA及以上系统配置" class="headerlink" title="VISTA及以上系统配置"></a>VISTA及以上系统配置</h4><p>在VISTA及以上版本系统中，需要使用 <code>bcdedit</code> 来修改启动项。<br>假定VMWARE和WINDBG已配置完毕，注意WIN10系统需要WINDBG的10.0及以上版本。<br>这里以WIN7系统作为例子进行配置，其他系统的操作步骤与此相同。<br>使用 <code>管理员权限</code> 打开CMD命令行，输入 <code>bcdedit</code> 可以查看当前已配置的启动项</p>
<p><img src="01.png" alt="查看启动项"></p>
<p>一般情况下，系统启动项只存在一个，复制当前选择的启动项到新的项，命令如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bcdedit &#x2F;copy &#123;current&#125; &#x2F;d &quot;Windows 7&quot;</span><br></pre></td></tr></table></figure>

<p><img src="02.png" alt="复制启动项"></p>
<p>再次输入 <code>bcdedit</code> 指令，查看启动项列表，可以看到新增加了一个启动项</p>
<p><img src="03.png" alt="新的启动项"></p>
<p>为了避免输入很长的 <code>标识符</code> 信息，我们直接修改当前的启动项，输入如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">bcdedit &#x2F;debug on</span><br><span class="line">bcdedit &#x2F;dbgsettings serial debugport:1 baudrate:115200</span><br><span class="line">bcdedit &#x2F;set testsigning on</span><br></pre></td></tr></table></figure>

<p><img src="04.png" alt="开启调试"></p>
<p>最后输入 <code>bcdedit</code> 查看修改的结果</p>
<p><img src="05.png" alt="查看结果"></p>
<p>到此已全部修改完毕，重启操作系统，在开机界面要选择 <code>[启用调试程序]</code> 项</p>
<p><img src="06.png" alt="选择启动项"></p>
<p>选择完毕后，同步打开具有调试参数的WINDBG快捷方式。</p>
<h4 id="显示驱动打印日志"><a href="#显示驱动打印日志" class="headerlink" title="显示驱动打印日志"></a>显示驱动打印日志</h4><p>VISTA及以上的操作系统默认不展示驱动打印的日志，我们可以通过添加注册表来开启。<br>复制如下信息到文本文档中，另存为 <code>.reg</code> 后缀的文件，双击该文件导入注册表信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Windows Registry Editor Version 5.00</span><br><span class="line"></span><br><span class="line">[HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\Debug Print Filter]</span><br><span class="line">&quot;DEFAULT&quot;&#x3D;dword:0000000f</span><br></pre></td></tr></table></figure>

<p><img src="07.png" alt="注册表项"></p>
<p>配置完注册表之后，需要重启操作系统才会生效。</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>在批处理中获取UAC管理员权限(1)</title>
    <url>/2019/07/15/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9C%A8%E6%89%B9%E5%A4%84%E7%90%86%E4%B8%AD%E8%8E%B7%E5%8F%96UAC%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90-1/</url>
    <content><![CDATA[<h4 id="使用批处理运行程序"><a href="#使用批处理运行程序" class="headerlink" title="使用批处理运行程序"></a>使用批处理运行程序</h4><p>当我们需要按照一定顺序，执行某些程序或者某些CMD指令时，一般会选择BAT批处理文件来执行，<br>但是有时候某些指令，需要管理员权限才能执行，而每次右键选择以管理员权限运行，操作又比较繁琐。</p>
<p>这里在BAT文件开头加入如下代码，就可以自动检测是否是管理员权限运行，当不具有管理员权限时，<br>会弹出UAC控制窗口，提示用户是否使用管理员权限继续执行。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">@echo off</span><br><span class="line">:: BatchGotAdmin</span><br><span class="line">:-------------------------------------</span><br><span class="line">REM  --&gt; Check for permissions</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">nul 2&gt;&amp;1 <span class="string">&quot;%SYSTEMROOT%\system32\cacls.exe&quot;</span> <span class="string">&quot;%SYSTEMROOT%\system32\config\system&quot;</span></span></span><br><span class="line"></span><br><span class="line">REM --&gt; If error flag set, we do not have admin.</span><br><span class="line">if &#x27;%errorlevel%&#x27; NEQ &#x27;0&#x27; (</span><br><span class="line">    echo Requesting administrative privileges...</span><br><span class="line">    goto UACPrompt</span><br><span class="line">) else ( goto gotAdmin )</span><br><span class="line"></span><br><span class="line">:UACPrompt</span><br><span class="line">    echo Set UAC = CreateObject^(&quot;Shell.Application&quot;^) &gt; &quot;%temp%\getadmin.vbs&quot;</span><br><span class="line">    echo UAC.ShellExecute &quot;%~s0&quot;, &quot;&quot;, &quot;&quot;, &quot;runas&quot;, 1 &gt;&gt; &quot;%temp%\getadmin.vbs&quot;</span><br><span class="line">    &quot;%temp%\getadmin.vbs&quot;</span><br><span class="line">    exit /B</span><br><span class="line"></span><br><span class="line">:gotAdmin</span><br><span class="line">    if exist &quot;%temp%\getadmin.vbs&quot; ( del &quot;%temp%\getadmin.vbs&quot; )</span><br><span class="line">    pushd &quot;%CD%&quot;</span><br><span class="line">    CD /D &quot;%~dp0&quot;</span><br><span class="line">:--------------------------------------</span><br><span class="line">@echo on</span><br></pre></td></tr></table></figure>

<h4 id="相关代码的说明"><a href="#相关代码的说明" class="headerlink" title="相关代码的说明"></a>相关代码的说明</h4><p>依据空行可以把以上代码划分为4部分功能：</p>
<p>第1部分，使用 <code>cacls.exe</code> 访问 <code>system</code> 注册表文件，得到一个返回值。</p>
<p>第2部分，检测这个返回值是否是0，不为0表示访问失败，需要提升权限。</p>
<p>第3部分，创建一个 <code>getadmin.vbs</code> 脚本文件，写入 <code>用runas以管理员权限创建新的控制台</code> 代码，<br>运行这个vbs脚本文件，并退出旧的控制台。</p>
<p>第4部分，删除vbs脚本，然后在新的控制台中，切换到当前的执行目录。</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>在服务程序中启动其他程序(1)</title>
    <url>/2019/08/14/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%9C%A8%E6%9C%8D%E5%8A%A1%E7%A8%8B%E5%BA%8F%E4%B8%AD%E5%90%AF%E5%8A%A8%E5%85%B6%E4%BB%96%E7%A8%8B%E5%BA%8F-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>有时我们需要跟随操作系统启动某些程序，常见的做法是创建服务程序，然后使用 <code>SYSTEM</code> 权限来启动其他程序</p>
<h4 id="控制服务的代码"><a href="#控制服务的代码" class="headerlink" title="控制服务的代码"></a>控制服务的代码</h4><p>服务的启动停止，可以直接使用 <code>sc.exe</code> 或者 <code>net.exe</code> 指令进行控制，比如使用 <code>sc stop dhcp</code> 来<br>停止 <code>dhcp</code> 服务，有时候停止服务时，会提示我们是否结束依赖项，使用 <code>net stop dhcp /y</code> 命令，可以<br>自动结束 <code>dhcp</code> 的依赖项。除此之外，我们还可以使用SDK提供的API来进行控制，如下为相关控制代码</p>
<h5 id="服务安装"><a href="#服务安装" class="headerlink" title="服务安装"></a>服务安装</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ServiceInstall</span><span class="params">(PCSTR pName, PCSTR pPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查参数</span></span><br><span class="line">    <span class="keyword">if</span> (pName == <span class="literal">NULL</span>) || (pPath == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 打开服务管理器</span></span><br><span class="line">    SC_HANDLE hSCM = OpenSCManager(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span> (hSCM == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 创建服务  </span></span><br><span class="line">    SC_HANDLE hService = CreateService(</span><br><span class="line">        hSCM, pName, pPath, SERVICE_ALL_ACCESS,</span><br><span class="line">        SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS,</span><br><span class="line">        SERVICE_AUTO_START, SERVICE_ERROR_NORMAL,</span><br><span class="line">        pPath, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="string">&quot;&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hService == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检测服务是否已经创建</span></span><br><span class="line">        <span class="keyword">if</span> (GetLastError() == ERROR_SERVICE_EXISTS)</span><br><span class="line">        &#123;</span><br><span class="line">            CloseServiceHandle(hSCM);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        CloseServiceHandle(hSCM);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    CloseServiceHandle(hService);</span><br><span class="line">    CloseServiceHandle(hSCM);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务启动"><a href="#服务启动" class="headerlink" title="服务启动"></a>服务启动</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ServiceStart</span><span class="params">(PCSTR pName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查参数</span></span><br><span class="line">    <span class="keyword">if</span> (pName == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 打开服务控制管理器</span></span><br><span class="line">    SC_HANDLE hSCM = OpenSCManager(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span> (hSCM == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 打开服务</span></span><br><span class="line">    SC_HANDLE hService = OpenService(hSCM, m_csName.GetBuffer(), SERVICE_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span> (hService != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseServiceHandle(hSCM);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先查询服务状态</span></span><br><span class="line">    DWORD needsize = <span class="number">0</span>;</span><br><span class="line">    SERVICE_STATUS_PROCESS ssp;</span><br><span class="line">    BOOL success = QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO,</span><br><span class="line">        (PBYTE)(&amp;ssp), <span class="keyword">sizeof</span>(SERVICE_STATUS_PROCESS), &amp;needsize);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseServiceHandle(hService);</span><br><span class="line">        CloseServiceHandle(hSCM);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待pending的动作</span></span><br><span class="line">    DWORD dwOldCheckPoint = ssp.dwCheckPoint;</span><br><span class="line">    <span class="keyword">while</span> ((ssp.dwCurrentState == SERVICE_START_PENDING) ||</span><br><span class="line">        (ssp.dwCurrentState == SERVICE_STOP_PENDING))</span><br><span class="line">    &#123;</span><br><span class="line">        Sleep(ssp.dwWaitHint); <span class="comment">// 休眠预估的时间</span></span><br><span class="line">        success = QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO,</span><br><span class="line">            (PBYTE)(&amp;ssp), <span class="keyword">sizeof</span>(SERVICE_STATUS_PROCESS), &amp;needsize);</span><br><span class="line">        <span class="keyword">if</span> (!success)</span><br><span class="line">        &#123;</span><br><span class="line">            CloseServiceHandle(hService);</span><br><span class="line">            CloseServiceHandle(hSCM);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查pending是否结束</span></span><br><span class="line">        <span class="keyword">if</span> ((ssp.dwCurrentState != SERVICE_START_PENDING) &amp;&amp;</span><br><span class="line">            (ssp.dwCurrentState != SERVICE_STOP_PENDING)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 检查是否超时</span></span><br><span class="line">        <span class="keyword">if</span> (ssp.dwCheckPoint == dwOldCheckPoint) <span class="keyword">break</span>;</span><br><span class="line">        dwOldCheckPoint = ssp.dwCheckPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">    <span class="keyword">if</span> (ssp.dwCurrentState == SERVICE_STOPPED)</span><br><span class="line">    &#123;</span><br><span class="line">        success = StartService(hService, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!success)</span><br><span class="line">        &#123;</span><br><span class="line">            CloseServiceHandle(hService);</span><br><span class="line">            CloseServiceHandle(hSCM);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CloseServiceHandle(hService);</span><br><span class="line">    CloseServiceHandle(hSCM);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务停止"><a href="#服务停止" class="headerlink" title="服务停止"></a>服务停止</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">StopDepend</span><span class="params">(SC_HANDLE hSCM, SC_HANDLE hService)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((hSCM == <span class="literal">NULL</span>) || (hService == <span class="literal">NULL</span>)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    DWORD count = <span class="number">0</span>;</span><br><span class="line">    DWORD needsize = <span class="number">0</span>;</span><br><span class="line">    LPENUM_SERVICE_STATUS pDepend = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 查询依赖服务</span></span><br><span class="line">    BOOL success = EnumDependentServices(hSCM,</span><br><span class="line">        SERVICE_ACTIVE, pDepend, <span class="number">0</span>, &amp;needsize, &amp;count);</span><br><span class="line">    <span class="keyword">if</span> (success) <span class="keyword">return</span> TRUE; <span class="comment">// 无依赖服务</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (GetLastError() != ERROR_MORE_DATA) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 申请内存空间</span></span><br><span class="line">    pDepend = (LPENUM_SERVICE_STATUS)<span class="built_in">malloc</span>(needsize);</span><br><span class="line">    <span class="keyword">if</span> (pDepend == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="built_in">memset</span>(pDepend, <span class="number">0</span>, needsize);</span><br><span class="line">    <span class="comment">// 再次查询依赖服务</span></span><br><span class="line">    success = EnumDependentServices(hSCM,</span><br><span class="line">        SERVICE_ACTIVE, pDepend, needsize, &amp;needsize, &amp;count);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pDepend);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环停止依赖服务</span></span><br><span class="line">    SC_HANDLE handle = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwOldCheckPoint = <span class="number">0</span>;</span><br><span class="line">    SERVICE_STATUS_PROCESS ssp;</span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; count; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        handle = OpenService(hSCM, (pDepend + i)-&gt;lpServiceName, SERVICE_ALL_ACCESS);</span><br><span class="line">        <span class="keyword">if</span> (handle == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(pDepend);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        success = ControlService(handle, SERVICE_CONTROL_STOP, (LPSERVICE_STATUS)(&amp;ssp));</span><br><span class="line">        <span class="keyword">if</span> (!success)</span><br><span class="line">        &#123;</span><br><span class="line">            CloseServiceHandle(handle);</span><br><span class="line">            <span class="built_in">free</span>(pDepend);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 等待停止完成</span></span><br><span class="line">        <span class="keyword">while</span> (ssp.dwCurrentState != SERVICE_STOPPED)</span><br><span class="line">        &#123;</span><br><span class="line">            Sleep(ssp.dwWaitHint); <span class="comment">// 休眠预估的时间</span></span><br><span class="line">            success = QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO,</span><br><span class="line">                (PBYTE)(&amp;ssp), <span class="keyword">sizeof</span>(SERVICE_STATUS_PROCESS), &amp;needsize);</span><br><span class="line">            <span class="keyword">if</span> (!success)</span><br><span class="line">            &#123;</span><br><span class="line">                CloseServiceHandle(handle);</span><br><span class="line">                <span class="built_in">free</span>(pDepend);</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ssp.dwCurrentState == SERVICE_STOPPED) <span class="keyword">break</span>; <span class="comment">// while</span></span><br><span class="line">            <span class="comment">// 检查是否超时</span></span><br><span class="line">            <span class="keyword">if</span> (ssp.dwCheckPoint == dwOldCheckPoint)</span><br><span class="line">            &#123;</span><br><span class="line">                CloseServiceHandle(handle);</span><br><span class="line">                <span class="built_in">free</span>(pDepend);</span><br><span class="line">                <span class="keyword">return</span> TRUE;</span><br><span class="line">            &#125;</span><br><span class="line">            dwOldCheckPoint = ssp.dwCheckPoint;</span><br><span class="line">        &#125;</span><br><span class="line">        CloseServiceHandle(handle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pDepend);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ServiceStop</span><span class="params">(PCSTR pName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pName == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 打开服务控制管理器</span></span><br><span class="line">    SC_HANDLE hSCM = OpenSCManager(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span> (hSCM == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 打开服务</span></span><br><span class="line">    SC_HANDLE hService = OpenService(hSCM, m_csName.GetBuffer(), SERVICE_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span> (hService != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseServiceHandle(hSCM);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先查询服务状态</span></span><br><span class="line">    DWORD needsize = <span class="number">0</span>;</span><br><span class="line">    SERVICE_STATUS_PROCESS ssp;</span><br><span class="line">    BOOL success = QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO,</span><br><span class="line">        (PBYTE)(&amp;ssp), <span class="keyword">sizeof</span>(SERVICE_STATUS_PROCESS), &amp;needsize);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseServiceHandle(hService);</span><br><span class="line">        CloseServiceHandle(hSCM);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待pending的动作</span></span><br><span class="line">    DWORD dwOldCheckPoint = ssp.dwCheckPoint;</span><br><span class="line">    <span class="keyword">while</span> ((ssp.dwCurrentState == SERVICE_START_PENDING) ||</span><br><span class="line">        (ssp.dwCurrentState == SERVICE_STOP_PENDING))</span><br><span class="line">    &#123;</span><br><span class="line">        Sleep(ssp.dwWaitHint); <span class="comment">// 休眠预估的时间</span></span><br><span class="line">        success = QueryServiceStatusEx(hService, SC_STATUS_PROCESS_INFO,</span><br><span class="line">            (PBYTE)(&amp;ssp), <span class="keyword">sizeof</span>(SERVICE_STATUS_PROCESS), &amp;needsize);</span><br><span class="line">        <span class="keyword">if</span> (!success)</span><br><span class="line">        &#123;</span><br><span class="line">            CloseServiceHandle(hService);</span><br><span class="line">            CloseServiceHandle(hSCM);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查pending是否结束</span></span><br><span class="line">        <span class="keyword">if</span> ((ssp.dwCurrentState != SERVICE_START_PENDING) &amp;&amp;</span><br><span class="line">            (ssp.dwCurrentState != SERVICE_STOP_PENDING)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 检查是否超时</span></span><br><span class="line">        <span class="keyword">if</span> (ssp.dwCheckPoint == dwOldCheckPoint) <span class="keyword">break</span>;</span><br><span class="line">        dwOldCheckPoint = ssp.dwCheckPoint;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 停止服务</span></span><br><span class="line">    <span class="keyword">if</span> (ssp.dwCurrentState == SERVICE_RUNNING)</span><br><span class="line">    &#123;</span><br><span class="line">        SERVICE_STATUS status;</span><br><span class="line">        success = StopDepend(hSCM, hService); <span class="comment">// 停止依赖服务</span></span><br><span class="line">        <span class="keyword">if</span> (!success)</span><br><span class="line">        &#123;</span><br><span class="line">            CloseServiceHandle(hService);</span><br><span class="line">            CloseServiceHandle(hSCM);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        success = ControlService(hService, SERVICE_CONTROL_STOP, &amp;status);</span><br><span class="line">        <span class="keyword">if</span> (!success)</span><br><span class="line">        &#123;</span><br><span class="line">            CloseServiceHandle(hService);</span><br><span class="line">            CloseServiceHandle(hSCM);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CloseServiceHandle(hService);</span><br><span class="line">    CloseServiceHandle(hSCM);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务卸载"><a href="#服务卸载" class="headerlink" title="服务卸载"></a>服务卸载</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ServiceUninstall</span><span class="params">(PCSTR pName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pName == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 打开服务控制管理器</span></span><br><span class="line">    SC_HANDLE hSCM = OpenSCManager(<span class="literal">NULL</span>, <span class="literal">NULL</span>, SC_MANAGER_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span> (hSCM == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 打开服务</span></span><br><span class="line">    SC_HANDLE hService = OpenService(hSCM, m_csName.GetBuffer(), SERVICE_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span> (hService != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseServiceHandle(hSCM);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 卸载服务</span></span><br><span class="line">    <span class="keyword">if</span> (DeleteService(hService))</span><br><span class="line">    &#123;</span><br><span class="line">        CloseServiceHandle(hService);</span><br><span class="line">        CloseServiceHandle(hSCM);</span><br><span class="line">        <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    CloseServiceHandle(hService);</span><br><span class="line">    CloseServiceHandle(hSCM);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="应用程序的示例"><a href="#应用程序的示例" class="headerlink" title="应用程序的示例"></a>应用程序的示例</h4><p>当我们需要常驻运行某个程序时，可以在服务中定时轮询检测并启动。如下为实例程序代码</p>
<h5 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shellapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;userenv.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;userenv.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wtsapi32.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;wtsapi32.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h5 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">SERVICE_STATUS g_svcStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">SERVICE_STATUS_HANDLE g_hSvcStatus = <span class="literal">NULL</span>;</span><br><span class="line">OSVERSIONINFO g_osVersion = &#123; <span class="number">0</span> &#125;;</span><br></pre></td></tr></table></figure>

<h5 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetPidByName</span><span class="params">(IN PCSTR pName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pName == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    PROCESSENTRY32 pe = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    pe.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    <span class="comment">// 创建进程快照</span></span><br><span class="line">    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 获取首个进程信息</span></span><br><span class="line">    <span class="keyword">if</span> (!Process32First(hSnapshot, &amp;pe))</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hSnapshot);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环遍历进程</span></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_stricmp(pName, pe.szExeFile) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            CloseHandle(hSnapshot);</span><br><span class="line">            <span class="keyword">return</span> pe.th32ProcessID;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(&amp;pe, <span class="number">0</span>, <span class="keyword">sizeof</span>(PROCESSENTRY32));</span><br><span class="line">        pe.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32);</span><br><span class="line">    &#125; <span class="keyword">while</span> (Process32Next(hSnapshot, &amp;pe));</span><br><span class="line">    CloseHandle(hSnapshot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">VistaStartProcess</span><span class="params">(IN PSTR pCmdLine)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pCmdLine == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 获取活动控制台会话</span></span><br><span class="line">    DWORD dwSessionId = WTSGetActiveConsoleSessionId();</span><br><span class="line">    <span class="keyword">if</span> (dwSessionId == <span class="number">0xFFFFFFFF</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 获取指定(会话/进程)令牌信息</span></span><br><span class="line">    HANDLE hToken = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!WTSQueryUserToken(dwSessionId, &amp;hToken)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">if</span> (!OpenProcessToken(GetCurrentProcess(), TOKEN_ALL_ACCESS, &amp;hToken)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 复制到新令牌</span></span><br><span class="line">    HANDLE hTokenDup = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!DuplicateTokenEx(hToken, MAXIMUM_ALLOWED, <span class="literal">NULL</span>,</span><br><span class="line">        SecurityIdentification, TokenPrimary, &amp;hTokenDup))</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hToken);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果需要，修改新令牌的会话信息</span></span><br><span class="line">    <span class="keyword">if</span> (!SetTokenInformation(hTokenDup, TokenSessionId, &amp;dwSessionId, <span class="keyword">sizeof</span>(DWORD)))</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hTokenDup);</span><br><span class="line">        CloseHandle(hToken);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭旧令牌句柄</span></span><br><span class="line">    CloseHandle(hToken);</span><br><span class="line">    <span class="comment">// 创建环境变量块</span></span><br><span class="line">    LPVOID pEnv = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwCreationFlags = NORMAL_PRIORITY_CLASS | CREATE_NEW_CONSOLE;</span><br><span class="line">    <span class="keyword">if</span> (CreateEnvironmentBlock(&amp;pEnv, hTokenDup, TRUE))</span><br><span class="line">        dwCreationFlags |= CREATE_UNICODE_ENVIRONMENT;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        pEnv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 启动进程</span></span><br><span class="line">    STARTUPINFO si = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    si.cb = <span class="keyword">sizeof</span>(STARTUPINFO);</span><br><span class="line">    si.lpDesktop = <span class="string">&quot;winsta0\\default&quot;</span>;</span><br><span class="line">    PROCESS_INFORMATION pi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (!CreateProcessAsUser(hTokenDup, <span class="literal">NULL</span>, pCmdLine,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, FALSE, dwCreationFlags, pEnv, <span class="literal">NULL</span>, &amp;si, &amp;pi))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (pEnv != <span class="literal">NULL</span>) DestroyEnvironmentBlock(pEnv);</span><br><span class="line">        CloseHandle(hTokenDup);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁环境变量块</span></span><br><span class="line">    <span class="keyword">if</span> (pEnv != <span class="literal">NULL</span>) DestroyEnvironmentBlock(pEnv);</span><br><span class="line">    CloseHandle(hTokenDup);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="服务函数"><a href="#服务函数" class="headerlink" title="服务函数"></a>服务函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> WINAPI <span class="title">ServiceCtrl</span><span class="params">(DWORD dwOpcode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 不提供服务控制</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> WINAPI <span class="title">ServiceMain</span><span class="params">(DWORD dwArgc, LPTSTR *lpszArgv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注册服务控制函数</span></span><br><span class="line">    g_hSvcStatus = RegisterServiceCtrlHandler(<span class="string">&quot;MyService&quot;</span>, ServiceCtrl);</span><br><span class="line">    <span class="keyword">if</span> (g_hSvcStatus == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 设置服务为pending状态</span></span><br><span class="line">    g_svcStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS;</span><br><span class="line">    g_svcStatus.dwCurrentState = SERVICE_START_PENDING;</span><br><span class="line">    g_svcStatus.dwControlsAccepted = <span class="number">0</span>; <span class="comment">// SERVICE_ACCEPT_STOP; // 停止服务变灰</span></span><br><span class="line">    g_svcStatus.dwWin32ExitCode = <span class="number">0</span>;</span><br><span class="line">    g_svcStatus.dwServiceSpecificExitCode = <span class="number">0</span>;</span><br><span class="line">    g_svcStatus.dwCheckPoint = <span class="number">0</span>;</span><br><span class="line">    g_svcStatus.dwWaitHint = <span class="number">0</span>;</span><br><span class="line">    SetServiceStatus(g_hSvcStatus, &amp;g_svcStatus);</span><br><span class="line">    <span class="comment">// 设置服务为running状态</span></span><br><span class="line">    g_svcStatus.dwCurrentState = SERVICE_RUNNING;</span><br><span class="line">    SetServiceStatus(g_hSvcStatus, &amp;g_svcStatus);</span><br><span class="line">    <span class="comment">// 循环启动进程</span></span><br><span class="line">    PSTR pPath = <span class="string">&quot;c:\\test.exe&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (GetPidByName(<span class="string">&quot;test.exe&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (g_osVersion.dwMajorVersion &gt; <span class="number">5</span>)</span><br><span class="line">                VistaStartProcess(pPath);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                StartProcess(pPath);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 休眠1分钟</span></span><br><span class="line">        Sleep(<span class="number">60000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 服务设置SERVICE_RUNNING以后会自动维持运行</span></span><br><span class="line">    <span class="comment">// 除非需要循环执行某些命令，否则不需要手动维持运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> WINAPI _tWinMain(HINSTANCE hInst, HINSTANCE hPrevInst, LPTSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取操作系统版本号</span></span><br><span class="line">    OSVERSIONINFO osver = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (!GetVersionEx(&amp;osver)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (g_osVersion.dwMajorVersion &lt; <span class="number">6</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 低权限内核对象属性描述</span></span><br><span class="line">    SECURITY_DESCRIPTOR secDesc = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    InitializeSecurityDescriptor(&amp;secDesc, SECURITY_DESCRIPTOR_REVISION);</span><br><span class="line">    SetSecurityDescriptorDacl(&amp;secDesc, TRUE, <span class="literal">NULL</span>, FALSE);</span><br><span class="line">    SECURITY_ATTRIBUTES secAttrib = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    secAttrib.nLength = <span class="keyword">sizeof</span>(SECURITY_ATTRIBUTES);</span><br><span class="line">    secAttrib.lpSecurityDescriptor = &amp;secDesc;</span><br><span class="line">    secAttrib.bInheritHandle = FALSE;</span><br><span class="line">    <span class="comment">// 创建防多开事件</span></span><br><span class="line">    HANDLE hEvent = CreateEvent(&amp;secAttrib, FALSE, FALSE, <span class="string">&quot;Global\\MyService&quot;</span>);</span><br><span class="line">    <span class="comment">// 创建失败，则退出</span></span><br><span class="line">    <span class="keyword">if</span> (hEvent == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 已存在，则退出</span></span><br><span class="line">    <span class="keyword">if</span> (GetLastError() == ERROR_ALREADY_EXISTS)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hEvent);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置服务主函数</span></span><br><span class="line">    SERVICE_TABLE_ENTRY st[] = &#123;</span><br><span class="line">        &#123; <span class="string">&quot;MyService&quot;</span>, ServiceMain &#125;,</span><br><span class="line">        &#123; <span class="literal">NULL</span>, <span class="literal">NULL</span> &#125; &#125;;</span><br><span class="line">    <span class="comment">// 运行服务主函数</span></span><br><span class="line">    StartServiceCtrlDispatcher(st);</span><br><span class="line">    CloseHandle(hEvent);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="其他事项"><a href="#其他事项" class="headerlink" title="其他事项"></a>其他事项</h4><p>以上启动的程序全都是 <code>SYSTEM</code> 权限的，如果想以其他权限运行，就需要在 <code>CreateProcessAsUser</code> 时，<br>使用其他程序的 <code>token</code> 信息，比如获取 <code>explorer.exe</code> 程序的 <code>token</code> 信息</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>实现MountPoint操作(1)</title>
    <url>/2021/12/07/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%AE%9E%E7%8E%B0MountPoint%E6%93%8D%E4%BD%9C-1/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>有些时候我们需要创建 <code>MountPoint</code> 或 <code>HardLink</code> 测试安全性漏洞。</p>
<h4 id="创建HardLink"><a href="#创建HardLink" class="headerlink" title="创建HardLink"></a>创建HardLink</h4><p>创建 <code>HardLink</code> 微软提供了现成的API操作，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">CreateHardLink</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_       LPCTSTR               lpFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_       LPCTSTR               lpExistingFileName,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Reserved_ LPSECURITY_ATTRIBUTES lpSecurityAttributes</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用起来特别简单，<code>lpFileName</code> 是创建的新名称路径，<code>lpExistingFileName</code> 是现有文件路径，<br><code>lpSecurityAttributes</code> 系统保留设置为NULL，代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CreateHardLink(<span class="string">L&quot;D:\\a.txt&quot;</span>, <span class="string">L&quot;D:\\b.txt&quot;</span>, <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>

<p>注意：创建 <code>HardLink</code> 需要请求文件的 <code>FILE_WRITE_ATTRIBUTES</code> 权限，不能跨盘符。</p>
<h4 id="创建MountPoint"><a href="#创建MountPoint" class="headerlink" title="创建MountPoint"></a>创建MountPoint</h4><p>创建 <code>MountPoint</code> 没有直接的API函数，我们通过发送 <code>FSCTL_SET_REPARSE_POINT</code> 控制码实现，<br>而控制码对应的输入参数是 <code>REPARSE_DATA_BUFFER</code> 结构体，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">REPARSE_DATA_BUFFER</span> &#123;</span></span><br><span class="line">    ULONG  ReparseTag;</span><br><span class="line">    USHORT ReparseDataLength;</span><br><span class="line">    USHORT Reserved;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            USHORT SubstituteNameOffset;</span><br><span class="line">            USHORT SubstituteNameLength;</span><br><span class="line">            USHORT PrintNameOffset;</span><br><span class="line">            USHORT PrintNameLength;</span><br><span class="line">            ULONG  Flags;</span><br><span class="line">            WCHAR  PathBuffer[<span class="number">1</span>];</span><br><span class="line">        &#125; SymbolicLinkReparseBuffer;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            USHORT SubstituteNameOffset;</span><br><span class="line">            USHORT SubstituteNameLength;</span><br><span class="line">            USHORT PrintNameOffset;</span><br><span class="line">            USHORT PrintNameLength;</span><br><span class="line">            WCHAR  PathBuffer[<span class="number">1</span>];</span><br><span class="line">        &#125; MountPointReparseBuffer;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            UCHAR DataBuffer[<span class="number">1</span>];</span><br><span class="line">        &#125; GenericReparseBuffer;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; REPARSE_DATA_BUFFER, *PREPARSE_DATA_BUFFER;</span><br></pre></td></tr></table></figure>

<p>创建MountPoint的代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CreateMountPoint</span><span class="params">(PCWSTR pSrcDir, PCWSTR pDstDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pSrcDir || !pSrcDir[<span class="number">0</span>] || !pDstDir || !pDstDir[<span class="number">0</span>]) <span class="keyword">return</span> FALSE;</span><br><span class="line">    HANDLE hFile = CreateFileW(pSrcDir, FILE_WRITE_ATTRIBUTES, <span class="number">0</span>, <span class="literal">NULL</span>,</span><br><span class="line">        OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    USHORT nDstSize = (USHORT)((wcslen(pDstDir) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(WCHAR));</span><br><span class="line">    DWORD dwHdrSize = FIELD_OFFSET(REPARSE_DATA_BUFFER, MountPointReparseBuffer);</span><br><span class="line">    DWORD dwSize = dwHdrSize + nDstSize + <span class="keyword">sizeof</span>(REPARSE_DATA_BUFFER::MountPointReparseBuffer);</span><br><span class="line">    PREPARSE_DATA_BUFFER pReparse = (PREPARSE_DATA_BUFFER)<span class="built_in">malloc</span>(dwSize);</span><br><span class="line">    <span class="keyword">if</span> (!pReparse)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hFile);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ZeroMemory(pReparse, dwSize);</span><br><span class="line">    pReparse-&gt;ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;</span><br><span class="line">    pReparse-&gt;ReparseDataLength = nDstSize + <span class="keyword">sizeof</span>(REPARSE_DATA_BUFFER::MountPointReparseBuffer);</span><br><span class="line">    <span class="built_in">memcpy</span>(pReparse-&gt;MountPointReparseBuffer.PathBuffer, pDstDir, nDstSize);</span><br><span class="line">    pReparse-&gt;MountPointReparseBuffer.SubstituteNameLength = nDstSize - <span class="keyword">sizeof</span>(WCHAR);</span><br><span class="line">    pReparse-&gt;MountPointReparseBuffer.PrintNameOffset = nDstSize;</span><br><span class="line"></span><br><span class="line">    DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">    BOOL bOK = DeviceIoControl(hFile,</span><br><span class="line">        FSCTL_SET_REPARSE_POINT, pReparse, dwSize, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwRet, <span class="literal">NULL</span>);</span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    <span class="built_in">free</span>(pReparse);</span><br><span class="line">    <span class="keyword">return</span> bOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除MountPoint的代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DeleteMountPoint</span><span class="params">(PCWSTR pSrcDir)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pSrcDir || !pSrcDir[<span class="number">0</span>]) <span class="keyword">return</span> FALSE;</span><br><span class="line">    HANDLE hFile = CreateFileW(pSrcDir, FILE_WRITE_ATTRIBUTES, <span class="number">0</span>, <span class="literal">NULL</span>,</span><br><span class="line">        OPEN_EXISTING, FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_OPEN_REPARSE_POINT, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    REPARSE_GUID_DATA_BUFFER stReparse = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    stReparse.ReparseTag = IO_REPARSE_TAG_MOUNT_POINT;</span><br><span class="line">    DWORD dwSize = REPARSE_GUID_DATA_BUFFER_HEADER_SIZE;</span><br><span class="line"></span><br><span class="line">    DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">    BOOL bOK = DeviceIoControl(hFile, FSCTL_DELETE_REPARSE_POINT,</span><br><span class="line">        &amp;stReparse, dwSize, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwRet, <span class="literal">NULL</span>);</span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    <span class="keyword">return</span> bOK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>调用方式如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CreateMountPoint(<span class="string">L&quot;\\??\\C:\\aaa&quot;</span>, <span class="string">L&quot;\\??\\D:\\bbb&quot;</span>);</span><br><span class="line">DeleteMountPoint(<span class="string">L&quot;\\??\\C:\\aaa&quot;</span>);</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>实现开机自启动的方法(1)</title>
    <url>/2021/03/15/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E5%AE%9E%E7%8E%B0%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在很多情况下，我们期望自己的程序，能够跟随操作系统运行。操作系统也提供了一些常规的<br>开机自启动的方法，比如特定的注册表和特定的文件夹等，下边依次进行介绍</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><h5 id="1-注册表RUN"><a href="#1-注册表RUN" class="headerlink" title="1.注册表RUN"></a>1.注册表RUN</h5><p>系统在注册表中提供随着 <code>用户登录</code> 而运行的RUN键值，包含如下位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\RunOnce</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce</span><br><span class="line">HKEY_CURRENT_USER\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run</span><br><span class="line">HKEY_CURRENT_USER\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\RunOnce</span><br></pre></td></tr></table></figure>

<p>在 <code>HKEY_LOCAL_MACHINE</code> 里的是针对 <code>所有用户</code> 的配置，在 <code>HKEY_CURRENT_USER</code> 里的是<br>针对 <code>当前用户</code> 的配置，其中 <code>RunOnce</code> 的配置在启动过一次后就会自行删除</p>
<p>注：该方法涉及到 <code>提升UAC权限</code> 运行的程序会失败</p>
<h5 id="2-文件夹启动"><a href="#2-文件夹启动" class="headerlink" title="2.文件夹启动"></a>2.文件夹启动</h5><p>在系统开时菜单中提供了随着 <code>用户登录</code> 而运行的启动目录，包含如下位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp</span><br><span class="line">C:\Users\用户名\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup</span><br></pre></td></tr></table></figure>

<p>其中 <code>ProgramData</code> 目录下的是针对 <code>所有用户</code> 的配置</p>
<p>注：该方法涉及到 <code>提升UAC权限</code> 运行的程序会失败</p>
<h5 id="3-注册表Userinit"><a href="#3-注册表Userinit" class="headerlink" title="3.注册表Userinit"></a>3.注册表Userinit</h5><p>在如下注册表的位置存在一个 <code>Userinit</code> 值，数据为 <code>C:\Windows\system32\userinit.exe,</code><br>注意结尾的逗号，这里我们可以添加自己的程序，在 <code>用户登录</code> 时就会跟随一起启动</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon</span><br></pre></td></tr></table></figure>

<p>注：该方法涉及到 <code>提升UAC权限</code> 运行的程序会失败</p>
<h5 id="3-计划任务"><a href="#3-计划任务" class="headerlink" title="3.计划任务"></a>3.计划任务</h5><p>在操作系统计划任务配置中，可以设置是 <code>用户登录</code> 时运行，还是 <code>系统启动</code> 时运行，<br>同时还可以设置是否以 <code>管理员权限</code> 运行，如下图所示</p>
<p><img src="01.png" alt="创建计划任务"></p>
<p>或者使用CMD命令进行设置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">schtasks &#x2F;Create &#x2F;SC ONLOGON &#x2F;RL HIGHEST &#x2F;F &#x2F;TN &quot;TaskName&quot; &#x2F;TR &quot;TaskExePath&quot; &#x2F;&#x2F; 创建</span><br><span class="line">schtasks &#x2F;Delete &#x2F;F &#x2F;TN &quot;TaskName&quot; &#x2F;&#x2F; 删除</span><br></pre></td></tr></table></figure>

<h5 id="4-服务"><a href="#4-服务" class="headerlink" title="4.服务"></a>4.服务</h5><p>程序注册成服务后可以在 <code>启动类型</code> 中设置成随系统启动，并且使用的 <code>SYSTEM</code> 权限，但是由于服务<br>是在 <code>会话0</code> 中运行，无法展示UI界面，所以需要先检测 <code>用户登录</code> 后再从 <code>会话1</code> 中启动带UI程序</p>
<p><img src="02.png" alt="创建服务"></p>
<p>其中 <code>Start</code> 为 <code>2</code> 时表示随系统启动</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统的关键信息查询(1)</title>
    <url>/2019/07/30/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%85%B3%E9%94%AE%E4%BF%A1%E6%81%AF%E6%9F%A5%E8%AF%A2-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>很多情况下，我们需要收集操作系统的关键信息，比如 <code>内存大小</code> <code>已安装软件</code> <code>已安装补丁</code> 等等信息。<br>所有的这些信息，我们可以起通过操作系统自带的 <code>WMI</code> 功能来查询到，它使用的是一种 <code>WQL</code> 数据库<br>访问语言。<code>WMI</code> 功能相当的庞大，我们这里只列出一部分我们感兴趣的项。</p>
<h4 id="WMI使用"><a href="#WMI使用" class="headerlink" title="WMI使用"></a>WMI使用</h4><p><code>WMI</code> 全称 <code>Windows Management Instrumentation</code> 中文叫 <code>Windows管理规范</code>，用户可以使用  <code>WMI</code><br>管理本地和远程计算机，它对外开放的网络端口为 <code>135</code>，一般情况下，我们应该主动关闭这个端口，<br>防止远程访问进行一些恶意操作。</p>
<p>WMI的使用方式包含 <code>COM API</code> <code>脚本API</code> <code>WQL(SQL for WMI)</code> 几种方式，我们这里使用的是 <code>WQL</code> 的<br>方式，其他使用方式请自行查询相关资料。(<a href="http://www.yfvb.com/help/wmi/index.htm">http://www.yfvb.com/help/wmi/index.htm</a>)</p>
<h4 id="示例查询代码"><a href="#示例查询代码" class="headerlink" title="示例查询代码"></a>示例查询代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 回调函数的定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HRESULT</span> <span class="params">(*WMICALLBACK)</span><span class="params">(VARIANT&amp; vtInfo)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">HRESULT <span class="title">WmiQueryInfo</span><span class="params">(LPCWSTR wszCmd, LPCWSTR wszName, WMICALLBACK Callback)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 检查参数的有效性</span></span><br><span class="line">    <span class="keyword">if</span> ((wszCmd == <span class="literal">NULL</span>) || (wszName == <span class="literal">NULL</span>) || (Callback == <span class="literal">NULL</span>)) <span class="keyword">return</span> S_FALSE;</span><br><span class="line">    <span class="comment">// 初始化COM的进程安全(CoInitializeEx)(原因：WMI的进程和应用程序进程不在同一个级别)</span></span><br><span class="line">    CoInitializeEx(<span class="number">0</span>, COINIT_MULTITHREADED);</span><br><span class="line">    HRESULT hr = CoInitializeSecurity(</span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        <span class="number">-1</span>,                          <span class="comment">// COM authentication    COM认证</span></span><br><span class="line">        <span class="literal">NULL</span>,                        <span class="comment">// Authentication services    认证服务</span></span><br><span class="line">        <span class="literal">NULL</span>,                        <span class="comment">// Reserved    保留</span></span><br><span class="line">        RPC_C_AUTHN_LEVEL_DEFAULT,   <span class="comment">// Default authentication 默认身份验认     </span></span><br><span class="line">        RPC_C_IMP_LEVEL_IMPERSONATE, <span class="comment">// Default Impersonation  默认模拟</span></span><br><span class="line">        <span class="literal">NULL</span>,                        <span class="comment">// Authentication info    认证信息</span></span><br><span class="line">        EOAC_NONE,                   <span class="comment">// Additional capabilities     额外功能</span></span><br><span class="line">        <span class="literal">NULL</span>);                       <span class="comment">// Reserved    保留</span></span><br><span class="line">    <span class="keyword">if</span> ((hr != S_OK) &amp;&amp; (hr != RPC_E_TOO_LATE)) <span class="keyword">return</span> hr;</span><br><span class="line">    <span class="comment">// 用指定的类标识符创建一个Com对象,用指定的类标识符创建一个未初始化的对象。</span></span><br><span class="line">    IWbemLocator *pLocator = <span class="literal">NULL</span>;   </span><br><span class="line">    hr = CoCreateInstance(</span><br><span class="line">        CLSID_WbemLocator,    <span class="comment">// 创建的Com对象的类标识符(CLSID)           </span></span><br><span class="line">        <span class="number">0</span>,                    <span class="comment">// 指向接口IUnknown的指针</span></span><br><span class="line">        CLSCTX_INPROC_SERVER, <span class="comment">// 运行可执行代码的上下文</span></span><br><span class="line">        IID_IWbemLocator,     <span class="comment">// 创建的Com对象的接口标识符</span></span><br><span class="line">        (LPVOID *)&amp;pLocator); <span class="comment">// 用来接收指向Com对象接口地址的指针变量</span></span><br><span class="line">    <span class="keyword">if</span> (hr != S_OK) <span class="keyword">return</span> hr;</span><br><span class="line">    <span class="comment">// 获取IWbemServices指针(IWbemLocator::ConnectServer)</span></span><br><span class="line">    <span class="comment">// 创建WMI服务</span></span><br><span class="line">    IWbemServices *pServices = <span class="literal">NULL</span>;</span><br><span class="line">    hr = pLocator-&gt;ConnectServer(</span><br><span class="line">        <span class="keyword">_bstr_t</span>(<span class="string">L&quot;ROOT\\CIMV2&quot;</span>), <span class="comment">// Object path of WMI namespace    </span></span><br><span class="line">        <span class="literal">NULL</span>,                    <span class="comment">// User name. NULL = current user    </span></span><br><span class="line">        <span class="literal">NULL</span>,                    <span class="comment">// User password. NULL = current    </span></span><br><span class="line">        <span class="number">0</span>,                       <span class="comment">// Locale. NULL indicates current    </span></span><br><span class="line">        <span class="literal">NULL</span>,                    <span class="comment">// Security flags.    </span></span><br><span class="line">        <span class="number">0</span>,                       <span class="comment">// Authority (e.g. Kerberos)    </span></span><br><span class="line">        <span class="number">0</span>,                       <span class="comment">// Context object     </span></span><br><span class="line">        &amp;pServices);             <span class="comment">// pointer to IWbemServices proxy    </span></span><br><span class="line">    <span class="keyword">if</span> (hr != S_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        pLocator-&gt;Release();</span><br><span class="line">        <span class="keyword">return</span> hr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置CoSetProxyBlanket代理安全(CoSetProxyBlanket)，使WMI服务可以模拟客户端</span></span><br><span class="line">    hr = CoSetProxyBlanket(</span><br><span class="line">        pServices,                   <span class="comment">// Indicates the proxy to set    </span></span><br><span class="line">        RPC_C_AUTHN_WINNT,           <span class="comment">// RPC_C_AUTHN_xxx    </span></span><br><span class="line">        RPC_C_AUTHZ_NONE,            <span class="comment">// RPC_C_AUTHZ_xxx    </span></span><br><span class="line">        <span class="literal">NULL</span>,                        <span class="comment">// Server principal name     </span></span><br><span class="line">        RPC_C_AUTHN_LEVEL_CALL,      <span class="comment">// RPC_C_AUTHN_LEVEL_xxx     </span></span><br><span class="line">        RPC_C_IMP_LEVEL_IMPERSONATE, <span class="comment">// RPC_C_IMP_LEVEL_xxx    </span></span><br><span class="line">        <span class="literal">NULL</span>,                        <span class="comment">// client identity    </span></span><br><span class="line">        EOAC_NONE);                  <span class="comment">// proxy capabilities     </span></span><br><span class="line">    <span class="keyword">if</span> (hr != S_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        pServices-&gt;Release();</span><br><span class="line">        pLocator-&gt;Release();</span><br><span class="line">        <span class="keyword">return</span> hr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// WMI查询(IWbemServices), 主要使用WQL语句,保存到全局变量中</span></span><br><span class="line">    <span class="comment">// 使用iwbemservices指针请求WMI</span></span><br><span class="line">    IEnumWbemClassObject* pEnumerator = <span class="literal">NULL</span>;</span><br><span class="line">    hr = pServices-&gt;ExecQuery(</span><br><span class="line">        <span class="keyword">_bstr_t</span>(<span class="string">L&quot;WQL&quot;</span>),</span><br><span class="line">        <span class="keyword">_bstr_t</span>(wszCmd), <span class="comment">// 参数传入的命令</span></span><br><span class="line">        WBEM_FLAG_FORWARD_ONLY | WBEM_FLAG_RETURN_IMMEDIATELY,  <span class="comment">// 同步查询   </span></span><br><span class="line">        <span class="literal">NULL</span>,</span><br><span class="line">        &amp;pEnumerator);</span><br><span class="line">    <span class="keyword">if</span> (hr != S_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        pServices-&gt;Release();</span><br><span class="line">        pLocator-&gt;Release();</span><br><span class="line">        <span class="keyword">return</span> hr;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 枚举所有信息</span></span><br><span class="line">    ULONG uReturn = <span class="number">0</span>;</span><br><span class="line">    VARIANT vtInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IWbemClassObject* pClassObject = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (pEnumerator != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取每条信息的内容</span></span><br><span class="line">        hr = pEnumerator-&gt;Next(WBEM_INFINITE, <span class="number">1</span>, &amp;pClassObject, &amp;uReturn);</span><br><span class="line">        <span class="keyword">if</span> ((hr != S_OK) || (uReturn == <span class="number">0</span>) || (pClassObject == <span class="literal">NULL</span>)) <span class="keyword">break</span>;</span><br><span class="line">        VariantInit(&amp;vtInfo);</span><br><span class="line">        <span class="comment">// 得到要返回的信息表中的某个字段值放入到变量vtInfo中。</span></span><br><span class="line">        hr = pClassObject-&gt;Get(wszName, <span class="number">0</span>, &amp;vtInfo, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (hr != S_OK) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 调用参数中的回调函数</span></span><br><span class="line">        hr = Callback(vtInfo);</span><br><span class="line">        <span class="keyword">if</span> (hr != S_OK) <span class="keyword">break</span>;</span><br><span class="line">        VariantClear(&amp;vtInfo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pClassObject != <span class="literal">NULL</span>) pClassObject-&gt;Release();</span><br><span class="line">    <span class="keyword">if</span> (pEnumerator != <span class="literal">NULL</span>) pEnumerator-&gt;Release();</span><br><span class="line">    pServices-&gt;Release();</span><br><span class="line">    pLocator-&gt;Release();</span><br><span class="line">    <span class="keyword">return</span> hr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="相关查询指令"><a href="#相关查询指令" class="headerlink" title="相关查询指令"></a>相关查询指令</h4><p>查询CPU信息，其 <code>L&quot;ProcessorId&quot;</code> 字段为 <code>CPUID</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">L&quot;SELECT * FROM Win32_Processor&quot;</span> <span class="comment">// CPU信息</span></span><br></pre></td></tr></table></figure>

<p>查询硬盘信息，其 <code>L&quot;SerialNumber&quot;</code> 字段为 <code>硬盘序列号</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">L&quot;SELECT * FROM Win32_DiskDrive&quot;</span> <span class="comment">// 硬盘信息</span></span><br></pre></td></tr></table></figure>

<p>查询内存信息，其 <code>L&quot;Capacity&quot;</code> 字段为 <code>内存大小</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">L&quot;SELECT * FROM Win32_PhysicalMemory&quot;</span> <span class="comment">// 内存信息</span></span><br></pre></td></tr></table></figure>

<p>查询已安装补丁信息，其 <code>L&quot;HotFixID&quot;</code> 字段为 <code>已安装补丁ID</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">L&quot;SELECT * FROM Win32_QuickFixEngineering&quot;</span> <span class="comment">// 已安装补丁信息</span></span><br></pre></td></tr></table></figure>

<h4 id="WMIC-EXE工具"><a href="#WMIC-EXE工具" class="headerlink" title="WMIC.EXE工具"></a>WMIC.EXE工具</h4><p>操作系统提供了一个具有WMI功能的 <code>wmic.exe</code> 程序，可以运行 <code>wmic.exe /?</code> 来查看该程序如何使用。</p>
<h4 id="常见查询总结"><a href="#常见查询总结" class="headerlink" title="常见查询总结"></a>常见查询总结</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Win32_Processor <span class="comment">// CPU 处理器</span></span><br><span class="line">Win32_PhysicalMemory <span class="comment">// 物理内存</span></span><br><span class="line">Win32_Keyboard <span class="comment">// 键盘</span></span><br><span class="line">Win32_PointingDevice <span class="comment">// 点输入设备，如鼠标</span></span><br><span class="line">Win32_DiskDrive <span class="comment">// 硬盘驱动器</span></span><br><span class="line">Win32_CDROMDrive <span class="comment">// 光盘驱动器</span></span><br><span class="line">Win32_BaseBoard <span class="comment">// 主板</span></span><br><span class="line">Win32_BIOS <span class="comment">// BIOS 芯片</span></span><br><span class="line">Win32_ParallelPort <span class="comment">// 并口</span></span><br><span class="line">Win32_SerialPort <span class="comment">// 串口</span></span><br><span class="line">Win32_SoundDevice <span class="comment">// 多媒体设置</span></span><br><span class="line">Win32_USBController <span class="comment">// USB 控制器</span></span><br><span class="line">Win32_NetworkAdapter <span class="comment">// 网络适配器</span></span><br><span class="line">Win32_NetworkAdapterConfiguration <span class="comment">// 网络适配器设置</span></span><br><span class="line">Win32_Printer <span class="comment">// 打印机</span></span><br><span class="line">Win32_PrinterConfiguration <span class="comment">// 打印机设置</span></span><br><span class="line">Win32_PrintJob <span class="comment">// 打印机任务</span></span><br><span class="line">Win32_TCPIPPrinterPort <span class="comment">// 打印机端口</span></span><br><span class="line">Win32_POTSModem <span class="comment">// MODEM</span></span><br><span class="line">Win32_POTSModemToSerialPort <span class="comment">// MODEM 端口</span></span><br><span class="line">Win32_DesktopMonitor <span class="comment">// 显示器</span></span><br><span class="line">Win32_VideoController <span class="comment">// 显卡细节</span></span><br><span class="line">Win32_VideoSettings <span class="comment">// 显卡支持的显示模式</span></span><br><span class="line">Win32_TimeZone <span class="comment">// 时区</span></span><br><span class="line">Win32_SystemDriver <span class="comment">// 驱动程序</span></span><br><span class="line">Win32_DiskPartition <span class="comment">// 磁盘分区</span></span><br><span class="line">Win32_LogicalDisk <span class="comment">// 逻辑磁盘</span></span><br><span class="line">Win32_LogicalMemoryConfiguration <span class="comment">// 逻辑内存配置</span></span><br><span class="line">Win32_PageFile <span class="comment">// 系统页文件信息</span></span><br><span class="line">Win32_PageFileSetting <span class="comment">// 页文件设置</span></span><br><span class="line">Win32_BootConfiguration <span class="comment">// 系统启动配置</span></span><br><span class="line">Win32_OperatingSystem <span class="comment">// 操作系统信息</span></span><br><span class="line">Win32_StartupCommand <span class="comment">// 系统自动启动程序</span></span><br><span class="line">Win32_Service <span class="comment">// 系统安装的服务</span></span><br><span class="line">Win32_Group <span class="comment">// 系统管理组</span></span><br><span class="line">Win32_GroupUser <span class="comment">// 系统组帐号</span></span><br><span class="line">Win32_UserAccount <span class="comment">// 用户帐号</span></span><br><span class="line">Win32_Process <span class="comment">// 系统进程</span></span><br><span class="line">Win32_Thread <span class="comment">// 系统线程</span></span><br><span class="line">Win32_Share <span class="comment">// 共享</span></span><br><span class="line">Win32_NetworkClient <span class="comment">// 已安装的网络客户端</span></span><br><span class="line">Win32_NetworkProtocol <span class="comment">// 已安装的网络协议</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>模拟手动从桌面运行程序(1)</title>
    <url>/2021/01/20/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%A8%A1%E6%8B%9F%E6%89%8B%E5%8A%A8%E4%BB%8E%E6%A1%8C%E9%9D%A2%E8%BF%90%E8%A1%8C%E7%A8%8B%E5%BA%8F-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>有的时候做测试，需要模拟手动从桌面运行程序，来区分使用API运行程序的效果</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>原理就是查找桌面窗口，遍历桌面窗口的所有项，找到并选择目标项，再发送按下回车键</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;commctrl.h&gt;</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">RunDesktopItem</span><span class="params">(PCWSTR pName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pName) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 查找桌面窗口</span></span><br><span class="line">    HWND hWndParent = FindWindowW(<span class="string">L&quot;Progman&quot;</span>, <span class="string">L&quot;Program Manager&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hWndParent) <span class="keyword">return</span> FALSE;</span><br><span class="line">    HWND hWndSHELLDLL_DefView = FindWindowExW(hWndParent, <span class="literal">NULL</span>, <span class="string">L&quot;SHELLDLL_DefView&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hWndSHELLDLL_DefView) <span class="keyword">return</span> FALSE;</span><br><span class="line">    HWND hWndSysListView32 = FindWindowExW(hWndSHELLDLL_DefView, <span class="literal">NULL</span>, <span class="string">L&quot;SysListView32&quot;</span>, <span class="string">L&quot;FolderView&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hWndSysListView32) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">int</span> nCount = (<span class="keyword">int</span>)SendMessageW(hWndSysListView32, LVM_GETITEMCOUNT, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (nCount &lt; <span class="number">1</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 向桌面进程申请缓存区</span></span><br><span class="line">    DWORD dwPid = <span class="number">0</span>;</span><br><span class="line">    GetWindowThreadProcessId(hWndSysListView32, &amp;dwPid);</span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">    <span class="keyword">if</span> (!hProcess) <span class="keyword">return</span> FALSE;</span><br><span class="line">    LVITEM *_lvi = (LVITEM*)VirtualAllocEx(hProcess, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(LVITEM), MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!_lvi)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    PWCHAR _item = (PWCHAR)VirtualAllocEx(hProcess, <span class="literal">NULL</span>, MAX_PATH * <span class="keyword">sizeof</span>(WCHAR), MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!_item)</span><br><span class="line">    &#123;</span><br><span class="line">        VirtualFreeEx(hProcess, _lvi, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">        CloseHandle(hProcess);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环获取桌面项的名称</span></span><br><span class="line">    LVITEM lvi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    WCHAR item[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    LRESULT result = <span class="number">0</span>;</span><br><span class="line">    BOOL bRet = FALSE;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nCount; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lvi.mask = LVIF_TEXT;</span><br><span class="line">        lvi.pszText = _item;</span><br><span class="line">        lvi.cchTextMax = MAX_PATH;</span><br><span class="line">        WriteProcessMemory(hProcess, _lvi, &amp;lvi, <span class="keyword">sizeof</span>(LVITEM), <span class="literal">NULL</span>);</span><br><span class="line">        result = SendMessageW(hWndSysListView32, LVM_GETITEMTEXT, (WPARAM)i, (LPARAM)_lvi);</span><br><span class="line">        ReadProcessMemory(hProcess, _item, item, MAX_PATH * <span class="keyword">sizeof</span>(WCHAR), <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 标记目标项为选中状态</span></span><br><span class="line">        <span class="keyword">if</span> (!wcscmp(item, pName))</span><br><span class="line">        &#123;</span><br><span class="line">            lvi.mask = LVIF_STATE;</span><br><span class="line">            lvi.state = LVIS_FOCUSED | LVIS_SELECTED;</span><br><span class="line">            lvi.stateMask = LVIS_FOCUSED | LVIS_SELECTED;</span><br><span class="line">            WriteProcessMemory(hProcess, _lvi, &amp;lvi, <span class="keyword">sizeof</span>(LVITEM), <span class="literal">NULL</span>);</span><br><span class="line">            result = SendMessageW(hWndSysListView32, LVM_SETITEMSTATE, (WPARAM)i, (LPARAM)_lvi);</span><br><span class="line">            <span class="comment">// 发送按下回车键</span></span><br><span class="line">            SendMessageW(hWndSysListView32, WM_KEYDOWN, VK_RETURN, <span class="number">0</span>);</span><br><span class="line">            SendMessageW(hWndSysListView32, WM_KEYUP, VK_RETURN, <span class="number">0</span>);</span><br><span class="line">            bRet = TRUE;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放申请的缓存区</span></span><br><span class="line">    VirtualFreeEx(hProcess, _lvi, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    VirtualFreeEx(hProcess, _item, <span class="number">0</span>, MEM_RELEASE);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>用代码实现PIN到任务栏(1)</title>
    <url>/2021/03/03/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%94%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0PIN%E5%88%B0%E4%BB%BB%E5%8A%A1%E6%A0%8F-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>早先在Win7/Win8系统中，可以使用 <code>ShellExecute</code> 函数把程序图标固定到任务栏，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ShellExecuteW(<span class="literal">NULL</span>, <span class="string">L&quot;taskbarpin&quot;</span>, shortcut, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 固定到任务栏</span></span><br><span class="line">ShellExecuteW(<span class="literal">NULL</span>, <span class="string">L&quot;taskbarunpin&quot;</span>, shortcut, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>); <span class="comment">// 从任务栏解除</span></span><br></pre></td></tr></table></figure>

<p>而到了Win10中，微软取消了用代码 <code>taskbarpin</code> 的方式，只留下户手动PIN到任务栏的方式，<br>从任务栏解除 <code>taskbarunpin</code> 仍然有效。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>实现的原理就是：使用COM接口，模拟人工操作目标，右键单击程序，并选择固定到任务栏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shldisp.h&gt;</span></span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">PinToTaskbar</span><span class="params">(PCWSTR pFolder, PCWSTR pName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pFolder || !pName)</span><br><span class="line">        <span class="keyword">return</span> ERROR_INVALID_PARAMETER;</span><br><span class="line">    <span class="comment">// 初始化COM组件</span></span><br><span class="line">    CoInitialize(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 获取shell的CLSID</span></span><br><span class="line">    CLSID clsid = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HRESULT hr = CLSIDFromProgID(<span class="string">L&quot;Shell.Application&quot;</span>, &amp;clsid);</span><br><span class="line">    <span class="keyword">if</span> (FAILED(hr)) <span class="keyword">return</span> HRESULT_CODE(hr);</span><br><span class="line">    <span class="comment">// 获取右键菜单列表</span></span><br><span class="line">    BSTR bs = <span class="literal">NULL</span>;</span><br><span class="line">    VARIANT var = &#123; VT_BSTR &#125;;</span><br><span class="line">    IShellDispatch* pisd = <span class="literal">NULL</span>;</span><br><span class="line">    Folder* pf = <span class="literal">NULL</span>;</span><br><span class="line">    FolderItem* pfi = <span class="literal">NULL</span>;</span><br><span class="line">    FolderItemVerbs* pfivs = <span class="literal">NULL</span>;</span><br><span class="line">    FolderItemVerb* pfiv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建shell实例</span></span><br><span class="line">        hr = CoCreateInstance(clsid, <span class="literal">NULL</span>,</span><br><span class="line">            CLSCTX_INPROC_SERVER, IID_IDispatch, (<span class="keyword">void</span>**)&amp;pisd);</span><br><span class="line">        <span class="keyword">if</span> (FAILED(hr)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 处理文件路径</span></span><br><span class="line">        var.bstrVal = SysAllocString(pFolder);</span><br><span class="line">        <span class="keyword">if</span> (!var.bstrVal) <span class="keyword">break</span>;</span><br><span class="line">        hr = pisd-&gt;NameSpace(var, &amp;pf);</span><br><span class="line">        <span class="keyword">if</span> (FAILED(hr)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 处理文件名</span></span><br><span class="line">        bs = SysAllocString(pName);</span><br><span class="line">        <span class="keyword">if</span> (!bs) <span class="keyword">break</span>;</span><br><span class="line">        hr = pf-&gt;ParseName(bs, &amp;pfi);</span><br><span class="line">        <span class="keyword">if</span> (FAILED(hr)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 获取右键菜单列表</span></span><br><span class="line">        hr = pfi-&gt;Verbs(&amp;pfivs);</span><br><span class="line">        <span class="keyword">if</span> (FAILED(hr)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">long</span> n = <span class="number">0</span>;</span><br><span class="line">        hr = pfivs-&gt;get_Count(&amp;n);</span><br><span class="line">        <span class="keyword">if</span> (FAILED(hr)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 循环遍历右键菜单列表</span></span><br><span class="line">        BSTR name = <span class="literal">NULL</span>;</span><br><span class="line">        BOOL bRet = FALSE;</span><br><span class="line">        VARIANT i = &#123; VT_I4 &#125;;</span><br><span class="line">        <span class="keyword">for</span> (i.lVal = <span class="number">0</span>; i.lVal &lt; n; i.lVal++)</span><br><span class="line">        &#123;</span><br><span class="line">            hr = pfivs-&gt;Item(i, &amp;pfiv);</span><br><span class="line">            <span class="keyword">if</span> (FAILED(hr)) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// 对比右键菜单项的名称</span></span><br><span class="line">            hr = pfiv-&gt;get_Name(&amp;name);</span><br><span class="line">            <span class="keyword">if</span> (SUCCEEDED(hr))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (!wcscmp(name, <span class="string">L&quot;固定到任务栏(&amp;K)&quot;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 执行目标项</span></span><br><span class="line">                    hr = pfiv-&gt;DoIt();</span><br><span class="line">                    bRet = TRUE;</span><br><span class="line">                &#125;</span><br><span class="line">                SysFreeString(name);</span><br><span class="line">            &#125;</span><br><span class="line">            pfiv-&gt;Release();</span><br><span class="line">            <span class="keyword">if</span> (bRet) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 释放所用的数据</span></span><br><span class="line">    <span class="keyword">if</span> (bs) SysFreeString(bs);</span><br><span class="line">    <span class="keyword">if</span> (var.bstrVal) SysFreeString(var.bstrVal);</span><br><span class="line">    <span class="keyword">if</span> (pfivs) pfivs-&gt;Release();</span><br><span class="line">    <span class="keyword">if</span> (pfi) pfi-&gt;Release();</span><br><span class="line">    <span class="keyword">if</span> (pf) pf-&gt;Release();</span><br><span class="line">    <span class="keyword">if</span> (pisd) pisd-&gt;Release();</span><br><span class="line">    <span class="keyword">return</span> HRESULT_CODE(hr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另外我们还需要把当前程序伪装成 <code>explorer.exe</code> 程序，右键菜单中才会出现 <code>固定到任务栏(&amp;K)</code> 项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ntdll.lib&quot;</span>)</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">FakeToExplorer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取explorer的路径</span></span><br><span class="line">    WCHAR szwPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    GetWindowsDirectoryW(szwPath, MAX_PATH);</span><br><span class="line">    wcscat_s(szwPath, <span class="string">L&quot;\\Explorer.exe&quot;</span>);</span><br><span class="line">    <span class="comment">// 查询当前程序的PEB信息</span></span><br><span class="line">    PROCESS_BASIC_INFORMATION pbi = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS ret = NtQueryInformationProcess(GetCurrentProcess(),</span><br><span class="line">        ProcessBasicInformation, &amp;pbi, <span class="keyword">sizeof</span>(pbi), <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(ret)) <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="comment">// 检查当前程序路径缓冲区是否足够</span></span><br><span class="line">    USHORT n = (USHORT)wcslen(szwPath);</span><br><span class="line">    <span class="keyword">if</span> (pbi.PebBaseAddress-&gt;ProcessParameters-&gt;ImagePathName.MaximumLength / <span class="number">2</span> &lt;= n)</span><br><span class="line">        <span class="keyword">return</span> ERROR_INSUFFICIENT_BUFFER;</span><br><span class="line">    <span class="comment">// 伪装成explorer路径，必须要有NULL结尾符</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pbi.PebBaseAddress-&gt;ProcessParameters-&gt;ImagePathName.Buffer, szwPath, n * <span class="number">2</span>);</span><br><span class="line">    pbi.PebBaseAddress-&gt;ProcessParameters-&gt;ImagePathName.Buffer[n] = <span class="number">0</span>; <span class="comment">// 结尾符</span></span><br><span class="line">    pbi.PebBaseAddress-&gt;ProcessParameters-&gt;ImagePathName.Length = n * <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> ERROR_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>用代码实现扫描WIFI并连接(1)</title>
    <url>/2021/03/23/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%94%A8%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%89%AB%E6%8F%8FWIFI%E5%B9%B6%E8%BF%9E%E6%8E%A5-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>微软提供了一系列WLAN相关的API函数，用来处理WIFI扫描和连接等的任务，<br>并且在对应API的MSDN文档中也给出了一些示例代码，如下做了一些整理</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><h5 id="1-扫描WIFI接入点"><a href="#1-扫描WIFI接入点" class="headerlink" title="1.扫描WIFI接入点"></a>1.扫描WIFI接入点</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wlanapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;wlanapi.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID CALLBACK <span class="title">SubScanProc</span><span class="params">(PWLAN_NOTIFICATION_DATA pData, PVOID pContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pData-&gt;NotificationCode == wlan_notification_acm_scan_complete)</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugStringW(<span class="string">L&quot;scan ok!\n\n&quot;</span>);</span><br><span class="line">        SetEvent((HANDLE)pContext); <span class="comment">// 扫描完成</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pData-&gt;NotificationCode == wlan_notification_acm_scan_fail)</span><br><span class="line">    &#123;</span><br><span class="line">        OutputDebugStringW(<span class="string">L&quot;scan fail!\n\n&quot;</span>);</span><br><span class="line">        SetEvent((HANDLE)pContext); <span class="comment">// 扫描失败</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">SubScan</span><span class="params">(HANDLE hClient, PWLAN_INTERFACE_INFO pIfInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hEvent = CreateEventW(<span class="literal">NULL</span>, TRUE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hEvent) <span class="keyword">return</span> GetLastError();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注册WLAN通知</span></span><br><span class="line">    DWORD dwResult = WlanRegisterNotification(</span><br><span class="line">        hClient, WLAN_NOTIFICATION_SOURCE_ACM, TRUE,</span><br><span class="line">        SubScanProc, (PVOID)hEvent, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (dwResult != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hEvent);</span><br><span class="line">        <span class="keyword">return</span> dwResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 扫描WIFI接入点</span></span><br><span class="line">    dwResult = WlanScan(hClient, &amp;pIfInfo-&gt;InterfaceGuid, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (dwResult == ERROR_SUCCESS)</span><br><span class="line">        WaitForSingleObject(hEvent, INFINITE); <span class="comment">// 等待扫描结果</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消WIFI通知</span></span><br><span class="line">    WlanRegisterNotification(</span><br><span class="line">        hClient, WLAN_NOTIFICATION_SOURCE_ACM, TRUE,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    CloseHandle(hEvent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dwResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-获取当前可连接列表"><a href="#2-获取当前可连接列表" class="headerlink" title="2.获取当前可连接列表"></a>2.获取当前可连接列表</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">SubGetAvailableList</span><span class="params">(HANDLE hClient, PWLAN_INTERFACE_INFO pIfInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PWLAN_AVAILABLE_NETWORK_LIST pBssList = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwResult = WlanGetAvailableNetworkList(</span><br><span class="line">        hClient, &amp;pIfInfo-&gt;InterfaceGuid, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;pBssList);</span><br><span class="line">    <span class="keyword">if</span> (dwResult != ERROR_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> dwResult;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (DWORD j = <span class="number">0</span>; j &lt; pBssList-&gt;dwNumberOfItems; j++)</span><br><span class="line">    &#123;</span><br><span class="line">        PWLAN_AVAILABLE_NETWORK pBssEntry = &amp;pBssList-&gt;Network[j];</span><br><span class="line">        <span class="comment">// 保存的连接设置名</span></span><br><span class="line">        pBssEntry-&gt;strProfileName;</span><br><span class="line">        <span class="comment">// WIFI的接入点名称</span></span><br><span class="line">        pBssEntry-&gt;dot11Ssid.uSSIDLength;</span><br><span class="line">        pBssEntry-&gt;dot11Ssid.ucSSID;</span><br><span class="line">        <span class="comment">// 是否可以连接</span></span><br><span class="line">        pBssEntry-&gt;bNetworkConnectable;</span><br><span class="line">        <span class="comment">// 无法连接的原因</span></span><br><span class="line">        pBssEntry-&gt;wlanNotConnectableReason;</span><br><span class="line">        <span class="comment">// 信号的质量</span></span><br><span class="line">        <span class="keyword">int</span> iRSSI = <span class="number">-100</span> + (pBssEntry-&gt;wlanSignalQuality / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">// 是否支持安全连接</span></span><br><span class="line">        pBssEntry-&gt;bSecurityEnabled;</span><br><span class="line">        <span class="comment">// 默认使用的验证算法</span></span><br><span class="line">        pBssEntry-&gt;dot11DefaultAuthAlgorithm;</span><br><span class="line">        <span class="comment">// 默认使用的加密算法</span></span><br><span class="line">        pBssEntry-&gt;dot11DefaultCipherAlgorithm;</span><br><span class="line">        <span class="comment">// 接入点的状态和标志</span></span><br><span class="line">        pBssEntry-&gt;dwFlags &amp; WLAN_AVAILABLE_NETWORK_CONNECTED; <span class="comment">// 是否已连接</span></span><br><span class="line">        pBssEntry-&gt;dwFlags &amp; WLAN_AVAILABLE_NETWORK_HAS_PROFILE; <span class="comment">// 是否有配置</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 使用配置进行连接</span></span><br><span class="line">        <span class="keyword">if</span> (!wcscmp(pBssEntry-&gt;strProfileName, <span class="string">L&quot;CMCC&quot;</span>) &amp;&amp;</span><br><span class="line">            !(pBssEntry-&gt;dwFlags &amp; WLAN_AVAILABLE_NETWORK_CONNECTED) &amp;&amp;</span><br><span class="line">            (pBssEntry-&gt;dwFlags &amp; WLAN_AVAILABLE_NETWORK_HAS_PROFILE))</span><br><span class="line">        &#123;</span><br><span class="line">            SubConnect(hClient, pIfInfo, pBssEntry);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pBssList)</span><br><span class="line">        WlanFreeMemory(pBssList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ERROR_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-使用配置进行连接"><a href="#3-使用配置进行连接" class="headerlink" title="3.使用配置进行连接"></a>3.使用配置进行连接</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">SubConnect</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HANDLE hClient,</span></span></span><br><span class="line"><span class="function"><span class="params">    PWLAN_INTERFACE_INFO pIfInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">    PWLAN_AVAILABLE_NETWORK pBssEntry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WLAN_CONNECTION_PARAMETERS ConnPara = &#123;&#125;;</span><br><span class="line">    ConnPara.wlanConnectionMode = wlan_connection_mode_profile; <span class="comment">// 使用配置</span></span><br><span class="line">    ConnPara.strProfile = pBssEntry-&gt;strProfileName;</span><br><span class="line">    ConnPara.pDot11Ssid = &amp;pBssEntry-&gt;dot11Ssid;</span><br><span class="line">    ConnPara.dot11BssType = pBssEntry-&gt;dot11BssType;</span><br><span class="line"></span><br><span class="line">    DWORD dwResult = WlanConnect(hClient, &amp;pIfInfo-&gt;InterfaceGuid, &amp;ConnPara, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (dwResult == ERROR_SUCCESS)</span><br><span class="line">        OutputDebugStringW(<span class="string">&quot;Connect ok!\n\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        OutputDebugStringW(<span class="string">&quot;Connect fail!\n\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> dwResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-打开WLAN设备并进行遍历"><a href="#4-打开WLAN设备并进行遍历" class="headerlink" title="4.打开WLAN设备并进行遍历"></a>4.打开WLAN设备并进行遍历</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">WlanControlRequest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hClient = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwCurVersion = <span class="number">0</span>;</span><br><span class="line">    DWORD dwResult = WlanOpenHandle(<span class="number">2</span>, <span class="literal">NULL</span>, &amp;dwCurVersion, &amp;hClient);</span><br><span class="line">    <span class="keyword">if</span> (dwResult != ERROR_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> dwResult;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历所有WLAN设备接口</span></span><br><span class="line">    PWLAN_INTERFACE_INFO_LIST pIfList = <span class="literal">NULL</span>;</span><br><span class="line">    dwResult = WlanEnumInterfaces(hClient, <span class="literal">NULL</span>, &amp;pIfList);</span><br><span class="line">    <span class="keyword">if</span> (dwResult != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        WlanCloseHandle(hClient, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> dwResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; pIfList-&gt;dwNumberOfItems; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        PWLAN_INTERFACE_INFO pIfInfo = &amp;pIfList-&gt;InterfaceInfo[i];</span><br><span class="line">         <span class="comment">// 设备接口的GUID</span></span><br><span class="line">        pIfInfo-&gt;InterfaceGuid;</span><br><span class="line">        <span class="comment">// 设备接口的描述信息</span></span><br><span class="line">        pIfInfo-&gt;strInterfaceDescription;</span><br><span class="line">        <span class="comment">// 设备接口的状态</span></span><br><span class="line">        pIfInfo-&gt;isState == wlan_interface_state_connected; <span class="comment">// 已连接</span></span><br><span class="line">        pIfInfo-&gt;isState == wlan_interface_state_disconnected; <span class="comment">// 未连接</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 扫描WIFI接入点</span></span><br><span class="line">        SubScan(hClient, pIfInfo);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取当前可连接列表</span></span><br><span class="line">        SubGetAvailableList(hClient, pIfInfo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pIfList)</span><br><span class="line">        WlanFreeMemory(pIfList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hClient)</span><br><span class="line">        WlanCloseHandle(hClient, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ERROR_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>线程之间的数据同步问题(1)</title>
    <url>/2019/08/08/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E7%BA%BF%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E6%95%B0%E6%8D%AE%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>我们为了提高程序运行效率，大多会采用多线程工作处理，最简单的例子就是 <code>界面线程+工作线程</code> 的模式。<br>不同的线程处理不同的功能，所以随之而来的就有多个线程访问同一段数据时的竞争问题。</p>
<h4 id="数据传输方式"><a href="#数据传输方式" class="headerlink" title="数据传输方式"></a>数据传输方式</h4><p>微软自身有一套消息处理机制，在一些逻辑简单的场合，我们可以直接使用这一机制，通过自定义消息来<br>发送数据，一般使用 <code>PostThreadMessage</code> 来向某个线程发送消息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">PostThreadMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD  idThread,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ UINT   Msg,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ WPARAM wParam,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>除此之外更多的是使用 <code>全局变量</code>，来存储多线程之间共有的数据。</p>
<h4 id="线程同步方式"><a href="#线程同步方式" class="headerlink" title="线程同步方式"></a>线程同步方式</h4><p>多线程同时访问同一个全局变量时，假设这个全局变量是个结构体，当一个线程正在写数据时，另一个线程<br>正好也开始写数据，就会造成数据混乱。线程的同步就是让这种同时操作，限制为顺序操作，来保证每次的<br>操作都是完整的。</p>
<p>一般常用的同步方法，有 <code>Event(事件)</code>  <code>Semaphore(信号量)</code> <code>Mutex(互斥体)</code> <code>CriticalSection(临界区)</code><br><code>Interlock(原子操作)</code> 等。其中 <code>事件</code> <code>信号量</code> <code>互斥体</code> 含有 <code>信号态</code> 与 <code>非信号态</code> 两种状态。我们使用等待函数<br><code>WaitForSingleObject</code> 和 <code>WaitForMultipleObjects</code> 来等待相关对象由 <code>非信号态</code> 切换到 <code>信号态</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">WaitForSingleObject</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HANDLE hHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD  dwMilliseconds</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">WaitForMultipleObjects</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_       DWORD  nCount,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ <span class="keyword">const</span> HANDLE *lpHandles,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_       BOOL   bWaitAll,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_       DWORD  dwMilliseconds</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>在Wait时，我们可以指定等待的时间，单位是毫秒，<code>INFINITE</code> 表示无限等待。如果是因为 <code>超时</code> 等待结束，<br>会返回一个 <code>WAIT_TIMEOUT</code> 返回值，正常的因为 <code>信号态</code> 等待结束，返回值为 <code>WAIT_OBJECT_0</code>。</p>
<h4 id="事件-信号量-互斥体"><a href="#事件-信号量-互斥体" class="headerlink" title="事件/信号量/互斥体"></a>事件/信号量/互斥体</h4><p>当Wait的 <code>事件</code> 处于 <code>非信号态</code> 时，线程进入休眠状态，当 <code>事件</code> 变为 <code>信号态</code> 时，线程结束休眠继续执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ LPSECURITY_ATTRIBUTES lpEventAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     BOOL                  bManualReset, <span class="comment">// 自动 or 手动</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     BOOL                  bInitialState,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ LPCTSTR               lpName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 创建事件</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">SetEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HANDLE hEvent</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 设置为信号态</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">ResetEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HANDLE hEvent</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 设置为非信号态</span></span><br></pre></td></tr></table></figure>

<p>在创建 <code>事件</code> 时，还可以指定 <code>自动恢复到非信号态</code> 还是 <code>手动恢复到非信号态</code>。如果指定为自动，在Wait结束后，<br>会自动把当前的 <code>信号态</code> 设置为 <code>非信号态</code>，而手动就是需要我们自己来改变状态。</p>
<p>信号量的原理与事件相同，只不过信号量只有自动模式，并且可以指定 <code>Wait次数</code> 后才会切换到 <code>非信号态</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateSemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     LONG                  lInitialCount,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     LONG                  lMaximumCount,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ LPCTSTR               lpName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 创建信号量</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">ReleaseSemaphore</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      HANDLE hSemaphore,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      LONG   lReleaseCount,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_opt_ LPLONG lpPreviousCount</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 增加Wait次数</span></span><br></pre></td></tr></table></figure>

<p>如果我们同步操作的代码逻辑特别简短，<code>事件</code> 和 <code>信号量</code> 频繁的 <code>休眠线程</code> 和 <code>唤醒线程</code> 会浪费大量的时间，<br>这个时候我们可以使用 <code>互斥体</code> 来进行同步。<code>互斥体</code> 在Wait时不会休眠线程，而是会不停的轮询当前状态。<br><code>互斥体</code> 只有手动模式，在Wait过后需要主动释放。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateMutex</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ LPSECURITY_ATTRIBUTES lpMutexAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     BOOL                  bInitialOwner,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ LPCTSTR               lpName</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 创建互斥体</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">ReleaseMutex</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HANDLE hMutex</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 释放互斥体</span></span><br></pre></td></tr></table></figure>

<p>在创建 <code>事件</code> <code>信号量</code> <code>互斥体</code> 时，有一个参数能够指定对象名称。如果是在进程内部使用，可以不指定名称，<br>也就是 <code>匿名对象</code> ，我们直接使用句柄进行操作。如果指定名称创建 <code>命名对象</code> ，就可以在不同的进程间使用，<br>在不同进程中打开或创建的同名事件，都是同一个事件。</p>
<h4 id="事件示例代码"><a href="#事件示例代码" class="headerlink" title="事件示例代码"></a>事件示例代码</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 创建手动控制的事件</span></span><br><span class="line">    HANDLE hEvent = CreateEvent(<span class="literal">NULL</span>, FALSE, FALSE, <span class="string">&quot;Global\\TestEvent&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (hEvent == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 设置为信号态</span></span><br><span class="line">    SetEvent(hEvent);</span><br><span class="line">    <span class="comment">// 等待事件为信号态</span></span><br><span class="line">    WaitForSingleObject(hEvent, INFINITE);</span><br><span class="line">    <span class="comment">// 设置为非信号态</span></span><br><span class="line">    ResetEvent(hEvent);</span><br><span class="line">    <span class="comment">// 关闭事件句柄</span></span><br><span class="line">    CloseHandle(hEvent);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="临界区-原子操作"><a href="#临界区-原子操作" class="headerlink" title="临界区/原子操作"></a>临界区/原子操作</h4><p><code>临界区</code> 和 <code>原子操作</code> 的原理，跟 <code>互斥体</code> 类似，只不过不需要使用Wait函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> WINAPI <span class="title">InitializeCriticalSection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_ LPCRITICAL_SECTION lpCriticalSection</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 初始化临界区</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> WINAPI <span class="title">DeleteCriticalSection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ LPCRITICAL_SECTION lpCriticalSection</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 删除临界区</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> WINAPI <span class="title">EnterCriticalSection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ LPCRITICAL_SECTION lpCriticalSection</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 进入临界区</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> WINAPI <span class="title">LeaveCriticalSection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ LPCRITICAL_SECTION lpCriticalSection</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 离开临界区</span></span><br></pre></td></tr></table></figure>

<p><code>临界区</code> 的使用示例代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">CRITICAL_SECTION CriticalSection = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> _tmain(<span class="keyword">int</span> argc, _TCHAR* argv[])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 初始化临界区，只需要初始化一次</span></span><br><span class="line">    InitializeCriticalSection(&amp;CriticalSection);</span><br><span class="line">    <span class="comment">// …… 其他代码 ……</span></span><br><span class="line">    <span class="comment">// 程序退出时，删除临界区</span></span><br><span class="line">    DeleteCriticalSection(&amp;CriticalSection);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">ThreadProc</span><span class="params">(LPVOID lpParameter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// …… 其他代码 ……</span></span><br><span class="line">    <span class="comment">// 进入临界区</span></span><br><span class="line">    EnterCriticalSection(&amp;CriticalSection);</span><br><span class="line">    <span class="comment">// …… 需要同步操作的代码 ……</span></span><br><span class="line">    <span class="comment">// 离开临界区</span></span><br><span class="line">    LeaveCriticalSection(&amp;CriticalSection);</span><br><span class="line">    <span class="comment">// …… 其他代码 ……</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>原子操作</code> 是操作系统提供的，只针对基本类型数据进行操作，比如针对LONG型数据执行算术运算</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG __cdecl <span class="title">InterlockedAdd</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ LONG <span class="keyword">volatile</span> *Addend,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    LONG          Value</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 原子操作加法</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG __cdecl <span class="title">InterlockedIncrement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ LONG <span class="keyword">volatile</span> *Addend</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 原子操作加1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG __cdecl <span class="title">InterlockedDecrement</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ LONG <span class="keyword">volatile</span> *Addend</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 原子操作减1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG __cdecl <span class="title">InterlockedExchange</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ LONG <span class="keyword">volatile</span> *Target,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    LONG          Value</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 原子操作数据交换</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PVOID __cdecl <span class="title">InterlockedExchangePointer</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ PVOID <span class="keyword">volatile</span> *Target,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    PVOID          Value</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 原子操作地址交换</span></span><br></pre></td></tr></table></figure>

<p>还有大量的其他原子操作函数，这里只列出了常见的几种，其他请自行查阅微软的 <code>MSDN</code> 资料</p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>解析快捷方式指向的路径(1)</title>
    <url>/2021/08/17/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%A7%A3%E6%9E%90%E5%BF%AB%E6%8D%B7%E6%96%B9%E5%BC%8F%E6%8C%87%E5%90%91%E7%9A%84%E8%B7%AF%E5%BE%84-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在做垃圾文件清理的时候，会涉及到快捷方式的解析，以确定其是否有效</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>操作系统提供了解析快捷方式的API，其中新型的 <code>msi</code> 快捷方式，多见于Office的程序，其文件路径是<br>类似 <code>msi:xxxx</code> 的ID信息，可以使用 <code>MsiGetShortcutTarget</code> 进行解析。普通的快捷方式，可以使用<br><code>IShellLink</code> 来进行解析，但是这种方法有缺陷，比如指向 <code>C:\Program Files\a.exe</code> 的快捷方式，<br>用64位的程序去解析是正确的，但是用32位的程序去解析，就会得到 <code>C:\Program Files (x86)\a.exe</code>，<br>无论是否使用 <code>Wow64DisableWow64FsRedirection</code> 关闭重定向，都是这样，所以只能解析 <code>lnk</code> 数据格式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atlbase.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atlstr.h&gt;</span></span></span><br><span class="line"><span class="comment">// (MAX_PATH * 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LARGE_PATH 520 </span></span><br><span class="line"><span class="function">LSTATUS <span class="title">ParseLnkGetPath</span><span class="params">(_In_ CStringA csLnk, _Out_ CStringA &amp;csPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    csLnk.MakeLower(); <span class="comment">// 转为小写</span></span><br><span class="line">    <span class="keyword">if</span> (csLnk.GetLength() &lt; <span class="number">5</span>) <span class="keyword">return</span> ERROR_INVALID_PARAMETER;</span><br><span class="line">    <span class="keyword">if</span> (csLnk.Right(<span class="number">4</span>) != <span class="string">&quot;.lnk&quot;</span>) <span class="keyword">return</span> ERROR_INVALID_PARAMETER;</span><br><span class="line">    <span class="comment">// 获取新型的快捷方式路径（比如OFFICE的）</span></span><br><span class="line">    CHAR szTemp[LARGE_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR szProductCode[<span class="number">39</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR szFeatureId[MAX_FEATURE_CHARS + <span class="number">1</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    CHAR szComponentCode[<span class="number">39</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    LSTATUS ret = MsiGetShortcutTargetA(</span><br><span class="line">        (PCSTR)csLnk, szProductCode, szFeatureId, szComponentCode);</span><br><span class="line">    <span class="keyword">if</span> (ret == ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        DWORD dwSize = LARGE_PATH * <span class="keyword">sizeof</span>(WCHAR);</span><br><span class="line">        <span class="comment">// 未检测szTemp空间是否足够大</span></span><br><span class="line">        INSTALLSTATE state = MsiGetComponentPathA(</span><br><span class="line">            szProductCode, szComponentCode, szTemp, &amp;dwSize);</span><br><span class="line">        <span class="keyword">if</span> (state == INSTALLSTATE_LOCAL)</span><br><span class="line">        &#123;</span><br><span class="line">            _strlwr_s(szTemp); <span class="comment">// 转为小写</span></span><br><span class="line">            csPath = szTemp;</span><br><span class="line">            <span class="keyword">return</span> ERROR_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ERROR_INVALID_PARAMETER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取快捷方式的内容</span></span><br><span class="line">    ret = ERROR_INVALID_PARAMETER;</span><br><span class="line">    HANDLE hFile = CreateFileA((PCSTR)csLnk, GENERIC_READ, FILE_SHARE_READ,</span><br><span class="line">        <span class="literal">NULL</span>, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) <span class="keyword">return</span> ret;</span><br><span class="line">    <span class="comment">// 按照特定格式解析内容</span></span><br><span class="line">    DWORD dwFlag = <span class="number">0</span>;</span><br><span class="line">    DWORD dwReadLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ReadFile(hFile, &amp;dwFlag, <span class="keyword">sizeof</span>(DWORD), &amp;dwReadLen, <span class="literal">NULL</span>)) <span class="keyword">goto</span> Last;</span><br><span class="line">    <span class="keyword">if</span> (dwReadLen != <span class="keyword">sizeof</span>(DWORD)) <span class="keyword">goto</span> Last;</span><br><span class="line">    <span class="keyword">if</span> (dwFlag != <span class="number">0x0000004C</span>UL) <span class="keyword">goto</span> Last;</span><br><span class="line"></span><br><span class="line">    DWORD dwRet = SetFilePointer(hFile, <span class="number">0x00000014</span>L, <span class="literal">NULL</span>, FILE_BEGIN);</span><br><span class="line">    <span class="keyword">if</span> (dwRet == INVALID_SET_FILE_POINTER) <span class="keyword">goto</span> Last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ReadFile(hFile, &amp;dwFlag, <span class="keyword">sizeof</span>(DWORD), &amp;dwReadLen, <span class="literal">NULL</span>)) <span class="keyword">goto</span> Last;</span><br><span class="line">    <span class="keyword">if</span> (dwReadLen != <span class="keyword">sizeof</span>(DWORD)) <span class="keyword">goto</span> Last;</span><br><span class="line"></span><br><span class="line">    dwRet = SetFilePointer(hFile, <span class="number">0x0000004C</span>L, <span class="literal">NULL</span>, FILE_BEGIN);</span><br><span class="line">    <span class="keyword">if</span> (dwRet == INVALID_SET_FILE_POINTER) <span class="keyword">goto</span> Last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dwFlag &amp; <span class="number">0x00000001</span>UL)</span><br><span class="line">    &#123;</span><br><span class="line">        WORD wSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ReadFile(hFile, &amp;wSize, <span class="keyword">sizeof</span>(WORD), &amp;dwReadLen, <span class="literal">NULL</span>)) <span class="keyword">goto</span> Last;</span><br><span class="line">        <span class="keyword">if</span> (dwReadLen != <span class="keyword">sizeof</span>(WORD)) <span class="keyword">goto</span> Last;</span><br><span class="line"></span><br><span class="line">        dwRet = SetFilePointer(hFile, (LONG)wSize, <span class="literal">NULL</span>, FILE_CURRENT);</span><br><span class="line">        <span class="keyword">if</span> (dwRet == INVALID_SET_FILE_POINTER) <span class="keyword">goto</span> Last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    dwRet = SetFilePointer(hFile, <span class="number">0x00000010</span>L, <span class="literal">NULL</span>, FILE_CURRENT);</span><br><span class="line">    <span class="keyword">if</span> (dwRet == INVALID_SET_FILE_POINTER) <span class="keyword">goto</span> Last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!ReadFile(hFile, &amp;dwFlag, <span class="keyword">sizeof</span>(DWORD), &amp;dwReadLen, <span class="literal">NULL</span>)) <span class="keyword">goto</span> Last;</span><br><span class="line">    <span class="keyword">if</span> (dwReadLen != <span class="keyword">sizeof</span>(DWORD)) <span class="keyword">goto</span> Last;</span><br><span class="line"></span><br><span class="line">    dwRet = SetFilePointer(hFile,</span><br><span class="line">        <span class="number">-0x00000010</span>L - (LONG)<span class="keyword">sizeof</span>(DWORD) + (LONG)dwFlag, <span class="literal">NULL</span>, FILE_CURRENT);</span><br><span class="line">    <span class="keyword">if</span> (dwRet == INVALID_SET_FILE_POINTER) <span class="keyword">goto</span> Last;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> ch = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(szTemp, <span class="number">0</span>, <span class="keyword">sizeof</span>(szTemp));</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!ReadFile(hFile, &amp;ch, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), &amp;dwReadLen, <span class="literal">NULL</span>)) <span class="keyword">goto</span> Last;</span><br><span class="line">        *(szTemp + i++) = ch; <span class="comment">// 未检测szTemp空间是否足够大</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (ch != <span class="string">&#x27;\0&#x27;</span>);</span><br><span class="line"></span><br><span class="line">    _strlwr_s(szTemp); <span class="comment">// 小写</span></span><br><span class="line">    csPath = szTemp;</span><br><span class="line">    ret = ERROR_SUCCESS;</span><br><span class="line">Last:</span><br><span class="line">    CloseHandle(hFile);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>触控板和触摸屏动作数据解析(1)</title>
    <url>/2021/04/27/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%A7%A6%E6%8E%A7%E6%9D%BF%E5%92%8C%E8%A7%A6%E6%91%B8%E5%B1%8F%E5%8A%A8%E4%BD%9C%E6%95%B0%E6%8D%AE%E8%A7%A3%E6%9E%90-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在Windows系统中，预设了一些多点触控手势操作，提供用户进行操作。但有时候我们想要自己定义<br>一些手势，来实现其他的操作，这就需要进行触摸输入的开发</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><h5 id="1-触摸消息-Touch-Message"><a href="#1-触摸消息-Touch-Message" class="headerlink" title="1.触摸消息(Touch Message)"></a>1.触摸消息(Touch Message)</h5><p>Windows系统提供了处理触摸屏手势和动作的 <code>WM_GESTURE</code> 和 <code>WM_TOUCH</code> 消息，可以在MSDN帮助文档中<br>查看消息的参数内容，默认情况下，窗口只处理 <code>WM_GESTURE</code> 手势消息，如果注册了 <code>WM_TOUCH</code> 动作消息，<br>窗口就不会再收到手势消息，所有关于触摸屏的说明和示例，都可以在微软MSDN帮助中找到：<br> <a href="https://docs.microsoft.com/en-us/windows/win32/wintouch/windows-touch-portal">https://docs.microsoft.com/en-us/windows/win32/wintouch/windows-touch-portal</a><br>使用该方法有一定的限制，只能在消息窗口激活的状态才能获取到触摸动作，无法在后台状态获取消息</p>
<h5 id="2-原始输入-Raw-Input"><a href="#2-原始输入-Raw-Input" class="headerlink" title="2.原始输入(Raw Input)"></a>2.原始输入(Raw Input)</h5><p>使用获取原始输入数据的方式，可以在后台工作，在微软MSDN帮助中有相关说明：<br><a href="https://docs.microsoft.com/en-us/windows/win32/inputdev/raw-input">https://docs.microsoft.com/en-us/windows/win32/inputdev/raw-input</a><br>键盘和鼠标的输入都有详尽的解释，但是对于触摸设备的说明并不清晰，这里给出一个简单的示例</p>
<h6 id="1-注册设备"><a href="#1-注册设备" class="headerlink" title="1.注册设备"></a>1.注册设备</h6><p>要想获取到 <code>WM_INPUT</code> 原始输入消息，首先需要注册想要监控的输入设备类</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">RegisterRawInputDevices</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  PCRAWINPUTDEVICE pRawInputDevices,</span></span></span><br><span class="line"><span class="function"><span class="params">  UINT             uiNumDevices,</span></span></span><br><span class="line"><span class="function"><span class="params">  UINT             cbSize)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中 <code>RAWINPUTDEVICE</code> 结构体中指定 <code>设备类型</code> 和接收消息的 <code>窗口句柄</code> </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagRAWINPUTDEVICE</span> &#123;</span></span><br><span class="line">  USHORT usUsagePage;</span><br><span class="line">  USHORT usUsage;</span><br><span class="line">  DWORD  dwFlags;</span><br><span class="line">  HWND   hwndTarget;</span><br><span class="line">&#125; RAWINPUTDEVICE, *PRAWINPUTDEVICE, *LPRAWINPUTDEVICE;</span><br></pre></td></tr></table></figure>

<p>关于 <code>UsagePage</code> 和 <code>Usage</code> 的值：（0x0D，0x05）表示触控板，（0x0D，0x04）表示触摸屏：<br><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/hid/hid-architecture#hid-clients-supported-in-windows">https://docs.microsoft.com/en-us/windows-hardware/drivers/hid/hid-architecture#hid-clients-supported-in-windows</a><br><code>Flags</code> 指定 <code>RIDEV_INPUTSINK</code> 值，就可以让指定的窗口，在后台状态获取原始输入信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">RegistrerDevice</span><span class="params">(HWND hWnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    RAWINPUTDEVICE Rid[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    Rid[<span class="number">0</span>].usUsagePage = <span class="number">0x0D</span>; <span class="comment">// HID_USAGE_PAGE_DIGITIZER</span></span><br><span class="line">    Rid[<span class="number">0</span>].usUsage = <span class="number">0x05</span>; <span class="comment">// 符合HID标准的触控板</span></span><br><span class="line">    Rid[<span class="number">0</span>].dwFlags = RIDEV_INPUTSINK;</span><br><span class="line">    Rid[<span class="number">0</span>].hwndTarget = hWnd;</span><br><span class="line">    Rid[<span class="number">1</span>].usUsagePage = <span class="number">0x0D</span>; <span class="comment">// HID_USAGE_PAGE_DIGITIZER</span></span><br><span class="line">    Rid[<span class="number">1</span>].usUsage = <span class="number">0x04</span>; <span class="comment">// 符合HID标准的触摸屏</span></span><br><span class="line">    Rid[<span class="number">1</span>].dwFlags = RIDEV_INPUTSINK;</span><br><span class="line">    Rid[<span class="number">1</span>].hwndTarget = hWnd;</span><br><span class="line">    <span class="keyword">return</span> RegisterRawInputDevices(Rid, <span class="number">1</span>, <span class="keyword">sizeof</span>(RAWINPUTDEVICE));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="2-解析消息"><a href="#2-解析消息" class="headerlink" title="2.解析消息"></a>2.解析消息</h6><p>在 <code>WM_INPUT</code> 消息中，<code>LPARAM</code> 存储着 <code>HRAWINPUT</code> 信息，我们可以用来查询原始输入信息，<br>解析的过程比较复杂，所有的数据都需要通过对应 <code>UsagePage</code> 和 <code>Usage</code> 值来确认内容：<br><a href="https://docs.microsoft.com/en-us/windows-hardware/design/component-guidelines/windows-precision-touchpad-required-hid-top-level-collections#windows-precision-touchpad-input-reports">https://docs.microsoft.com/en-us/windows-hardware/design/component-guidelines/windows-precision-touchpad-required-hid-top-level-collections#windows-precision-touchpad-input-reports</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ParseInputInfo</span><span class="params">(HRAWINPUT lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 申请内存并获取RAWINPUT数据</span></span><br><span class="line">    <span class="comment">// 其实在RAWINPUT中就已经包含全部有效数据，但是所有数据堆积在一起，</span></span><br><span class="line">    <span class="comment">// 我们无法知道其表示的意义，所以才获取PREPARSEDDATA数据重新解析</span></span><br><span class="line">    UINT uSize = <span class="number">0</span>;</span><br><span class="line">    UINT uRet = GetRawInputData(</span><br><span class="line">        lParam, RID_INPUT, <span class="literal">NULL</span>, &amp;uSize, <span class="keyword">sizeof</span>(RAWINPUTHEADER));</span><br><span class="line">    <span class="keyword">if</span> (uRet != <span class="number">0</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    PRAWINPUT pRawInput = (PRAWINPUT)<span class="built_in">malloc</span>(uSize);</span><br><span class="line">    <span class="keyword">if</span> (!pRawInput) <span class="keyword">return</span> FALSE;</span><br><span class="line">    ZeroMemory(pRawInput, uSize);</span><br><span class="line">    uRet = GetRawInputData(</span><br><span class="line">        lParam, RID_INPUT, pRawInput, &amp;uSize, <span class="keyword">sizeof</span>(RAWINPUTHEADER));</span><br><span class="line">    <span class="keyword">if</span> (uRet != uSize) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 获取未解析PREPARSEDDATA数据</span></span><br><span class="line">    uSize = <span class="number">0</span>;</span><br><span class="line">    uRet = GetRawInputDeviceInfoW(</span><br><span class="line">        pRawInput-&gt;header.hDevice, RIDI_PREPARSEDDATA, <span class="literal">NULL</span>, &amp;uSize);</span><br><span class="line">    <span class="keyword">if</span> (uRet != <span class="number">0</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    PHIDP_PREPARSED_DATA pPreparsedData = (PHIDP_PREPARSED_DATA)<span class="built_in">malloc</span>(uSize);</span><br><span class="line">    <span class="keyword">if</span> (!pPreparsedData) <span class="keyword">return</span> FALSE;</span><br><span class="line">    ZeroMemory(pPreparsedData, uSize);</span><br><span class="line">    uRet = GetRawInputDeviceInfoW(</span><br><span class="line">        pRawInput-&gt;header.hDevice, RIDI_PREPARSEDDATA, pPreparsedData, &amp;uSize);</span><br><span class="line">    <span class="keyword">if</span> (uRet != uSize) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 查询PREPARSEDDATA数据中包含Button和Value信息的数量</span></span><br><span class="line">    HIDP_CAPS stCaps = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS ntStatus = HidP_GetCaps(pPreparsedData, &amp;stCaps);</span><br><span class="line">    <span class="keyword">if</span> (ntStatus != HIDP_STATUS_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 申请数组空间用来存储Button和Value数据</span></span><br><span class="line">    ULONG uDataSize = stCaps.NumberInputDataIndices * <span class="keyword">sizeof</span>(HIDP_DATA);</span><br><span class="line">    PHIDP_DATA pDataList = (PHIDP_DATA)<span class="built_in">malloc</span>(uDataSize);</span><br><span class="line">    <span class="keyword">if</span> (!pDataList) <span class="keyword">return</span> FALSE;</span><br><span class="line">    ZeroMemory(pDataList, uDataSize);</span><br><span class="line">    ULONG uDataNum = stCaps.NumberInputDataIndices;</span><br><span class="line">    ntStatus = HidP_GetData(</span><br><span class="line">        HidP_Input, pDataList, &amp;uDataNum, pPreparsedData,</span><br><span class="line">        (PCHAR)pRawInput-&gt;data.hid.bRawData, pRawInput-&gt;data.hid.dwSizeHid);</span><br><span class="line">    <span class="keyword">if</span> (ntStatus != HIDP_STATUS_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 获取全部ButtonCaps信息</span></span><br><span class="line">    uSize = stCaps.NumberInputButtonCaps * <span class="keyword">sizeof</span>(HIDP_BUTTON_CAPS);</span><br><span class="line">    PHIDP_BUTTON_CAPS pButtonCaps = (PHIDP_BUTTON_CAPS)<span class="built_in">malloc</span>(uSize);</span><br><span class="line">    <span class="keyword">if</span> (!pButtonCaps) <span class="keyword">return</span> FALSE;</span><br><span class="line">    ZeroMemory(pButtonCaps, uSize);</span><br><span class="line">    ntStatus = HidP_GetButtonCaps(</span><br><span class="line">        HidP_Input, pButtonCaps, &amp;stCaps.NumberInputButtonCaps, pPreparsedData);</span><br><span class="line">    <span class="keyword">if</span> (ntStatus != HIDP_STATUS_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 在数组中查询对应Index</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; stCaps.NumberInputButtonCaps; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        BOOL isBtnData = FALSE;</span><br><span class="line">        <span class="keyword">for</span> (DWORD j = <span class="number">0</span>; j &lt; uDataNum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pDataList[j].DataIndex == pButtonCaps[i].NotRange.DataIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                isBtnData = pDataList[j].On;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 只会获取On状态的Button数据，如果未查到就说明不是On状态</span></span><br><span class="line">        <span class="keyword">if</span> (pButtonCaps[i].UsagePage == <span class="number">0x0D</span> &amp;&amp;</span><br><span class="line">            pButtonCaps[i].NotRange.Usage == <span class="number">0x47</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里获取的是Confidence信息，注意pButtonCaps[i].IsRange成员，</span></span><br><span class="line">            <span class="comment">// 这里默认当成NotRange处理，但并不总是这样</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取全部ValueCaps信息</span></span><br><span class="line">    uSize = stCaps.NumberInputValueCaps * <span class="keyword">sizeof</span>(HIDP_VALUE_CAPS);</span><br><span class="line">    PHIDP_VALUE_CAPS pValueCaps = (PHIDP_VALUE_CAPS)<span class="built_in">malloc</span>(uSize);</span><br><span class="line">    <span class="keyword">if</span> (!pValueCaps) <span class="keyword">return</span> FALSE;</span><br><span class="line">    ZeroMemory(pValueCaps, uSize);</span><br><span class="line">    ntStatus = HidP_GetValueCaps(</span><br><span class="line">        HidP_Input, pValueCaps, &amp;stCaps.NumberInputValueCaps, pPreparsedData);</span><br><span class="line">    <span class="keyword">if</span> (ntStatus != HIDP_STATUS_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 在数组中查询对应Index</span></span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt; stCaps.NumberInputValueCaps; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ULONG uValueData = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (DWORD j = <span class="number">0</span>; j &lt; uDataNum; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pDataList[j].DataIndex == pValueCaps[i].NotRange.DataIndex)</span><br><span class="line">            &#123;</span><br><span class="line">                uValueData = pDataList[j].RawValue;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pValueCaps[i].UsagePage == <span class="number">0x01</span> &amp;&amp;</span><br><span class="line">            pValueCaps[i].NotRange.Usage == <span class="number">0x30</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 这里获取的是坐标x信息，可以看微软相关规定的链接</span></span><br><span class="line">            LONG nXMax = pValueCaps[i].LogicalMax;</span><br><span class="line">            <span class="comment">// 坐标x的最大值为pValueCaps[i].LogicalMax;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放申请的内存空间</span></span><br><span class="line">    <span class="built_in">free</span>(pDataList);</span><br><span class="line">    <span class="built_in">free</span>(pButtonCaps);</span><br><span class="line">    <span class="built_in">free</span>(pValueCaps);</span><br><span class="line">    <span class="built_in">free</span>(pPreparsedData);</span><br><span class="line">    <span class="built_in">free</span>(pRawInput);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="3-创建窗口"><a href="#3-创建窗口" class="headerlink" title="3.创建窗口"></a>3.创建窗口</h6><p>由于我们并不需要窗口操作界面，所以可以创建 <code>Message-Only Window</code> 来处理消息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (uMsg == WM_INPUT)</span><br><span class="line">    &#123;</span><br><span class="line">        ParseInputInfo((HRAWINPUT)lParam);</span><br><span class="line">        <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> APIENTRY <span class="title">wWinMain</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    HINSTANCE hInst, HINSTANCE hPrevInst, LPWSTR lpCmdLine, <span class="keyword">int</span> nCmdShow)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 注册窗口类</span></span><br><span class="line">    WNDCLASSEXW wcex = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    wcex.cbSize = <span class="keyword">sizeof</span>(WNDCLASSEX);</span><br><span class="line">    wcex.lpfnWndProc = WndProc;</span><br><span class="line">    wcex.hInstance = hInst;</span><br><span class="line">    wcex.lpszClassName = <span class="string">L&quot;MsgOnlyClass&quot;</span>;</span><br><span class="line">    ATOM ret = RegisterClassExW(&amp;wcex);</span><br><span class="line">    <span class="keyword">if</span> (!ret &amp;&amp; (GetLastError() != ERROR_CLASS_ALREADY_EXISTS))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建窗口</span></span><br><span class="line">    HWND hWnd = CreateWindowExW(</span><br><span class="line">        <span class="number">0</span>, <span class="string">L&quot;MsgOnlyClass&quot;</span>, <span class="string">L&quot;MsgOnlyWnd&quot;</span>, <span class="number">0</span>,</span><br><span class="line">        <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, HWND_MESSAGE, <span class="literal">NULL</span>, hInst, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hWnd) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    UpdateWindow(hWnd);</span><br><span class="line">    <span class="comment">// 注册输入设备</span></span><br><span class="line">    <span class="keyword">if</span> (!RegistrerDevice(hWnd))</span><br><span class="line">    &#123;</span><br><span class="line">        DestroyWindow(hWnd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 消息循环</span></span><br><span class="line">    MSG msg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (GetMessageW(&amp;msg, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        TranslateMessage(&amp;msg);</span><br><span class="line">        DispatchMessageW(&amp;msg);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 销毁窗口</span></span><br><span class="line">    DestroyWindow(hWnd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>配置系统审核进程跟踪日志(1)</title>
    <url>/2019/09/23/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F%E5%AE%A1%E6%A0%B8%E8%BF%9B%E7%A8%8B%E8%B7%9F%E8%B8%AA%E6%97%A5%E5%BF%97-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>某些情况下，我们写的进程监控模块，频繁的检测到某进程的退出和启动，然后频繁发出告警。<br>但是客户在任务管理器中，看到这个进程运行着呢，就会认为是我们写的代码有问题，所以这里我们<br>可以通过配置操作系统自带的审计功能，监控进程的启动和退出动作，来验证到底是谁出了问题。</p>
<h4 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h4><ol>
<li>打开 <code>控制面板</code> 然后打开 <code>管理工具</code> 项，找到 <code>本地安全策略</code></li>
</ol>
<p><img src="01.png" alt="管理工具"></p>
<ol start="2">
<li>打开 <code>本地安全策略</code> 中 <code>本地策略</code> 的 <code>审核策略</code> 进行 <code>审核进程跟踪</code> 配置<br>或者在 <code>运行</code> 中直接使用 <code>secpol.msc</code> 指令来打开 <code>本地安全策略</code> 项</li>
</ol>
<p><img src="02.png" alt="本地安全策略"></p>
<ol start="3">
<li>在 <code>审核进程跟踪</code> 中勾选 <code>成功</code> 和 <code>失败</code> 选项并确定</li>
</ol>
<p><img src="03.png" alt="审核进程跟踪"></p>
<h4 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h4><ol>
<li>同样是打开 <code>控制面板</code> 中的 <code>管理工具</code> 项 找到 <code>事件查看器</code></li>
</ol>
<p><img src="04.png" alt="事件查看器"></p>
<ol start="2">
<li>打开 <code>事件查看器</code> 中 <code>Windows日志</code> 里的 <code>安全</code> 项</li>
</ol>
<p><img src="05.png" alt="安全"></p>
<ol start="3">
<li>选中一条审核记录，在下边的 <code>详细信息</code> 中可以找到对应进程名</li>
</ol>
<p><img src="06.png" alt="详细信息"></p>
<p>注意：只有在配置了策略以后才会开始记录进程动作，可以在配置前先 <code>右键</code> 选择清空一下无关的日志。</p>
<p><img src="07.png" alt="清除日志"></p>
]]></content>
      <categories>
        <category>基础知识</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>实现自定义密码复杂度过滤(1)</title>
    <url>/2019/07/29/%E5%AF%86%E7%A0%81%E7%AD%96%E7%95%A5/%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%86%E7%A0%81%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%BF%87%E6%BB%A4-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>由于一些特殊的情况，操作系统提供的密码复杂度检测，不能满足我们的需求。<br>比如 <code>小写字母</code> <code>大写字母</code> <code>数字</code> <code>特殊符号</code> 我们需要全都存在（四选四），但是操作系统只能（四选三），<br>又或者类似 <code>p@ssw0rd</code> 之类的密码，虽然复杂度要求满足，但是太常见，很容易被密码字典破解。<br>所以我们需要注册一个自定义的密码检测规则，在创建或修改密码时，直接进行检测和处理。</p>
<h4 id="过滤器的注册"><a href="#过滤器的注册" class="headerlink" title="过滤器的注册"></a>过滤器的注册</h4><p>微软操作系统提供了一种 <code>Password Filter DLL</code> 的方式，可以在 <code>密码保存之前</code> 对其进行处理。<br>该功能需要导出三个函数，而且必须编译为DLL类型，32位系统使用32位DLL，64位使用64位DLL。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">InitializeChangeNotify</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">PasswordChangeNotify</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ PUNICODE_STRING UserName,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ ULONG           RelativeId,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ PUNICODE_STRING NewPassword</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">PasswordFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ PUNICODE_STRING AccountName,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ PUNICODE_STRING FullName,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ PUNICODE_STRING Password,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ BOOLEAN         SetOperation</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中 <code>InitializeChangeNotify</code> 函数用来初始化DLL信息，返回 <code>TRUE</code> 表示成功，<code>FALSE</code> 表示失败。</p>
<p>其中 <code>PasswordFilter</code> 函数用来自定义我们的过滤规则，参数 <code>Password</code> 就是需要检测的密码，前两个<br>参数是对应的 <code>账户名称</code>，参数 <code>SetOperation</code> 为 <code>TRUE</code> 时，表示 <code>密码新建</code> 操作，反之为 <code>密码修改</code> 操作，<br>返回 <code>TRUE</code> 表示 <code>允许</code> 本次操作，返回 <code>FALSE</code> 表示 <code>拒绝</code> 本次操作。</p>
<p>其中 <code>PasswordChangeNotify</code> 函数会在所有检测都已通过，系统准备存储该密码时调用，该函数多数是<br>做信息记录用，而且只能返回 <code>STATUS_SUCCESS</code> 返回值。</p>
<p>注册该过滤器DLL时，我们需要先把DLL文件，复制到操作系统 <code>System32</code> 目录下，注意用程序复制时，<br>会涉及到64位系统中32位程序的目录重定向问题。然后在如下注册表路径下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Lsa</span><br></pre></td></tr></table></figure>

<p>存在一个 <code>Notification Packages</code> 注册表值，是 <code>REG_MULTI_SZ</code> 类型，如果不存在，需要新建一个，<br>注意 <code>不要删除</code> 原来自带的数据，要在原字符串 <code>后边附加</code> 新字符串，填写DLL的文件名，不要 <code>.dll</code> 后缀。</p>
<p>所有操作完毕后重启操作系统，该DLL过滤器就会被操作系统加载起来。</p>
<h4 id="过滤器的代码"><a href="#过滤器的代码" class="headerlink" title="过滤器的代码"></a>过滤器的代码</h4><p>如下为相关三个函数的代码，我们只处理 <code>PasswordFilter</code> 函数，其余两个函数直接返回成功。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOLEAN __stdcall <span class="title">InitializeChangeNotify</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS __stdcall <span class="title">PasswordChangeNotify</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PUNICODE_STRING UserName, ULONG RelativeId,</span></span></span><br><span class="line"><span class="function"><span class="params">    PUNICODE_STRING NewPassword)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOLEAN __stdcall <span class="title">PasswordFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PUNICODE_STRING AccountName, PUNICODE_STRING FullName,</span></span></span><br><span class="line"><span class="function"><span class="params">    PUNICODE_STRING Password, BOOLEAN SetOperation)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Password == <span class="literal">NULL</span>) <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="keyword">if</span> (Password-&gt;Buffer == <span class="literal">NULL</span>) <span class="keyword">return</span> TRUE;</span><br><span class="line">    <span class="comment">// 检查复杂度（四选四）</span></span><br><span class="line">    <span class="keyword">if</span> (!CheckPwdComplexStrong(Password)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的地方是，每个函数都需要声明 <code>__stdcall</code> 类型，但是这样在头文件中使用<br><code>extern &quot;C&quot;</code> 导出函数时，就变成 <code>_InitializeChangeNotify@0</code> 的样式，导致DLL加载失败，<br>所以我们需要创建一个 <code>.def</code> 文件来代替 <code>extern &quot;C&quot;</code> 声明导出函数，文件内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXPORTS</span><br><span class="line">InitializeChangeNotify</span><br><span class="line">PasswordChangeNotify</span><br><span class="line">PasswordFilter</span><br></pre></td></tr></table></figure>

<p>然后在工程配置中，配置属性 -&gt; 链接器 -&gt; 输入 -&gt; 模块定义文件，加入该 <code>.def</code> 文件</p>
<p><img src="01.png" alt="模块定义文件"></p>
<p>最后如果在写过滤规则时，引入了其他的库，可以使用 <code>多线程 (/MT)</code> 配置，把相关函数编译到DLL中。</p>
]]></content>
      <categories>
        <category>密码策略</category>
      </categories>
      <tags>
        <tag>密码策略</tag>
      </tags>
  </entry>
  <entry>
    <title>用CMD指令修改密码策略(1)</title>
    <url>/2019/07/05/%E5%AF%86%E7%A0%81%E7%AD%96%E7%95%A5/%E7%94%A8CMD%E6%8C%87%E4%BB%A4%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E7%AD%96%E7%95%A5-1/</url>
    <content><![CDATA[<h4 id="手动修改密码策略"><a href="#手动修改密码策略" class="headerlink" title="手动修改密码策略"></a>手动修改密码策略</h4><p>在运行框中输入 <code>secpol.msc</code> 可以打开 <code>本地安全设置</code> ，其中 <code>密码策略</code> 如图所示</p>
<p><img src="01.png" alt="密码策略"></p>
<h4 id="密码策略项的确认"><a href="#密码策略项的确认" class="headerlink" title="密码策略项的确认"></a>密码策略项的确认</h4><p>需要以管理员权限运行CMD控制台，然后运行如下指令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">secedit &#x2F;export &#x2F;cfg c:\1.inf &#x2F;log c:\1.log</span><br></pre></td></tr></table></figure>

<p>就可以把当前的 <code>本地安全设置</code> 导出到C盘根目录下的1.inf文件中。<br>这里只关注 <code>复杂性要求</code> 和 <code>最小长度</code> 两项，手动修改 <code>复杂性要求</code> 为启用，并设置 <code>最小长度</code> 为8</p>
<p><img src="02.png" alt="新密码策略"></p>
<p>然后再次使用指令导出当前的配置信息到2.inf中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">secedit &#x2F;export &#x2F;cfg c:\2.inf &#x2F;log c:\2.log</span><br></pre></td></tr></table></figure>

<p>如此，两个文件文件只有 <code>复杂性要求</code> 和 <code>最小长度</code> 发生了变化，使用文本比较工具可以看到</p>
<p><img src="03.png" alt="文本比较"></p>
<p>其中 <code>MinimumPasswordLength</code> 由0变成了8，对应的是 <code>密码长度最小值</code> 项，<br>而 <code>PasswordComplexity</code> 由0变成了1，对应的是 <code>密码必须符合复杂性要求</code> 项。</p>
<h4 id="用指令修改密码策略"><a href="#用指令修改密码策略" class="headerlink" title="用指令修改密码策略"></a>用指令修改密码策略</h4><p>在C盘根目录下创建3.inf配置文件，文件内容如下，其中数值可自行修改</p>
<p><img src="04.png" alt="配置文件"></p>
<p>其中 <code>[Version]</code> 字段和 <code>signature=”$CHICAGO$”</code> 条目必须保留，<br>在CMD控制台中输入如下指令，来设置3.inf配置文件中包含的配置信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">secedit &#x2F;configure &#x2F;cfg c:\3.inf &#x2F;db c:\3.db &#x2F;log c:\3.log</span><br></pre></td></tr></table></figure>

<p>执行完毕后如图所示，表示配置已完成，可以手动打开 <code>本地安全配置</code> 查看结果</p>
<p><img src="05.png" alt="设置结果"></p>
<h4 id="最后的结语"><a href="#最后的结语" class="headerlink" title="最后的结语"></a>最后的结语</h4><p>所有的导出和配置操作，都是通过 <code>secedit.exe</code> 来处理的，位于 <code>C:\Windows\System32</code> 目录下，<br>可以配置好inf文件，并使用 <code>CreateProcess</code> 或者 <code>ShellExecute</code> 等API嵌入到代码中执行。</p>
]]></content>
      <categories>
        <category>密码策略</category>
      </categories>
      <tags>
        <tag>密码策略</tag>
      </tags>
  </entry>
  <entry>
    <title>用NetUser函数修改密码策略(2)</title>
    <url>/2019/07/10/%E5%AF%86%E7%A0%81%E7%AD%96%E7%95%A5/%E7%94%A8NetUser%E5%87%BD%E6%95%B0%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E7%AD%96%E7%95%A5-2/</url>
    <content><![CDATA[<h4 id="用API查询和设置策略"><a href="#用API查询和设置策略" class="headerlink" title="用API查询和设置策略"></a>用API查询和设置策略</h4><p>前边提到了如何用 <code>secedit</code> 修改密码策略，在修改之前我们应该先查询一下当前的策略是什么，<br>不符合预期要求的再进行修改，以减少数据的写入次数。</p>
<p>经过搜索，发现可以使用 <code>NetUserModalsGet</code> 来查询密码策略，最后需要使用 <code>NetApiBufferFree</code> 来释放<br>查询到的数据空间。还可以使用 <code>NetUserModalsSet</code> 可以对密码策略进行设定。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NET_API_STATUS <span class="title">NetUserModalsGet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ LPCWSTR servername,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     DWORD   level,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_    LPBYTE  *bufptr</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 查询密码策略</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NET_API_STATUS <span class="title">NetApiBufferFree</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPVOID Buffer</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 释放查询的数据空间</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NET_API_STATUS <span class="title">NetUserModalsSet</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  LPCWSTR servername,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  DWORD   level,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  LPBYTE  buf,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_ LPDWORD parm_err</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 设定密码策略</span></span><br></pre></td></tr></table></figure>

<p>这两个函数中 <code>level</code> 参数决定了要处理数据的类型，可以取值的内容为</p>
<table>
<thead>
<tr>
<th align="left">Value</th>
<th>Meaning</th>
<th>Structure</th>
</tr>
</thead>
<tbody><tr>
<td align="left">0</td>
<td>Specifies global password parameters.</td>
<td>USER_MODALS_INFO_0</td>
</tr>
<tr>
<td align="left">1</td>
<td>Specifies logon server and domain controller information.</td>
<td>USER_MODALS_INFO_1</td>
</tr>
<tr>
<td align="left">2</td>
<td>Specifies the domain name and identifier.</td>
<td>USER_MODALS_INFO_2</td>
</tr>
<tr>
<td align="left">3</td>
<td>Specifies lockout information.</td>
<td>USER_MODALS_INFO_3</td>
</tr>
<tr>
<td align="left">1001</td>
<td>Specifies the minimum allowable password length.</td>
<td>USER_MODALS_INFO_1001</td>
</tr>
<tr>
<td align="left">1002</td>
<td>Specifies the maximum allowable password age.</td>
<td>USER_MODALS_INFO_1002</td>
</tr>
<tr>
<td align="left">1003</td>
<td>Specifies the minimum allowable password age.</td>
<td>USER_MODALS_INFO_1003</td>
</tr>
<tr>
<td align="left">1004</td>
<td>Specifies forced logoff information.</td>
<td>USER_MODALS_INFO_1004</td>
</tr>
<tr>
<td align="left">1005</td>
<td>Specifies the length of the password history.</td>
<td>USER_MODALS_INFO_1005</td>
</tr>
<tr>
<td align="left">1006</td>
<td>Specifies the role of the logon server.</td>
<td>USER_MODALS_INFO_1006</td>
</tr>
<tr>
<td align="left">1007</td>
<td>Specifies domain controller information.</td>
<td>USER_MODALS_INFO_1007</td>
</tr>
</tbody></table>
<p>如下是使用 <code>NetUserModalsGet</code> 查询时，我们关注的结构体信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USER_MODALS_INFO_0</span> &#123;</span></span><br><span class="line">  DWORD usrmod0_min_passwd_len; <span class="comment">// 密码长度最小值</span></span><br><span class="line">  DWORD usrmod0_max_passwd_age; <span class="comment">// 密码最长使用期限(秒)</span></span><br><span class="line">  DWORD usrmod0_min_passwd_age; <span class="comment">// 密码最短使用期限(秒)</span></span><br><span class="line">  DWORD usrmod0_force_logoff; <span class="comment">// 过期后强制注销的期限(秒)</span></span><br><span class="line">  DWORD usrmod0_password_hist_len; <span class="comment">// 强制密码历史个数</span></span><br><span class="line">&#125; USER_MODALS_INFO_0, *PUSER_MODALS_INFO_0, *LPUSER_MODALS_INFO_0;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USER_MODALS_INFO_3</span> &#123;</span></span><br><span class="line">  DWORD usrmod3_lockout_duration; <span class="comment">// 账户锁定时间(秒)</span></span><br><span class="line">  DWORD usrmod3_lockout_observation_window; <span class="comment">// 重置账户锁定计数器(秒)</span></span><br><span class="line">  DWORD usrmod3_lockout_threshold; <span class="comment">// 账户锁定阈值</span></span><br><span class="line">&#125; USER_MODALS_INFO_3, *PUSER_MODALS_INFO_3, *LPUSER_MODALS_INFO_3;</span><br></pre></td></tr></table></figure>

<p>使用 <code>NetUserModalsSet</code> 除了以上结构体进行整体设置外，还可以对部分参数进行单独设置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USER_MODALS_INFO_1001</span> &#123;</span></span><br><span class="line">  DWORD usrmod1001_min_passwd_len; <span class="comment">// 密码长度最小值</span></span><br><span class="line">&#125; USER_MODALS_INFO_1001, *PUSER_MODALS_INFO_1001, *LPUSER_MODALS_INFO_1001;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USER_MODALS_INFO_1002</span> &#123;</span></span><br><span class="line">  DWORD usrmod1002_max_passwd_age; <span class="comment">// 密码最长使用期限(秒)</span></span><br><span class="line">&#125; USER_MODALS_INFO_1002, *PUSER_MODALS_INFO_1002, *LPUSER_MODALS_INFO_1002;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USER_MODALS_INFO_1003</span> &#123;</span></span><br><span class="line">  DWORD usrmod1003_min_passwd_age; <span class="comment">// 密码最短使用期限(秒)</span></span><br><span class="line">&#125; USER_MODALS_INFO_1003, *PUSER_MODALS_INFO_1003, *LPUSER_MODALS_INFO_1003;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USER_MODALS_INFO_1004</span> &#123;</span></span><br><span class="line">  DWORD usrmod1004_force_logoff; <span class="comment">// 过期后强制注销的期限(秒)</span></span><br><span class="line">&#125; USER_MODALS_INFO_1004, *PUSER_MODALS_INFO_1004, *LPUSER_MODALS_INFO_1004;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">USER_MODALS_INFO_1005</span> &#123;</span></span><br><span class="line">  DWORD usrmod1005_password_hist_len; <span class="comment">// 强制密码历史个数</span></span><br><span class="line">&#125; USER_MODALS_INFO_1005, *PUSER_MODALS_INFO_1005, *LPUSER_MODALS_INFO_1005;</span><br></pre></td></tr></table></figure>

<h4 id="密码复杂度的处理"><a href="#密码复杂度的处理" class="headerlink" title="密码复杂度的处理"></a>密码复杂度的处理</h4><p>看到这里是不是发现一个问题，那就是 <code>密码必须符合复杂性要求</code> 这项配置，查询不到。<br>我们可以通过直接读取 <code>SAM</code> 注册表的信息，来判断密码复杂度是否启用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckPwdComplexPolicy</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HKEY hKey = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 打开密码策略注册表</span></span><br><span class="line">    LONG lResult = RegOpenKeyEx(HKEY_LOCAL_MACHINE,</span><br><span class="line">        <span class="string">&quot;SAM\\SAM\\Domains\\Account&quot;</span>, <span class="number">0</span>, KEY_ALL_ACCESS, &amp;hKey);</span><br><span class="line">    <span class="keyword">if</span> (lResult != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 读取密码策略注册表信息</span></span><br><span class="line">    DWORD dwLen = <span class="number">1024</span>;</span><br><span class="line">    BYTE pBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    lResult = RegQueryValueEx(hKey, <span class="string">&quot;F&quot;</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, pBuf, &amp;dwLen);</span><br><span class="line">    RegCloseKey(hKey);</span><br><span class="line">    <span class="keyword">if</span> (lResult != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 检查密码复杂度是否启用</span></span><br><span class="line">    <span class="keyword">if</span> (pBuf[<span class="number">76</span>] != <span class="number">1</span>) <span class="keyword">return</span> FALSE; <span class="comment">// 复杂度(0未启用)(1已启用)</span></span><br><span class="line">    <span class="comment">// if (pBuf[80] &lt; 8) return FALSE; // 最小长度</span></span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>普通情况下 <code>SAM</code> 注册表是不允许访问的，就需要我们首先修改一下访问 <code>SAM</code> 的权限</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">ModifySamRegPrivilege</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PACL pOldDacl = <span class="literal">NULL</span>;</span><br><span class="line">    PSECURITY_DESCRIPTOR pSID = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 获取SAM主键的DACL</span></span><br><span class="line">    DWORD dRet = GetNamedSecurityInfo(<span class="string">&quot;MACHINE\\SAM\\SAM&quot;</span>,</span><br><span class="line">        SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;pOldDacl, <span class="literal">NULL</span>, &amp;pSID);</span><br><span class="line">    <span class="keyword">if</span> (dRet != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        LocalFree(pSID);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建一个ACE,允许Administrators组成员完全控制对象,并允许子对象继承此权限</span></span><br><span class="line">    EXPLICIT_ACCESS_A eia = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    BuildExplicitAccessWithName(&amp;eia, <span class="string">&quot;Administrators&quot;</span>,</span><br><span class="line">        KEY_ALL_ACCESS, SET_ACCESS, SUB_CONTAINERS_AND_OBJECTS_INHERIT);</span><br><span class="line">    <span class="comment">// 将新的ACE加入DACL</span></span><br><span class="line">    PACL pNewDacl = <span class="literal">NULL</span>;</span><br><span class="line">    dRet = SetEntriesInAcl(<span class="number">1</span>, &amp;eia, pOldDacl, &amp;pNewDacl);</span><br><span class="line">    <span class="keyword">if</span> (dRet != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        LocalFree(pSID);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新SAM主键的DACL   </span></span><br><span class="line">    dRet = SetNamedSecurityInfo(<span class="string">&quot;MACHINE\\SAM\\SAM&quot;</span>,</span><br><span class="line">        SE_REGISTRY_KEY, DACL_SECURITY_INFORMATION, <span class="literal">NULL</span>, <span class="literal">NULL</span>, pNewDacl, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (dRet != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        LocalFree(pNewDacl);</span><br><span class="line">        LocalFree(pSID);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>密码策略</category>
      </categories>
      <tags>
        <tag>密码策略</tag>
      </tags>
  </entry>
  <entry>
    <title>用SAM函数修改密码策略(3)</title>
    <url>/2019/07/16/%E5%AF%86%E7%A0%81%E7%AD%96%E7%95%A5/%E7%94%A8SAM%E5%87%BD%E6%95%B0%E4%BF%AE%E6%94%B9%E5%AF%86%E7%A0%81%E7%AD%96%E7%95%A5-3/</url>
    <content><![CDATA[<h4 id="使用SAM功能获取策略"><a href="#使用SAM功能获取策略" class="headerlink" title="使用SAM功能获取策略"></a>使用SAM功能获取策略</h4><p>看到这里，设置 <code>密码复杂度</code> 策略仍然需要使用inf配置文件，那有没有不借助于inf文件的办法？</p>
<p>使用IDA逆向XP系统中的 <code>netapi32.dll</code> 模块，查看 <code>NetUserModuleGet</code> 和 <code>NetUserModuleSet</code> 函数，<br>可以看到引用了一系列的以Sam开头的函数，然后找到这些Sam开头的函数是在 <code>samlib.dll</code> 导出的。</p>
<p>经过搜索，在 <code>WDK7.1</code> 开发包中，找到了 <code>ntsam.h</code> 头文件和 <code>samlib.lib</code> 库文件。然后在密码破解<br>神器 <code>mimikatz</code> 工具的源码中，也找到了相关的 <code>kull_m_samlib.h</code> 和 <code>samlib.lib</code> 文件。</p>
<p>最后再对照着 <code>ReactOS</code> 的源码，找其中一些共通之处，发现密码策略涉及到的结构体为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DOMAIN_PASSWORD_INFORMATION</span> &#123;</span></span><br><span class="line">    USHORT MinPasswordLength; <span class="comment">// 密码最小长度</span></span><br><span class="line">    USHORT PasswordHistoryLength; <span class="comment">// 密码历史记录个数</span></span><br><span class="line">    ULONG PasswordProperties; <span class="comment">// 密码规则，包含密码复杂度</span></span><br><span class="line">    LARGE_INTEGER MaxPasswordAge; <span class="comment">// 最大密码过期期限</span></span><br><span class="line">    LARGE_INTEGER MinPasswordAge; <span class="comment">// 最小密码过期期限</span></span><br><span class="line">&#125; DOMAIN_PASSWORD_INFORMATION, *PDOMAIN_PASSWORD_INFORMATION;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 密码规则 PasswordProperties 对应的标志</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOMAIN_PASSWORD_COMPLEX             0x00000001L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOMAIN_PASSWORD_NO_ANON_CHANGE      0x00000002L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOMAIN_PASSWORD_NO_CLEAR_CHANGE     0x00000004L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOMAIN_LOCKOUT_ADMINS               0x00000008L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOMAIN_PASSWORD_STORE_CLEARTEXT     0x00000010L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DOMAIN_REFUSE_PASSWORD_CHANGE       0x00000020L</span></span><br></pre></td></tr></table></figure>

<p>可以看到使用Sam功能可以获取到 <code>密码复杂度</code> 策略，是在输出到外部时被忽略掉了。</p>
<p>在 <code>WDK7.1</code> 中的 <code>ntsam.h</code> 文件无法直接使用，我们拷出来进行改造，主要是增加函数 <code>NTAPI</code> 声明，比如</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SamFreeMemory</span><span class="params">(__in PVOID Buffer)</span></span>; <span class="comment">// 原始的函数声明</span></span><br><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">SamFreeMemory</span><span class="params">(__in PVOID Buffer)</span></span>; <span class="comment">// 修改以后的函数声明</span></span><br></pre></td></tr></table></figure>

<h4 id="整合数据声明的头文件"><a href="#整合数据声明的头文件" class="headerlink" title="整合数据声明的头文件"></a>整合数据声明的头文件</h4><p>我们这里把相关功能整理到单独的h和cpp文件中，新建头文件然后补充一些相关的定义，如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NT_SUCCESS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NT_SUCCESS(x) ((NTSTATUS)(x) &gt;= 0)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> STRING OEM_STRING;</span><br><span class="line"><span class="keyword">typedef</span> PSTRING POEM_STRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OBJECT_ATTRIBUTES</span> &#123;</span></span><br><span class="line">    ULONG Length;</span><br><span class="line">    HANDLE RootDirectory;</span><br><span class="line">    PUNICODE_STRING ObjectName;</span><br><span class="line">    ULONG Attributes;</span><br><span class="line">    PVOID SecurityDescriptor;</span><br><span class="line">    PVOID SecurityQualityOfService;</span><br><span class="line">&#125; OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntsecapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;ntsam.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;advapi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;samlib.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ntdll.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> NTSYSAPI</span><br><span class="line">LARGE_INTEGER NTAPI</span><br><span class="line">RtlExtendedMagicDivide(</span><br><span class="line">__in LARGE_INTEGER Dividend,</span><br><span class="line">__in LARGE_INTEGER MagicDivisor,</span><br><span class="line">__in CCHAR ShiftCount);</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> NTSYSAPI</span><br><span class="line">LARGE_INTEGER NTAPI</span><br><span class="line">RtlExtendedIntegerMultiply(</span><br><span class="line">__in LARGE_INTEGER Multiplicand,</span><br><span class="line">__in LONG Multiplier</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DOMAINPWD_INFO</span> &#123;</span></span><br><span class="line">    DWORD pwd_prop; <span class="comment">// 复杂度(位标志)</span></span><br><span class="line">    WORD min_len; <span class="comment">// 最小长度</span></span><br><span class="line">    DWORD max_age; <span class="comment">// 最长期限(秒)</span></span><br><span class="line">    DWORD min_age; <span class="comment">// 最短期限(秒)</span></span><br><span class="line">    WORD hist_len; <span class="comment">// 历史数量</span></span><br><span class="line">&#125; DOMAINPWD_INFO, *PDOMAINPWD_INFO;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 密码策略</span></span><br><span class="line"><span class="function">BOOL <span class="title">GetDomainPasswordInfo</span><span class="params">(DOMAINPWD_INFO &amp;stInfo)</span></span>;</span><br><span class="line"><span class="function">BOOL <span class="title">SetDomainPasswordInfo</span><span class="params">(DOMAINPWD_INFO &amp;stInfo)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中 <code>RtlExtendedMagicDivide</code> 和 <code>RtlExtendedIntegerMultiply</code> 函数是在 <code>ntdll.dll</code> 中导出的，<br>同样在 <code>WDK7.1</code> 中可以找到 <code>ntdll.lib</code> 库文件。这两个函数的作用，主要是查询完密码策略后，<br>进行数据转换计算用，其功能是把64位数扩展到128位数进行乘除操作。</p>
<h4 id="整合函数的代码文件"><a href="#整合函数的代码文件" class="headerlink" title="整合函数的代码文件"></a>整合函数的代码文件</h4><p>使用Sam功能查询到的策略信息，其中时间相关的数据均为 <code>DeltaTime</code> 时间，需要转换成 <code>Seconds</code> 秒数，<br>如下为 <code>DeltaTime</code> 与 <code>Seconds</code> 之间的转换函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">DeltaTimeToSeconds</span><span class="params">(LARGE_INTEGER &amp;Dividend)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD result = <span class="number">0</span>;</span><br><span class="line">    LARGE_INTEGER Seconds = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    LARGE_INTEGER MagicDivisor = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (Dividend.QuadPart != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        MagicDivisor.QuadPart = <span class="number">0xD6BF94D5E57A42BD</span>L;</span><br><span class="line">        Seconds = RtlExtendedMagicDivide(Dividend, MagicDivisor, <span class="number">23</span>);</span><br><span class="line">        <span class="keyword">if</span> (Seconds.HighPart == <span class="number">0xFFFFFFFF</span>)</span><br><span class="line">            result = -(<span class="keyword">int</span>)Seconds.LowPart;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            result = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LARGE_INTEGER <span class="title">SecondsToDeltaTime</span><span class="params">(DWORD Seconds)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LARGE_INTEGER result = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    LARGE_INTEGER DeltaTime = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    LARGE_INTEGER Multiplicand = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (Seconds != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        result.HighPart = <span class="number">0x80000000</span>;</span><br><span class="line">        <span class="keyword">if</span> (Seconds == <span class="number">0xFFFFFFFF</span>) <span class="keyword">return</span> result;</span><br><span class="line">        Multiplicand.QuadPart = Seconds;</span><br><span class="line">        DeltaTime = RtlExtendedIntegerMultiply(Multiplicand, <span class="number">10000000</span>);</span><br><span class="line">        <span class="keyword">if</span> (DeltaTime.QuadPart &lt; <span class="number">0</span>) <span class="keyword">return</span> result;</span><br><span class="line">        DeltaTime.QuadPart = -DeltaTime.QuadPart;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DeltaTime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在读取密码策略之前，我们还需要获取账户所在域的SID信息，用IDA逆向时是使用Sam函数获取的，<br>但是这个信息还可以用其他方式获取到，在 <code>ReactOS</code> 和 <code>mimikatz</code> 中就是使用的 <code>LSA</code> 函数进行查询的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">GetAccountDomainSid</span><span class="params">(PSID *DomainSid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 打开LSA本地策略</span></span><br><span class="line">    LSA_HANDLE hPolicy = <span class="literal">NULL</span>;</span><br><span class="line">    LSA_OBJECT_ATTRIBUTES ObjAttrib = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS Status = LsaOpenPolicy(<span class="literal">NULL</span>, &amp;ObjAttrib, POLICY_VIEW_LOCAL_INFORMATION, &amp;hPolicy);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">return</span> Status;</span><br><span class="line">    <span class="comment">// 查询本地账户域信息</span></span><br><span class="line">    PPOLICY_ACCOUNT_DOMAIN_INFO DomainInfo = <span class="literal">NULL</span>;</span><br><span class="line">    Status = LsaQueryInformationPolicy(hPolicy, PolicyAccountDomainInformation, (PVOID*)&amp;DomainInfo);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        LsaClose(hPolicy);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取域SID信息</span></span><br><span class="line">    ULONG Length = GetLengthSid(DomainInfo-&gt;DomainSid);</span><br><span class="line">    *DomainSid = HeapAlloc(GetProcessHeap(), <span class="number">0</span>, Length);</span><br><span class="line">    <span class="keyword">if</span> (*DomainSid == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        LsaFreeMemory(DomainInfo);</span><br><span class="line">        LsaClose(hPolicy);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0xC000009A</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 复制到输出参数</span></span><br><span class="line">    <span class="built_in">memcpy</span>(*DomainSid, DomainInfo-&gt;DomainSid, Length);</span><br><span class="line">    LsaFreeMemory(DomainInfo);</span><br><span class="line">    LsaClose(hPolicy);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所有的准备工作都已完毕，如下为 <code>查询密码策略信息</code> 和 <code>设置密码策略信息</code> 的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetDomainPasswordInfo</span><span class="params">(DOMAINPWD_INFO &amp;stInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bRetrun = FALSE;</span><br><span class="line">    PSID DomainSid = <span class="literal">NULL</span>;</span><br><span class="line">    ACCESS_MASK DesiredAccess = <span class="number">0</span>;</span><br><span class="line">    SAM_HANDLE ServerHandle = <span class="literal">NULL</span>;</span><br><span class="line">    SAM_HANDLE DomainHandle = <span class="literal">NULL</span>;</span><br><span class="line">    PDOMAIN_PASSWORD_INFORMATION PasswdInfo = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 连接本机SAM服务器</span></span><br><span class="line">        NTSTATUS Status = SamConnect(<span class="literal">NULL</span>, &amp;ServerHandle, SAM_SERVER_LOOKUP_DOMAIN, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 获取账户的域SID</span></span><br><span class="line">        Status = GetAccountDomainSid(&amp;DomainSid);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 打开本机SAM服务器中对应的域</span></span><br><span class="line">        SAM_HANDLE DomainHandle = <span class="literal">NULL</span>;</span><br><span class="line">        DesiredAccess = DOMAIN_READ_OTHER_PARAMETERS | DOMAIN_READ_PASSWORD_PARAMETERS;</span><br><span class="line">        Status = SamOpenDomain(ServerHandle, DesiredAccess, DomainSid, &amp;DomainHandle);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 查询域中的密码信息</span></span><br><span class="line">        Status = SamQueryInformationDomain(DomainHandle, DomainPasswordInformation, (PVOID*)&amp;PasswdInfo);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 转换对应信息</span></span><br><span class="line">        stInfo.pwd_prop = PasswdInfo-&gt;PasswordProperties;</span><br><span class="line">        stInfo.min_len = PasswdInfo-&gt;MinPasswordLength;</span><br><span class="line">        stInfo.max_age = DeltaTimeToSeconds(PasswdInfo-&gt;MaxPasswordAge);</span><br><span class="line">        <span class="comment">// 最大期限策略为0时，实际的数据为0xFFFFFFFF</span></span><br><span class="line">        <span class="keyword">if</span> (stInfo.max_age == <span class="number">0xFFFFFFFF</span>) stInfo.max_age = <span class="number">0</span>;</span><br><span class="line">        stInfo.min_age = DeltaTimeToSeconds(PasswdInfo-&gt;MinPasswordAge);</span><br><span class="line">        stInfo.hist_len = PasswdInfo-&gt;PasswordHistoryLength;</span><br><span class="line">        bRetrun = TRUE;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 释放申请的内存</span></span><br><span class="line">    <span class="keyword">if</span> (PasswdInfo != <span class="literal">NULL</span>) SamFreeMemory(PasswdInfo);</span><br><span class="line">    <span class="keyword">if</span> (DomainSid != <span class="literal">NULL</span>) HeapFree(GetProcessHeap(), <span class="number">0</span>, DomainSid);</span><br><span class="line">    <span class="keyword">if</span> (DomainHandle != <span class="literal">NULL</span>) SamCloseHandle(DomainHandle);</span><br><span class="line">    <span class="keyword">if</span> (ServerHandle != <span class="literal">NULL</span>) SamCloseHandle(ServerHandle);</span><br><span class="line">    <span class="keyword">return</span> bRetrun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SetDomainPasswordInfo</span><span class="params">(DOMAINPWD_INFO &amp;stInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bRetrun = FALSE;</span><br><span class="line">    PSID DomainSid = <span class="literal">NULL</span>;</span><br><span class="line">    ACCESS_MASK DesiredAccess = <span class="number">0</span>;</span><br><span class="line">    SAM_HANDLE ServerHandle = <span class="literal">NULL</span>;</span><br><span class="line">    SAM_HANDLE DomainHandle = <span class="literal">NULL</span>;</span><br><span class="line">    DOMAIN_PASSWORD_INFORMATION PasswdInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 连接本机SAM服务器</span></span><br><span class="line">        NTSTATUS Status = SamConnect(<span class="literal">NULL</span>, &amp;ServerHandle, SAM_SERVER_LOOKUP_DOMAIN, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 获取账户的域SID</span></span><br><span class="line">        Status = GetAccountDomainSid(&amp;DomainSid);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 打开本机SAM服务器中对应的域</span></span><br><span class="line">        SAM_HANDLE DomainHandle = <span class="literal">NULL</span>;</span><br><span class="line">        DesiredAccess = DOMAIN_WRITE_OTHER_PARAMETERS | DOMAIN_WRITE_PASSWORD_PARAMS;</span><br><span class="line">        Status = SamOpenDomain(ServerHandle, DesiredAccess, DomainSid, &amp;DomainHandle);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 转换对应信息</span></span><br><span class="line">        PasswdInfo.PasswordProperties = stInfo.pwd_prop;</span><br><span class="line">        PasswdInfo.MinPasswordLength = stInfo.min_len;</span><br><span class="line">        <span class="comment">// 最大期限策略为0时，实际的数据为0xFFFFFFFF</span></span><br><span class="line">        <span class="keyword">if</span> (stInfo.max_age == <span class="number">0</span>) stInfo.max_age = <span class="number">0xFFFFFFFF</span>;</span><br><span class="line">        PasswdInfo.MaxPasswordAge = SecondsToDeltaTime(stInfo.max_age);</span><br><span class="line">        PasswdInfo.MinPasswordAge = SecondsToDeltaTime(stInfo.min_age);</span><br><span class="line">        PasswdInfo.PasswordHistoryLength = stInfo.hist_len;</span><br><span class="line">        <span class="comment">// 设置域中的密码信息</span></span><br><span class="line">        Status = SamSetInformationDomain(DomainHandle, DomainPasswordInformation, &amp;PasswdInfo);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        bRetrun = TRUE;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 释放申请的内存</span></span><br><span class="line">    <span class="keyword">if</span> (DomainSid != <span class="literal">NULL</span>) HeapFree(GetProcessHeap(), <span class="number">0</span>, DomainSid);</span><br><span class="line">    <span class="keyword">if</span> (DomainHandle != <span class="literal">NULL</span>) SamCloseHandle(DomainHandle);</span><br><span class="line">    <span class="keyword">if</span> (ServerHandle != <span class="literal">NULL</span>) SamCloseHandle(ServerHandle);</span><br><span class="line">    <span class="keyword">return</span> bRetrun;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于 <code>密码复杂度</code> 是按标志位进行检测，虽然一般情况下其他的标志位都为0，但是保险起见，<br>尽量先查询当前的信息，然后和标志位进行 <code>按位或</code> 的操作，再设置回去。</p>
]]></content>
      <categories>
        <category>密码策略</category>
      </categories>
      <tags>
        <tag>密码策略</tag>
      </tags>
  </entry>
  <entry>
    <title>使用InlineHook实现进程保护(3)</title>
    <url>/2019/08/02/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E4%BD%BF%E7%94%A8InlineHook%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%8A%A4-3/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>关于 <code>INLINEHOOK</code> 的技术，既可以用于驱动，又可以用于应用层，其原理本质上是汇编指令替换。<br>因为应用层进程之间内存空间有隔离，所以要想HOOK函数，需要先注入模块到目标进程中。</p>
<h4 id="INLINEHOOK的原理"><a href="#INLINEHOOK的原理" class="headerlink" title="INLINEHOOK的原理"></a>INLINEHOOK的原理</h4><p>操作系统中的函数的开头多数是固定格式，这里以 <code>NtTerminateProcess</code> 为例，查看汇编指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nt!NtTerminateProcess:</span><br><span class="line"><span class="number">805</span>d399e <span class="number">8b</span>ff            mov     edi,edi</span><br><span class="line"><span class="number">805</span>d39a0 <span class="number">55</span>              push    ebp</span><br><span class="line"><span class="number">805</span>d39a1 <span class="number">8b</span>ec            mov     ebp,esp</span><br><span class="line"><span class="number">805</span>d39a3 <span class="number">83</span>ec10          sub     esp,<span class="number">10</span>h</span><br><span class="line"><span class="number">805</span>d39a6 <span class="number">53</span>              push    ebx</span><br></pre></td></tr></table></figure>

<p>可以看到前3条指令合起来占用5个字节的机器码，我们使用无条件跳转指令来替换它们，从而调用这个<br>函数时首先跳转到我们自定义的函数中，处理完毕后再跳转回来。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_asm jmp MyNtTerminateProcess;</span><br><span class="line"><span class="number">00e1143</span>e e9e5fbffff      jmp     <span class="number">00e11028</span></span><br></pre></td></tr></table></figure>

<p>以上机器码 <code>E9</code> 表示 <code>JMP</code> 指令，后边4个字节为跳转的偏移 <code>0xFFFFFBE5</code>，这里可以计算一下，<br>指令地址为 <code>0x00E1143E</code> 目标地址为 <code>0x00E11028</code>，属于往前跳，所以跳转偏移是个负数，转换完并<br>求绝对值为 <code>0x41B</code>，这里 <code>0x00E1143E - 0x41B = 0x00E11023</code> 并不是 <code>0x00E11028</code>，是因为跳转<br>指令本身占了 <code>5</code> 个字节，CPU是从执行完指令之后的地址开始算的。</p>
<p>所以我们在替换 <code>NtTerminateProcess</code> 函数首 <code>5</code> 个字节时，可以使用如下公式计算跳转偏移</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">跳转偏移 = 目标地址(自定义函数地址) - 指令地址(原函数地址) - <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p>注意在我们自定义的函数执行完毕后，如果还需要执行原函数，需要先运行替换的原5个字节指令，<br>再跳转回原函数中。获取 <code>NtTerminateProcess</code> 函数地址的方法这里不再专门说明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ULONG NtTerminateProcessNextCodeAddr = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">__declspec(naked) <span class="function"><span class="keyword">void</span> <span class="title">NakeNtTerminateProcess</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _asm &#123;</span><br><span class="line">        mov eax, [esp + <span class="number">8</span>];</span><br><span class="line">        push eax;</span><br><span class="line">        mov eax, [esp + <span class="number">8</span>];</span><br><span class="line">        push eax;</span><br><span class="line">        call ProxyNtTerminateProcess;</span><br><span class="line">        add esp, <span class="number">8</span>;</span><br><span class="line">        test eax, eax;</span><br><span class="line">        je oricode;</span><br><span class="line">        ret;</span><br><span class="line">    oricode:</span><br><span class="line">        nop;</span><br><span class="line">        nop;</span><br><span class="line">        nop;</span><br><span class="line">        nop;</span><br><span class="line">        nop;</span><br><span class="line">        jmp NtTerminateProcessNextCodeAddr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ProxyNtTerminateProcess</span><span class="params">(HANDLE ProcessHandle, NTSTATUS ExitStatus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检查参数</span></span><br><span class="line">        <span class="keyword">if</span> (ProcessHandle == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ProcessHandle == (HANDLE)<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 本次操作对应的进程</span></span><br><span class="line">        PsGetCurrentProcessId();</span><br><span class="line">        <span class="comment">// 使用ZwQueryInformationProcess查询进程名</span></span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">            <span class="keyword">return</span> STATUS_ACCESS_DENIED; <span class="comment">// 拦截操作</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 返回成功跳转回原函数</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下为HOOK操作函数，如果要卸载HOOK就是把替换的5个字节指令恢复回去，这里不再专门说明。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 函数NakeNtTerminateProcess对应的机器码</span></span><br><span class="line"><span class="number">00</span>D613D0 <span class="number">8B</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>          mov     eax,dword ptr [esp+<span class="number">8</span>]</span><br><span class="line"><span class="number">00</span>D613D4 <span class="number">50</span>                   push    eax</span><br><span class="line"><span class="number">00</span>D613D5 <span class="number">8B</span> <span class="number">44</span> <span class="number">24</span> <span class="number">08</span>          mov     eax,dword ptr [esp+<span class="number">8</span>]</span><br><span class="line"><span class="number">00</span>D613D9 <span class="number">50</span>                   push    eax</span><br><span class="line"><span class="number">00</span>D613DA E8 <span class="number">39</span> <span class="function">FD FF FF       call    <span class="title">ProxyNtTerminateProcess</span> <span class="params">(<span class="number">0</span>D61118h)</span></span></span><br><span class="line">00D613DF 83 C4 08             add     esp,8</span><br><span class="line"><span class="number">00</span>D613E2 <span class="number">85</span> C0                test    eax,eax</span><br><span class="line"><span class="number">00</span>D613E4 <span class="number">74</span> <span class="number">01</span>                <span class="function">je      <span class="title">oricode</span> <span class="params">(<span class="number">0</span>D613E7h)</span></span></span><br><span class="line"><span class="function">00D613E6 C3                   ret</span></span><br><span class="line"><span class="function">oricode:</span></span><br><span class="line"><span class="function">00D613E7 90                   nop</span></span><br><span class="line"><span class="function">00D613E8 90                   nop</span></span><br><span class="line"><span class="function">00D613E9 90                   nop</span></span><br><span class="line"><span class="function">00D613EA 90                   nop</span></span><br><span class="line"><span class="function">00D613EB 90                   nop</span></span><br><span class="line">00D613EC FF 25 30 81 D6 00    jmp     dword ptr ds:[0D68130h]</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InlineHook</span><span class="params">(IN PVOID FuncAddr, IN PVOID NakeAddr, OUT PULONG NextCodeAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 指令NOP地址为23个字节的偏移</span></span><br><span class="line">    PULONG NopAddr = (PULONG)((ULONG)NakeAddr + <span class="number">23</span>);</span><br><span class="line">    <span class="keyword">if</span> (*NopAddr != <span class="number">0x90909090</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 保存返回地址</span></span><br><span class="line">    *NextCodeAddr = (ULONG)FuncAddr + <span class="number">5</span>;</span><br><span class="line">    WPOff(); <span class="comment">// 关闭内存写保护</span></span><br><span class="line">    <span class="comment">// 保存原代码</span></span><br><span class="line">    *(PUCHAR)NopAddr = *(PUCHAR)FuncAddr;</span><br><span class="line">    *(PULONG)((PUCHAR)NopAddr + <span class="number">1</span>) = *(PULONG)((PUCHAR)FuncAddr + <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 写入跳转指令</span></span><br><span class="line">    *(PUCHAR)FuncAddr = <span class="number">0xE9</span>;</span><br><span class="line">    *(PULONG)((PUCHAR)FuncAddr + <span class="number">1</span>) = (ULONG)NakeAddr - (ULONG)FuncAddr - <span class="number">5</span>;</span><br><span class="line">    WPOn(); <span class="comment">// 打开内存写保护</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有些情况下，要HOOK的函数开头不是正好5个字节的指令，就需要我们内置一个反汇编引擎，反汇编<br>目标函数，至少找到5个字节的空间。比如7个字节的指令，仍然是相同的操作，先保存这7个字节的指令<br>到 <code>Nake函数</code> 预置的 <code>0x90</code> 中，然后保存下一条指令的地址，最后写入跳转指令，多余的空间写入 <code>0x90</code></p>
<p>可以使用开源的minhook引擎：<a href="https://github.com/TsudaKageyu/minhook">https://github.com/TsudaKageyu/minhook</a></p>
]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>使用MiniFilter与应用层通讯(1)</title>
    <url>/2020/01/10/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E4%BD%BF%E7%94%A8MiniFilter%E4%B8%8E%E5%BA%94%E7%94%A8%E5%B1%82%E9%80%9A%E8%AE%AF-1/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>通常情况下驱动想要主动与应用层通讯，都是借助于内核同步对象（比如事件、信号量等）来实现，<br>但是使用内核同步对象对 <code>IRQL</code> 有限制，某些特殊环境下是 <code>APC_LEVEL</code> 级别，这就产生了一些问题。</p>
<h4 id="内核同步对象"><a href="#内核同步对象" class="headerlink" title="内核同步对象"></a>内核同步对象</h4><p>我们以内核同步对象中的 <code>事件(Event)</code> 为例，可以在MSDN文档中查看 <code>ZwSetEvent</code> 和 <code>KeSetEvent</code><br>的相关说明，其中 <code>ZwSetEvent</code> 只能运行在 <code>PASSIVE_LEVEL</code> 级别下，而 <code>KeSetEvent</code> 则是说明如下</p>
<p><img src="01.png" alt="KeSetEvent"></p>
<p>可以知道 <code>KeSetEvent</code> 适应的范围更广，由于 <code>KeSetEvent</code> 操作的不是句柄，把内核中的事件跟应用层<br>关联起来的方法，就是使用 <code>IoCreateNotificationEvent</code> 和 <code>IoCreateSynchronizationEvent</code> 来<br>创建跟应用层 <code>相同名称</code> 的事件，可以获取到对应的句柄和内核对象。</p>
<p>注意：先从应用层创建，再从内核层打开，两者具有相同权限。如果先从内核层创建，再从应用层打开，<br>应用层只能 <code>WaitForSingleObject</code> 而没有修改的权限。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PKEVENT <span class="title">IoCreateNotificationEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   PUNICODE_STRING EventName,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  PHANDLE EventHandle</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 创建或打开手动复位的命名事件</span></span><br><span class="line"></span><br><span class="line"><span class="function">PKEVENT <span class="title">IoCreateSynchronizationEvent</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  PUNICODE_STRING EventName,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_ PHANDLE         EventHandle</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 创建或打开自动复位的命名事件</span></span><br></pre></td></tr></table></figure>

<h4 id="MiniFilter通讯端口"><a href="#MiniFilter通讯端口" class="headerlink" title="MiniFilter通讯端口"></a>MiniFilter通讯端口</h4><p>MiniFilter跟应用层通讯，可以在 <code>APC_LEVEL</code> 级别下进行，某些情况下可以选择此通讯方式。<br>本例子以WDK源码中 <code>src -&gt; filesys -&gt; miniFilter -&gt; minispy</code> 工程作为基础。<br>创建驱动与应用层通讯的端口，需要安全描述符，如下为相关创建和释放的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">FltBuildDefaultSecurityDescriptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_  PSECURITY_DESCRIPTOR *SecurityDescriptor,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_   ACCESS_MASK DesiredAccess</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 创建描述权限的安全描述符</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FltFreeSecurityDescriptor</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ PSECURITY_DESCRIPTOR SecurityDescriptor</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 释放安全描述符内存</span></span><br></pre></td></tr></table></figure>

<p>创建好安全描述符后，就可以使用描述符创建和关闭通讯端口</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">FltCreateCommunicationPort</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      PFLT_FILTER Filter,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_     PFLT_PORT *ServerPort,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      POBJECT_ATTRIBUTES ObjectAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  PVOID ServerPortCookie,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      PFLT_CONNECT_NOTIFY ConnectNotifyCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      PFLT_DISCONNECT_NOTIFY DisconnectNotifyCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  PFLT_MESSAGE_NOTIFY MessageNotifyCallback,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      LONG MaxConnections</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 创建通讯端口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FltCloseCommunicationPort</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ PFLT_PORT ServerPort</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 关闭通讯端口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FltCloseClientPort</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  PFLT_FILTER Filter,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_ PFLT_PORT   *ClientPort</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 关闭客户端通讯</span></span><br></pre></td></tr></table></figure>

<p>当应用层连接驱动的通讯端口时，就会触发 <code>ConnectNotifyCallback</code> 回调，在这里我们要保存<br> <code>ClientPort</code> 信息，给驱动主动往应用层发送数据时用。当应用层关闭与驱动连接的通讯时，就会<br>触发 <code>DisconnectNotifyCallback</code> 回调，这里我们要使用 <code>FltCloseClientPort</code> 关闭 <code>ClientPort</code>，<br>当应用层主动向驱动发送数据时，就会触发 <code>MessageNotifyCallback</code> 回调，我们在这里进行数据操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">PFLT_FILTER FilterHandle = <span class="literal">NULL</span>; <span class="comment">// 过滤器句柄</span></span><br><span class="line">PFLT_PORT FilterServerPort = <span class="literal">NULL</span>; <span class="comment">// 驱动端口</span></span><br><span class="line">PFLT_PORT FilterClientPort = <span class="literal">NULL</span>; <span class="comment">// 应用端口</span></span><br></pre></td></tr></table></figure>

<p>如下为连接驱动通讯端口时 <code>ConnectNotifyCallback</code> 回调函数的处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ConnectCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PFLT_PORT ClientPort,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID ServerPortCookie,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID ConnectionContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG SizeOfContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PVOID *ConnectionPortCookie)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(ServerPortCookie);</span><br><span class="line">    UNREFERENCED_PARAMETER(ConnectionContext);</span><br><span class="line">    UNREFERENCED_PARAMETER(SizeOfContext);</span><br><span class="line">    UNREFERENCED_PARAMETER(ConnectionPortCookie);</span><br><span class="line">    FilterClientPort = ClientPort;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下为关闭与驱动连接的通讯时 <code>DisconnectNotifyCallback</code> 回调函数的处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DisconnectCallback</span><span class="params">(IN PVOID ConnectionCookie)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(ConnectionCookie);</span><br><span class="line">    FltCloseClientPort(FilterHandle, &amp;FilterClientPort);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下为主动向驱动发送数据时 <code>MessageNotifyCallback</code> 回调函数的处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MessageCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID PortCookie,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID InputBuffer OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG InputBufferLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PVOID OutputBuffer OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG OutputBufferLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PULONG ReturnOutputBufferLength)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UCHAR Command = <span class="number">0</span>;</span><br><span class="line">    UNREFERENCED_PARAMETER(PortCookie);</span><br><span class="line">    <span class="comment">// 检查输入缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> ((InputBuffer == <span class="literal">NULL</span>) || (InputBufferLength != <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">    <span class="comment">// 检查输出缓冲区</span></span><br><span class="line">    <span class="keyword">if</span> ((OutputBuffer == <span class="literal">NULL</span>) || (OutputBufferLength != <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">    <span class="comment">// 检查实际大小指针</span></span><br><span class="line">    <span class="keyword">if</span> ((ReturnOutputBufferLength == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">    <span class="comment">// 对缓冲区的操作要放到try/except中</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Command = *((PUCHAR)InputBuffer);</span><br><span class="line">    &#125; except(EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">        <span class="keyword">return</span> GetExceptionCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把传入的数据加1</span></span><br><span class="line">    Command++;</span><br><span class="line">    <span class="comment">// 对缓冲区的操作要放到try/except中</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        *((PUCHAR)OutputBuffer) = Command;</span><br><span class="line">    &#125; except(EXCEPTION_EXECUTE_HANDLER) &#123;</span><br><span class="line">        <span class="keyword">return</span> GetExceptionCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 实际数据大小</span></span><br><span class="line">    *ReturnOutputBufferLength = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下为驱动入口函数注册通讯端口的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PSECURITY_DESCRIPTOR pDescriptor = <span class="literal">NULL</span>;</span><br><span class="line">    OBJECT_ATTRIBUTES Attributes = &#123; <span class="number">370030</span> &#125;;</span><br><span class="line">    UNICODE_STRING PortName = RTL_CONSTANT_STRING(<span class="string">L&quot;MyCommPort&quot;</span>);</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    <span class="comment">// 注册过滤器</span></span><br><span class="line">    Status = FltRegisterFilter(DriverObject, &amp;Registration, &amp;FilterHandle);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">return</span> Status;</span><br><span class="line">    <span class="comment">// 创建安全描述符</span></span><br><span class="line">    Status = FltBuildDefaultSecurityDescriptor(&amp;pDescriptor, FLT_PORT_ALL_ACCESS);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        FltUnregisterFilter(FilterHandle);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化通讯端口属性</span></span><br><span class="line">    InitializeObjectAttributes(&amp;Attributes, &amp;PortName,</span><br><span class="line">        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, <span class="literal">NULL</span>, pDescriptor);</span><br><span class="line">    <span class="comment">// 创建与应用层通讯端口</span></span><br><span class="line">    Status = FltCreateCommunicationPort(FilterHandle, &amp;FilterServerPort,</span><br><span class="line">        &amp;Attributes, <span class="literal">NULL</span>, ConnectCallback, DisconnectCallback, MessageCallback, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 释放安全描述符内存</span></span><br><span class="line">    FltFreeSecurityDescriptor(pDescriptor);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        FltUnregisterFilter(FilterHandle);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 启动过滤器</span></span><br><span class="line">    Status = FltStartFiltering(FilterHandle);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        FltCloseCommunicationPort(FilterServerPort);</span><br><span class="line">        FltUnregisterFilter(FilterHandle);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>应用层向驱动通讯通讯时，连接通讯端口和发送数据的函数定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">FilterConnectCommunicationPort</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     LPCWSTR               lpPortName,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     DWORD                 dwOptions,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ LPCVOID               lpContext,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     WORD                  dwSizeOfContext,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ LPSECURITY_ATTRIBUTES lpSecurityAttributes,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_    HANDLE                *hPort</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 连接驱动的通讯端口</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">FilterSendMessage</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     HANDLE  hPort,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ LPVOID  lpInBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     DWORD   dwInBufferSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_    LPVOID  lpOutBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     DWORD   dwOutBufferSize,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_    LPDWORD lpBytesReturned</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 发送数据给驱动</span></span><br></pre></td></tr></table></figure>

<p>实际使用的示例代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CommunicationToDriverTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 连接驱动的通讯端口</span></span><br><span class="line">    HANDLE Port = <span class="literal">NULL</span>;</span><br><span class="line">    HRESULT Result = FilterConnectCommunicationPort(</span><br><span class="line">        <span class="string">L&quot;MyCommPort&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;Port);</span><br><span class="line">    <span class="keyword">if</span> (Result != S_OK) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 发送和接收数据</span></span><br><span class="line">    DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">    UCHAR InBuffer = <span class="number">55</span>;</span><br><span class="line">    UCHAR OutBuffer = <span class="number">0</span>;</span><br><span class="line">    Result = FilterSendMessage(</span><br><span class="line">        Port, &amp;InBuffer, <span class="keyword">sizeof</span>(UCHAR), &amp;OutBuffer, <span class="keyword">sizeof</span>(UCHAR), &amp;dwRet);</span><br><span class="line">    CloseHandle(Port); <span class="comment">// 关闭句柄</span></span><br><span class="line">    <span class="keyword">if</span> (Result != S_OK) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="驱动向应用层通讯"><a href="#驱动向应用层通讯" class="headerlink" title="驱动向应用层通讯"></a>驱动向应用层通讯</h4><p>驱动向应用层通讯的工作方式，与Windows的消息循环模式类似，需要先在应用层创建消息循环体，<br>然后驱动再发送给应用层。并且应用层在读取和回复消息时，需要增加一个消息头结构体，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">FILTER_MESSAGE_HEADER</span> &#123;</span></span><br><span class="line">    ULONG     ReplyLength; <span class="comment">// 驱动可接收的缓冲区大小</span></span><br><span class="line">    ULONGLONG MessageId;   <span class="comment">// 驱动生成的通讯消息ID</span></span><br><span class="line">&#125; FILTER_MESSAGE_HEADER, *PFILTER_MESSAGE_HEADER;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">FILTER_REPLY_HEADER</span> &#123;</span></span><br><span class="line">  NTSTATUS  Status; <span class="comment">// 回复给驱动的结果</span></span><br><span class="line">  ULONGLONG MessageId; <span class="comment">// 回复目标通讯消息ID</span></span><br><span class="line">&#125; FILTER_REPLY_HEADER, *PFILTER_REPLY_HEADER;</span><br></pre></td></tr></table></figure>

<p>我们这里做如下示例定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MY_GET_MSG</span> &#123;</span></span><br><span class="line">    FILTER_MESSAGE_HEADER Header; <span class="comment">// 附加的头</span></span><br><span class="line">    ULONG ProcessID; <span class="comment">// 实际通讯的数据</span></span><br><span class="line">&#125; MY_GET_MSG, *PMY_GET_MSG;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">MY_REPLAY_MSG</span> &#123;</span></span><br><span class="line">    FILTER_REPLY_HEADER Header; <span class="comment">// 附加的头</span></span><br><span class="line">    ULONG ProcessID; <span class="comment">// 实际通讯的数据</span></span><br><span class="line">&#125; MY_REPLAY_MSG, *PMY_REPLAY_MSG;</span><br></pre></td></tr></table></figure>

<p>如下为实际使用时的示例代码，需要注意的是，编译器有个 <code>结构体自动对齐</code> 的功能，以如上定义的<br>结构体为例，尽管我们通讯的 <code>ProcessID</code> 是 <code>ULONG</code> 类型，但是整个结构体会对齐到 <code>ULONGLONG</code> 大小，<br>如果我们使用整个结构体的大小，就会超出驱动中能接收的 <code>sizeof(ULONG)</code> 大小。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">GetDriverCommunicationTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 连接驱动的通讯端口</span></span><br><span class="line">    HANDLE Port = <span class="literal">NULL</span>;</span><br><span class="line">    HRESULT Result = FilterConnectCommunicationPort(</span><br><span class="line">        <span class="string">L&quot;MyCommPort&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;Port);</span><br><span class="line">    <span class="keyword">if</span> (Result != S_OK) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 创建消息循环</span></span><br><span class="line">    MY_GET_MSG stGetMsg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    MY_REPLAY_MSG stReplayMsg = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 等待读取驱动的信息</span></span><br><span class="line">        <span class="built_in">memset</span>(&amp;stGetMsg, <span class="number">0</span>, <span class="keyword">sizeof</span>(MY_GET_MSG));</span><br><span class="line">        Result = FilterGetMessage(</span><br><span class="line">            Port, &amp;stGetMsg.Header, <span class="keyword">sizeof</span>(MY_GET_MSG), <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (Result != S_OK) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 把读取到的信息加1</span></span><br><span class="line">        stReplayMsg.Header.Status = STATUS_SUCCESS;</span><br><span class="line">        stReplayMsg.Header.MessageId = stGetMsg.Header.MessageId;</span><br><span class="line">        stReplayMsg.ProcessID = stGetMsg.ProcessID + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 回复给驱动的信息(由于结构体的自动对齐情况,</span></span><br><span class="line">        <span class="comment">//   可能sizeof(MY_REPLAY_MSG)中超出原本sizeof(ULONG)的大小)</span></span><br><span class="line">        Result = FilterReplyMessage(</span><br><span class="line">            Port, &amp;stReplayMsg.Header,</span><br><span class="line">            <span class="keyword">sizeof</span>(FILTER_REPLY_HEADER) + <span class="keyword">sizeof</span>(ULONG));</span><br><span class="line">        <span class="keyword">if</span> (Result != S_OK) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(Port); <span class="comment">// 关闭句柄</span></span><br><span class="line">    <span class="keyword">if</span> (Result != S_OK) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>使用MiniFilter实现文件保护(1)</title>
    <url>/2019/07/05/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E4%BD%BF%E7%94%A8MiniFilter%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%BF%9D%E6%8A%A4-1/</url>
    <content><![CDATA[<h4 id="可用的框架"><a href="#可用的框架" class="headerlink" title="可用的框架"></a>可用的框架</h4><p>文件保护可以使用框架有两种，一种是 <code>sfilter</code> 框架，另一种是 <code>minifilter</code> 框架。<br>微软推荐使用 <code>minifilter</code> 框架，因为它封装了 <code>sfilter</code> 中关于细节的处理，使用起来更简单。</p>
<h4 id="框架的注册和卸载"><a href="#框架的注册和卸载" class="headerlink" title="框架的注册和卸载"></a>框架的注册和卸载</h4><p>在XPSP3系统中，也可以使用 <code>minifilter</code> 框架，其注册函数如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">FltRegisterFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_        PDRIVER_OBJECT   Driver,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  <span class="keyword">const</span> FLT_REGISTRATION *Registration,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_       PFLT_FILTER      *RetFilter</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>注册完毕后，还需要使过滤器生效，才会开始工作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">FltStartFiltering</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ PFLT_FILTER Filter</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果驱动提供卸载功能，则需要在 <code>DriverUnload</code> 中卸载过滤器。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FltUnregisterFilter</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ PFLT_FILTER Filter</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="注册框架前的准备工作"><a href="#注册框架前的准备工作" class="headerlink" title="注册框架前的准备工作"></a>注册框架前的准备工作</h4><p>本例子基于WDK源码中 <code>src -&gt; filesys -&gt; miniFilter -&gt; passThrough</code> 工程作为基础。<br>在进行注册之前，需要初始化两个关键的结构体，作为全局变量，这里以最小实现为例进行初始化。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONST FLT_OPERATION_REGISTRATION Callbacks[] = &#123;</span><br><span class="line">    &#123; IRP_MJ_CREATE,          <span class="number">0</span>, FilePreCreate,         FilePostOperation &#125;,</span><br><span class="line">    &#123; IRP_MJ_SET_INFORMATION, <span class="number">0</span>, FilePreSetInformation, FilePostOperation &#125;,</span><br><span class="line">    &#123; IRP_MJ_WRITE,           <span class="number">0</span>, FilePreWrite,          FilePostOperation &#125;,</span><br><span class="line">    &#123; IRP_MJ_OPERATION_END &#125; &#125;;</span><br><span class="line"></span><br><span class="line">CONST FLT_REGISTRATION Registration = &#123;</span><br><span class="line">    <span class="keyword">sizeof</span>(FLT_REGISTRATION),     <span class="comment">//  Size</span></span><br><span class="line">    FLT_REGISTRATION_VERSION,     <span class="comment">//  Version</span></span><br><span class="line">    <span class="number">0</span>,                            <span class="comment">//  Flags</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//  Context</span></span><br><span class="line">    Callbacks,                    <span class="comment">//  Operation callbacks</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//  MiniFilterUnload</span></span><br><span class="line">    FileInstanceSetup,            <span class="comment">//  InstanceSetup</span></span><br><span class="line">    FileInstanceQueryTeardown,    <span class="comment">//  InstanceQueryTeardown</span></span><br><span class="line">    FileInstanceTeardownStart,    <span class="comment">//  InstanceTeardownStart</span></span><br><span class="line">    FileInstanceTeardownComplete, <span class="comment">//  InstanceTeardownComplete</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//  GenerateFileName</span></span><br><span class="line">    <span class="literal">NULL</span>,                         <span class="comment">//  GenerateDestinationFileName</span></span><br><span class="line">    <span class="literal">NULL</span> &#125;;                       <span class="comment">//  NormalizeNameComponent</span></span><br></pre></td></tr></table></figure>

<p>结构体数组 <code>FLT_OPERATION_REGISTRATION</code> 用来定义我们需要关注的操作，<br>这里只处理 <code>IRP_MJ_CREATE</code> <code>IRP_MJ_SET_INFORMATION</code> <code>IRP_MJ_WRITE</code> 三种操作，<br>结构体数组使用 <code>IRP_MJ_OPERATION_END</code> 作为结束标志，放到数组的最后。</p>
<p>以上每种操作分为 <code>动作之前</code> 和 <code>动作之后</code> 两个时机，这里把 <code>动作之后</code> 都设置为不做任何操作，<br>注意在 <code>动作之前</code> 的函数中使用 <code>FLT_PREOP_SUCCESS_NO_CALLBACK</code> 返回值时，就可以<br>省略  <code>动作之后</code> 的函数，而如果返回 <code>FLT_PREOP_SUCCESS_WITH_CALLBACK</code> 时不能省略。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FLT_PREOP_CALLBACK_STATUS</span> <span class="params">(*PFLT_PRE_OPERATION_CALLBACK)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ PFLT_CALLBACK_DATA    Data,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    PCFLT_RELATED_OBJECTS FltObjects,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_   PVOID                 *CompletionContext</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 操作之前 函数类型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">FLT_POSTOP_CALLBACK_STATUS</span> <span class="params">(*PFLT_POST_OPERATION_CALLBACK)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_  PFLT_CALLBACK_DATA       Data,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     PCFLT_RELATED_OBJECTS    FltObjects,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ PVOID                    CompletionContext,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     FLT_POST_OPERATION_FLAGS Flags</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 操作之后 函数类型</span></span><br></pre></td></tr></table></figure>

<h4 id="实例的处理"><a href="#实例的处理" class="headerlink" title="实例的处理"></a>实例的处理</h4><p>当MiniFilter在卷上处理实例时，会调用相关Instance回调函数，其中 <code>InstanceSetup</code><br>管理准备附加的卷设备信息，可以返回 <code>STATUS_FLT_DO_NOT_ATTACH</code> 来跳过该卷设备，<br>而 <code>InstanceQueryTeardown</code> <code>InstanceTeardownStart</code> <code>InstanceTeardownComplete</code><br>我们这里不做任何处理，直接返回成功</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">FileInstanceSetup</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PCFLT_RELATED_OBJECTS FltObjects,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN FLT_INSTANCE_SETUP_FLAGS Flags,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN DEVICE_TYPE VolumeDeviceType,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN FLT_FILESYSTEM_TYPE VolumeFilesystemType)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(FltObjects);</span><br><span class="line">    UNREFERENCED_PARAMETER(Flags);</span><br><span class="line">    UNREFERENCED_PARAMETER(VolumeDeviceType); <span class="comment">// 卷设备类型</span></span><br><span class="line">    <span class="comment">// FILE_DEVICE_CD_ROM_FILE_SYSTEM</span></span><br><span class="line">    <span class="comment">// FILE_DEVICE_DISK_FILE_SYSTEM</span></span><br><span class="line">    <span class="comment">// FILE_DEVICE_NETWORK_FILE_SYSTEM</span></span><br><span class="line">    UNREFERENCED_PARAMETER(VolumeFilesystemType); <span class="comment">// 文件系统类型</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">FileInstanceQueryTeardown</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PCFLT_RELATED_OBJECTS FltObjects,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN FLT_INSTANCE_QUERY_TEARDOWN_FLAGS Flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(FltObjects);</span><br><span class="line">    UNREFERENCED_PARAMETER(Flags);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">FileInstanceTeardownStart</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PCFLT_RELATED_OBJECTS FltObjects,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN FLT_INSTANCE_TEARDOWN_FLAGS Flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(FltObjects);</span><br><span class="line">    UNREFERENCED_PARAMETER(Flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">VOID <span class="title">FileInstanceTeardownComplete</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PCFLT_RELATED_OBJECTS FltObjects,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN FLT_INSTANCE_TEARDOWN_FLAGS Flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(FltObjects);</span><br><span class="line">    UNREFERENCED_PARAMETER(Flags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="操作的类型处理"><a href="#操作的类型处理" class="headerlink" title="操作的类型处理"></a>操作的类型处理</h4><p>删除文件时触发的操作，还包括创建或打开时设置 <code>FILE_DELETE_ON_CLOSE</code> 标志的方式，所以要在<br><code>IRP_MJ_CREATE</code> 中检测是否存在 <code>FILE_DELETE_ON_CLOSE</code> 标志信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FLT_PREOP_CALLBACK_STATUS FLTAPI <span class="title">FilePreCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT PFLT_CALLBACK_DATA Data,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN     PCFLT_RELATED_OBJECTS FltObjects,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT    PVOID *CompletionContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(FltObjects);</span><br><span class="line">    UNREFERENCED_PARAMETER(CompletionContext);</span><br><span class="line">    <span class="comment">// 本次操作对应的进程</span></span><br><span class="line">    FltGetRequestorProcessId(Data);</span><br><span class="line">    <span class="comment">// 使用FltGetFileNameInformation获取文件信息</span></span><br><span class="line">    <span class="comment">// 使用FltParseFileNameInformation转换文件路径</span></span><br><span class="line">    Data; <span class="comment">// 文件信息</span></span><br><span class="line">    <span class="comment">// 检查是否包含关闭文件后并删除的标志</span></span><br><span class="line">    <span class="keyword">if</span> (Data-&gt;Iopb-&gt;Parameters.Create.Options &amp; FILE_DELETE_ON_CLOSE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置拒绝本次操作</span></span><br><span class="line">        Data-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">        Data-&gt;IoStatus.Status = STATUS_ACCESS_DENIED;</span><br><span class="line">        <span class="comment">// 已处理完毕，不再往下层发送</span></span><br><span class="line">        <span class="keyword">return</span> FLT_PREOP_COMPLETE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 本层不做处理，继续发给下层过滤器</span></span><br><span class="line">    <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>IRP_MJ_SET_INFORMATION</code> 中，重命名文件时触发 <code>FileRenameInformation</code> 操作，删除文件时触发<br><code>FileDispositionInformation</code> 操作，我们只关注这两种操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FLT_PREOP_CALLBACK_STATUS FLTAPI <span class="title">FilePreSetInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT PFLT_CALLBACK_DATA Data,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN     PCFLT_RELATED_OBJECTS FltObjects,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT    PVOID *CompletionContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(FltObjects);</span><br><span class="line">    UNREFERENCED_PARAMETER(CompletionContext);</span><br><span class="line">    <span class="comment">// 本次操作对应的进程</span></span><br><span class="line">    FltGetRequestorProcessId(Data);</span><br><span class="line">    <span class="comment">// 使用FltGetFileNameInformation获取文件信息</span></span><br><span class="line">    <span class="comment">// 使用FltParseFileNameInformation转换文件路径</span></span><br><span class="line">    Data; <span class="comment">// 文件信息</span></span><br><span class="line">    <span class="comment">// 检查本次操作类型是不是删除文件操作</span></span><br><span class="line">    <span class="keyword">if</span> (Data-&gt;Iopb-&gt;Parameters.SetFileInformation.FileInformationClass == FileDispositionInformation);</span><br><span class="line">    <span class="comment">// 检查本次操作类型是不是重命名文件操作</span></span><br><span class="line">    <span class="keyword">if</span> (Data-&gt;Iopb-&gt;Parameters.SetFileInformation.FileInformationClass == FileRenameInformation)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 文件的新父路径，使用ZwQueryInformationFile查询</span></span><br><span class="line">        ((PFILE_RENAME_INFORMATION)(Data-&gt;Iopb-&gt;Parameters.SetFileInformation.InfoBuffer))-&gt;RootDirectory;</span><br><span class="line">        <span class="comment">// 文件的新子路径，WCHAR字符串，不含L&#x27;\0&#x27;结尾</span></span><br><span class="line">        ((PFILE_RENAME_INFORMATION)(Data-&gt;Iopb-&gt;Parameters.SetFileInformation.InfoBuffer))-&gt;FileName;</span><br><span class="line">        ((PFILE_RENAME_INFORMATION)(Data-&gt;Iopb-&gt;Parameters.SetFileInformation.InfoBuffer))-&gt;FileNameLength;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 本层不做处理，继续发给下层过滤器</span></span><br><span class="line">    <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>IRP_MJ_WRITE</code> 中，我们处理文件内容的写入操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FLT_PREOP_CALLBACK_STATUS FLTAPI <span class="title">FilePreWrite</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT PFLT_CALLBACK_DATA Data,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN     PCFLT_RELATED_OBJECTS FltObjects,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT    PVOID *CompletionContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(FltObjects);</span><br><span class="line">    UNREFERENCED_PARAMETER(CompletionContext);</span><br><span class="line">    <span class="comment">// 本次操作对应的进程</span></span><br><span class="line">    FltGetRequestorProcessId(Data);</span><br><span class="line">    <span class="comment">// 使用FltGetFileNameInformation获取文件信息</span></span><br><span class="line">    <span class="comment">// 使用FltParseFileNameInformation转换文件路径</span></span><br><span class="line">    Data; <span class="comment">// 文件信息</span></span><br><span class="line">    <span class="comment">// 本层不做处理，继续发给下层过滤器</span></span><br><span class="line">    <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通用的 <code>操作之后</code> 函数，不做任何处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FLT_POSTOP_CALLBACK_STATUS <span class="title">FilePostOperation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT PFLT_CALLBACK_DATA Data,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN     PCFLT_RELATED_OBJECTS FltObjects,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN     PVOID CompletionContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN     FLT_POST_OPERATION_FLAGS Flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(Data);</span><br><span class="line">    UNREFERENCED_PARAMETER(FltObjects);</span><br><span class="line">    UNREFERENCED_PARAMETER(CompletionContext);</span><br><span class="line">    UNREFERENCED_PARAMETER(Flags);</span><br><span class="line">    <span class="keyword">return</span> FLT_POSTOP_FINISHED_PROCESSING;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>使用MiniFilter实现文件重定向(1)</title>
    <url>/2021/04/30/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E4%BD%BF%E7%94%A8MiniFilter%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E9%87%8D%E5%AE%9A%E5%90%91-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>有些情况下，我们需要伪装某个文件，比如请求打开文件A，实际上打开的是B，就需要<br>实现文件重定向的功能。比如在沙箱技术中，就可以用文件和文件夹的重定向技术实现，<br>这里参照的WDK示例 <code>src -&gt; filesys -&gt; miniFilter -&gt; simrep</code> 的框架</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>关于 <code>MiniFilter</code> 注册和安装的代码这里不再罗列，主要关注重定向核心逻辑。<br>我们需要在驱动触发 <code>PreCreate</code> 时，去查询目标文件的路径，如果匹配到，就改变这个路径<br>为另外的文件路径，最后返回 <code>STATUS_REPARSE</code> 结果，操作系统就会使用使用新路径去处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FLT_PREOP_CALLBACK_STATUS <span class="title">MyPreCreate</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PFLT_CALLBACK_DATA Data,</span></span></span><br><span class="line"><span class="function"><span class="params">    PCFLT_RELATED_OBJECTS FltObjects,</span></span></span><br><span class="line"><span class="function"><span class="params">    PVOID *CompletionContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PWCHAR NewName = <span class="literal">NULL</span>;</span><br><span class="line">     UNICODE_STRING OriName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UNREFERENCED_PARAMETER(FltObjects);</span><br><span class="line">    UNREFERENCED_PARAMETER(CompletionContext);</span><br><span class="line">    <span class="keyword">if</span> (Data-&gt;Iopb-&gt;MajorFunction != IRP_MJ_CREATE)</span><br><span class="line">        <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    <span class="keyword">if</span> (!Data || !Data-&gt;Iopb || !Data-&gt;Iopb-&gt;TargetFileObject)</span><br><span class="line">        <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    RtlInitUnicodeString(&amp;OriName, <span class="string">L&quot;\\System32\\1.txt&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (RtlEqualUnicodeString(&amp;Data-&gt;Iopb-&gt;TargetFileObject-&gt;FileName, &amp;OriName, TRUE))</span><br><span class="line">    &#123;</span><br><span class="line">        NewName = (PWCHAR)ExAllocatePool(NonPagedPoolNx, <span class="number">256</span>);</span><br><span class="line">        <span class="keyword">if</span> (NewName)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 注意新路径需要包含\\Device\\HardDiskVolume3卷信息</span></span><br><span class="line">            wcscpy(NewName, <span class="string">L&quot;\\SystemRoot\\System32\\2.txt&quot;</span>);</span><br><span class="line">            ExFreePool(Data-&gt;Iopb-&gt;TargetFileObject-&gt;FileName.Buffer);</span><br><span class="line">            RtlInitUnicodeString(&amp;Data-&gt;Iopb-&gt;TargetFileObject-&gt;FileName, NewName);</span><br><span class="line">            Data-&gt;Iopb-&gt;TargetFileObject-&gt;RelatedFileObject = <span class="literal">NULL</span>;</span><br><span class="line">            Data-&gt;IoStatus.Status = STATUS_REPARSE;</span><br><span class="line">            Data-&gt;IoStatus.Information = IO_REPARSE;</span><br><span class="line">            FltSetCallbackDataDirty(Data); <span class="comment">// simrep中没有这行</span></span><br><span class="line">            <span class="keyword">return</span> FLT_PREOP_COMPLETE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：因为文件操作本身就特别复杂，所以文件重定向需要格外注意细节，以上代码仅作技术参考</p>
]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>使用MiniFilter拦截DLL的加载(1)</title>
    <url>/2019/12/26/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E4%BD%BF%E7%94%A8MiniFilter%E6%8B%A6%E6%88%AADLL%E7%9A%84%E5%8A%A0%E8%BD%BD-1/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>拦截DLL的加载，主要的思路就是在 <code>LdrLoadDll</code> 过程中，所涉及的操作进行拦截，比如 <code>CreateSection</code><br> <code>CreateFileMapping</code> 映射文件的操作，在32位系统中可以HOOK这些函数来拦截，而在64位系统中则可以<br>使用 <code>MiniFilter</code> 过滤映射文件时产生的 <code>IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION</code> 操作。</p>
<p>还有一种方法，就是在 <code>PsSetLoadImageNotifyRoutine</code> 中修改DLL的入口点代码，但是存在一些问题，<br>首先DLL被拦截一次之后，重启系统前再也无法加载，另外在通知回调中，去掉内存写保护时会导致死锁，<br>需要硬编码在 <code>EPROCESS</code> 中找到这个锁先进行释放，然后才能用 <code>ZwProtectVirturlMemory</code> 去掉写保护，<br>改完代码后还需要手动加上锁，显然这种方式不仅通用性不好，而且还不易操作。</p>
<h4 id="使用文件过滤"><a href="#使用文件过滤" class="headerlink" title="使用文件过滤"></a>使用文件过滤</h4><p>这里过滤框架使用的是WDK源码中的  <code>src -&gt; filesys -&gt; miniFilter -&gt; passThrough</code> 项目，首先在<br>注册 <code>FLT_OPERATION_REGISTRATION</code> 的结构体中，修改关于文件映射IRP的处理函数，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    IRP_MJ_ACQUIRE_FOR_SECTION_SYNCHRONIZATION,</span><br><span class="line">    FLTFL_OPERATION_REGISTRATION_SKIP_PAGING_IO,</span><br><span class="line">    PtPreCreateSection, <span class="comment">// 处理文件映射的函数</span></span><br><span class="line">    PtPostOperationPassThrough</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>过滤文件映射的处理函数如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FLT_PREOP_CALLBACK_STATUS <span class="title">PtPreCreateSection</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    __inout PFLT_CALLBACK_DATA Data,</span></span></span><br><span class="line"><span class="function"><span class="params">    __in PCFLT_RELATED_OBJECTS FltObjects,</span></span></span><br><span class="line"><span class="function"><span class="params">    __deref_out_opt PVOID *CompletionContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG ProcessID = <span class="number">0</span>;</span><br><span class="line">    PEPROCESS EProcess = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PFLT_FILE_NAME_INFORMATION NameInfo = <span class="literal">NULL</span>;</span><br><span class="line">    UNREFERENCED_PARAMETER(CompletionContext);</span><br><span class="line">    <span class="comment">// 获取本次操作的进程信息</span></span><br><span class="line">    EProcess = FltGetRequestorProcess(Data);</span><br><span class="line">    ProcessID = FltGetRequestorProcessId(Data);</span><br><span class="line">    <span class="comment">// 检查是不是映射文件操作</span></span><br><span class="line">    <span class="keyword">if</span> (Data-&gt;Iopb-&gt;Parameters.AcquireForSectionSynchronization.SyncType</span><br><span class="line">        == SyncTypeCreateSection)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取文件名信息</span></span><br><span class="line">        Status = FltGetFileNameInformation(Data,</span><br><span class="line">            FLT_FILE_NAME_NORMALIZED | FLT_FILE_NAME_QUERY_DEFAULT, &amp;NameInfo);</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (NT_SUCCESS(Status))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 转换文件名信息</span></span><br><span class="line">                Status = FltParseFileNameInformation(NameInfo);</span><br><span class="line">                <span class="keyword">if</span> (NT_SUCCESS(Status))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 本次操作的文件对象</span></span><br><span class="line">                    Data-&gt;Iopb-&gt;TargetFileObject;</span><br><span class="line">                    <span class="comment">// 过滤到的文件不止DLL文件,可以做个检测</span></span><br><span class="line">                    <span class="keyword">if</span> (IsValidDll(FltObjects-&gt;Instance, FltObjects-&gt;FileObject))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 根据已获得的PID,NameInfo,FileObject决定动作</span></span><br><span class="line">                        <span class="comment">// ......</span></span><br><span class="line">                        FltReleaseFileNameInformation(NameInfo);</span><br><span class="line">                        Data-&gt;IoStatus.Status = STATUS_ACCESS_DENIED;</span><br><span class="line">                        <span class="keyword">return</span> FLT_PREOP_COMPLETE;</span><br><span class="line">                        <span class="comment">// 注意拦截后会弹出权限不足的窗口</span></span><br><span class="line">                        <span class="comment">// 使用STATUS_INSUFFICIENT_RESOURCES就不会弹窗</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 释放文件名内存空间</span></span><br><span class="line">                FltReleaseFileNameInformation(NameInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FLT_PREOP_SUCCESS_WITH_CALLBACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>验证过滤到的文件是否是DLL文件的函数。关于PE文件的验证，可以看前边写的PE数字签名相关文章。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">IsValidDll</span><span class="params">(PFLT_INSTANCE Instance, PFILE_OBJECT FileObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG Size = <span class="number">0</span>;</span><br><span class="line">    PUCHAR Buffer[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;; <span class="comment">// 要用堆空间</span></span><br><span class="line">    LARGE_INTEGER Offset = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    <span class="comment">// 读取文件并验证PE结构,见前边写的PE数字签名相关文章</span></span><br><span class="line">    Status = FltReadFile(Instance, FileObject, &amp;Offset, <span class="number">1024</span>, Buffer,</span><br><span class="line">        FLTFL_IO_OPERATION_DO_NOT_UPDATE_BYTE_OFFSET, &amp;Size, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>由于MiniFilter是分层过滤的，如果在高权重的过滤层直接把IRP完成了，那么低权重的过滤层就收不到<br>该IRP了，所以应该尽量的提高过滤驱动的权重。</p>
<p>某些情况下使用 <code>FltGetFileNameInformation</code> 函数无法获取文件名，比如使用 <code>CreateFileMapping</code><br>和 <code>MapViewOfFile</code> 后，再使用 <code>memset</code> 写入数据时，触发的 <code>IRP_MJ_WRITE</code> 就无法获取文件名，但是在<br><code>IRP_MJ_CREATE</code> 处能获取到，所以我们需要借助注册 <code>FLT_CONTEXT_REGISTRATION</code> 来传递上下文。</p>
<p><img src="01.png" alt="错误码描述"></p>
<p>处理上下文的例子参考WDK源码中的 <code>src -&gt; filesys -&gt; miniFilter -&gt; ctx</code> 项目。</p>
]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>使用MiniFilter拦截MountPoint操作(1)</title>
    <url>/2021/12/06/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E4%BD%BF%E7%94%A8MiniFilter%E6%8B%A6%E6%88%AAMountPoint%E6%93%8D%E4%BD%9C-1/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>某些情况下，我们需要保护文件或文件夹，不被恶意 <code>MountPoint</code> 或 <code>HardLink</code> 等操作。<br>有以下几种可选方案：<br>1、在操作文件之前，先检测是否被 <code>MountPoint</code> ，如果有则解除。<br>2、利用MiniFilter过滤驱动，来拦截所有的 <code>MountPoint</code> 等操作。<br>3、使用DACL权限管理机制，在 <code>MountPoint</code> 时，请求的是 <code>FILE_WRITE_ATTRIBUTES</code> 权限，<br>所以可以在目标中添加 <code>拒绝Users组的写入属性</code> 权限，而Users组在CreateFile时，需要排除请求<br>写入属性权限，即 <code>FILE_ALL_ACCESS &amp; ~FILE_WRITE_ATTRIBUTES</code>，否则会因为权限被拒绝而<br>打开文件失败。注：只是修改的Users组，其他组不受影响。修改父目录的权限后，其所有子目录<br>可以自动继承该权限。<code>重要：目标的拥有者不能是Users组，因为拥有者具有全部权限</code>。</p>
<h4 id="使用MiniFilter过滤"><a href="#使用MiniFilter过滤" class="headerlink" title="使用MiniFilter过滤"></a>使用MiniFilter过滤</h4><p>MountPoint操作对应到MiniFilter驱动中，主功能码为 <code>IRP_MJ_FILE_SYSTEM_CONTROL</code>，<br>内部控制码是 <code>FSCTL_SET_REPARSE_POINT</code>。<br>HardLink操作对应到MiniFilter驱动中，主功能码是 <code>IRP_MJ_SET_INFORMATION</code>，对应的<br><code>FileInformationClass</code> 为 <code>FileLinkInformation</code>。</p>
<p>注册 <code>FLT_OPERATION_REGISTRATION</code> 的结构体，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">FLT_OPERATION_REGISTRATION Callbacks[] = &#123;</span><br><span class="line">    &#123; IRP_MJ_SET_INFORMATION, <span class="number">0</span>, PtPreSetInfromation, <span class="literal">NULL</span> &#125;,</span><br><span class="line">    &#123; IRP_MJ_FILE_SYSTEM_CONTROL, <span class="number">0</span>, PtPreFileSystemControl, <span class="literal">NULL</span> &#125;,</span><br><span class="line">    &#123; IRP_MJ_OPERATION_END &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>过滤文件映射的处理函数如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FLT_POSTOP_CALLBACK_STATUS <span class="title">PtPreSetInfromation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ PFLT_CALLBACK_DATA Data,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ PCFLT_RELATED_OBJECTS FltObjects,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_ PVOID *CompletionContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG ProcessID = <span class="number">0</span>;</span><br><span class="line">    PEPROCESS EProcess = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PFLT_FILE_NAME_INFORMATION NameInfo = <span class="literal">NULL</span>;</span><br><span class="line">    UNREFERENCED_PARAMETER(CompletionContext);</span><br><span class="line">    <span class="comment">// 获取本次操作的进程信息</span></span><br><span class="line">    EProcess = FltGetRequestorProcess(Data);</span><br><span class="line">    ProcessID = FltGetRequestorProcessId(Data);</span><br><span class="line">    <span class="comment">// 检查是不是硬链接操作</span></span><br><span class="line">    <span class="keyword">if</span> (Data-&gt;Iopb-&gt;Parameters.SetFileInformation.FileInformationClass</span><br><span class="line">        != FileLinkInformation) <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    <span class="comment">// 获取文件名信息</span></span><br><span class="line">    Status = FltGetFileNameInformation(Data,</span><br><span class="line">        FLT_FILE_NAME_NORMALIZED | FLT_FILE_NAME_QUERY_DEFAULT, &amp;NameInfo);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status) <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    <span class="comment">// 转换文件名信息</span></span><br><span class="line">    Status = FltParseFileNameInformation(NameInfo);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        FltReleaseFileNameInformation(NameInfo);</span><br><span class="line">        <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 本次操作的文件对象</span></span><br><span class="line">    Data-&gt;Iopb-&gt;TargetFileObject;</span><br><span class="line">    <span class="comment">// 根据已获得的PID,NameInfo,FileObject决定动作</span></span><br><span class="line">    <span class="keyword">if</span> (IsProtectFile(NameInfo))</span><br><span class="line">    &#123;</span><br><span class="line">        FltReleaseFileNameInformation(NameInfo);</span><br><span class="line">        Data-&gt;IoStatus.Status = STATUS_ACCESS_DENIED;</span><br><span class="line">        <span class="keyword">return</span> FLT_PREOP_COMPLETE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放文件名内存空间</span></span><br><span class="line">    FltReleaseFileNameInformation(NameInfo);</span><br><span class="line">    <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">FLT_POSTOP_CALLBACK_STATUS <span class="title">PtPreFileSystemControl</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ PFLT_CALLBACK_DATA Data,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ PCFLT_RELATED_OBJECTS FltObjects,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_ PVOID *CompletionContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG ProcessID = <span class="number">0</span>;</span><br><span class="line">    PEPROCESS EProcess = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PFLT_FILE_NAME_INFORMATION NameInfo = <span class="literal">NULL</span>;</span><br><span class="line">    UNREFERENCED_PARAMETER(CompletionContext);</span><br><span class="line">    <span class="comment">// 获取本次操作的进程信息</span></span><br><span class="line">    EProcess = FltGetRequestorProcess(Data);</span><br><span class="line">    ProcessID = FltGetRequestorProcessId(Data);</span><br><span class="line">    <span class="comment">// 检查是不是MountPoint操作</span></span><br><span class="line">    <span class="keyword">if</span> (Data-&gt;Iopb-&gt;Parameters.FileSystemControl.Common.FsControlCode</span><br><span class="line">        != FSCTL_SET_REPARSE_POINT) <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    <span class="comment">// 获取文件名信息</span></span><br><span class="line">    Status = FltGetFileNameInformation(Data,</span><br><span class="line">        FLT_FILE_NAME_NORMALIZED | FLT_FILE_NAME_QUERY_DEFAULT, &amp;NameInfo);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status) <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    <span class="comment">// 转换文件名信息</span></span><br><span class="line">    Status = FltParseFileNameInformation(NameInfo);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        FltReleaseFileNameInformation(NameInfo);</span><br><span class="line">        <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 本次操作的文件对象</span></span><br><span class="line">    Data-&gt;Iopb-&gt;TargetFileObject;</span><br><span class="line">    <span class="comment">// 根据已获得的PID,NameInfo,FileObject决定动作</span></span><br><span class="line">    <span class="keyword">if</span> (IsProtectFile(NameInfo))</span><br><span class="line">    &#123;</span><br><span class="line">        FltReleaseFileNameInformation(NameInfo);</span><br><span class="line">        Data-&gt;IoStatus.Status = STATUS_ACCESS_DENIED;</span><br><span class="line">        <span class="keyword">return</span> FLT_PREOP_COMPLETE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放文件名内存空间</span></span><br><span class="line">    FltReleaseFileNameInformation(NameInfo);</span><br><span class="line">    <span class="keyword">return</span> FLT_PREOP_SUCCESS_NO_CALLBACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：无论是 <code>MountPoint</code> 还是 <code>HardLink</code> 都存在 <code>源对象</code> 和 <code>目的对象</code>，这里只处理了 <code>源对象</code>。<br>可以参考链接 <a href="http://www.sinkland.cn/?p=204">http://www.sinkland.cn/?p=204</a> 中的例子来处理 <code>目的对象</code>。</p>
]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SSDTHOOK实现进程保护(2)</title>
    <url>/2019/07/24/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E4%BD%BF%E7%94%A8SSDTHOOK%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E4%BF%9D%E6%8A%A4-2/</url>
    <content><![CDATA[<h4 id="在XP下的HOOK方式"><a href="#在XP下的HOOK方式" class="headerlink" title="在XP下的HOOK方式"></a>在XP下的HOOK方式</h4><p>在XP下可以使用的HOOK方式，包含 <code>SSDTHOOK</code> <code>INLINEHOOK</code> <code>OBJECTHOOK</code> 等，<br>其中 <code>SSDTHOOK</code> <code>OBJECTHOOK</code> 相对于 <code>INLINEHOOK</code> 更稳定，但是也更容易被移除。</p>
<h4 id="SSDTHOOK的原理"><a href="#SSDTHOOK的原理" class="headerlink" title="SSDTHOOK的原理"></a>SSDTHOOK的原理</h4><p>SSDT全称 <code>System Services Descriptor Table</code> 中文叫 <code>系统服务描述符表</code> 它是一个地址数组，<br>保存着由R3切换到R0时，所用函数的索引地址。在XP中导出了一个描述SSDT的结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SSDT_TABLE</span> &#123;</span></span><br><span class="line">    PULONG ServiceTableBase; <span class="comment">// 基址</span></span><br><span class="line">    PULONG ServiceCounterTableBase;</span><br><span class="line">    ULONG NumberOfServices; <span class="comment">// 数量</span></span><br><span class="line">    PUCHAR ParamTableBase;</span><br><span class="line">&#125; SSDT_TABLE, *PSSDT_TABLE;</span><br></pre></td></tr></table></figure>

<p>我们在使用时，需要先声明一下这个导出的结构体变量</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NTSYSAPI SSDT_TABLE KeServiceDescriptorTable;</span><br></pre></td></tr></table></figure>

<p>那么如何查找某函数对应的索引呢，比如 <code>ZwTerminateProcess</code> 这个函数，我们先看一下反汇编</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span>: kd&gt; u ZwTerminateProcess</span><br><span class="line">nt!ZwTerminateProcess:</span><br><span class="line"><span class="number">80502140</span> b801010000      mov     eax,<span class="number">101</span>h</span><br><span class="line"><span class="number">80502145</span> <span class="number">8</span>d542404        lea     edx,[esp+<span class="number">4</span>]</span><br><span class="line"><span class="number">80502149</span> <span class="number">9</span>c              pushfd</span><br><span class="line"><span class="number">8050214</span>a <span class="number">6</span>a08            push    <span class="number">8</span></span><br><span class="line"><span class="number">8050214</span>c e800030400      call    nt!KiSystemService (<span class="number">80542451</span>)</span><br><span class="line"><span class="number">80502151</span> c20800          ret     <span class="number">8</span></span><br></pre></td></tr></table></figure>

<p>这个函数的功能就是，把 <code>0x101</code> 索引放入到 <code>eax</code> 中，然后通过 <code>KiSystemService</code> 访问索引的函数，<br>索引 <code>0x101</code> 处存储的就是 <code>NtTerminateProcess</code> 函数，这个函数才是真实的 <code>退出进程</code> 功能函数。<br>可以看到 <code>0x101</code> 正是 <code>ZwTerminateProcess</code> 函数 <code>起始地址+1字节</code> 的位置，所以可以这样定义一个宏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据ZW函数查找NT函数的ID</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVICE_ID(Service) (*(PULONG)((ULONG)(Service) + 1))</span></span><br></pre></td></tr></table></figure>

<p>同时我们也可以借助于一些ARK工具来验证这个索引是否正确，如下为PCHunter显示的信息</p>
<p><img src="01.png" alt="函数索引"></p>
<p>而我们HOOK函数 <code>NtTerminateProcess</code> 就是用我们自己的函数地址，替换 <code>0x101</code> 索引处的地址，<br>这样系统调用 <code>NtTerminateProcess</code> 函数时就会调用我们的函数，当我们检测完放行时，还得调用原始<br>函数，执行正常功能，如果我们不放行，就可以直接返回 <code>STATUS_ACCESS_DENIED</code> 进行拦截操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">NtTerminateProcess</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  HANDLE ProcessHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      NTSTATUS ExitStatus</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如下为HOOK函数，以及相关调用代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SSDTHook</span><span class="params">(IN PULONG FuncAddr, IN PVOID ProxyAddr, OUT PULONG OrigianlAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WPOff(); <span class="comment">// 关闭内存写保护</span></span><br><span class="line">    *OrigianlAddr = *(PULONG)FuncAddr; <span class="comment">// 保存原函数地址</span></span><br><span class="line">    *(PULONG)FuncAddr = (ULONG)ProxyAddr; <span class="comment">// 替换为自定义函数</span></span><br><span class="line">    WPOn(); <span class="comment">// 打开内存写保护</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ULONG OriginalNtTerminateProcess = <span class="number">0</span>; <span class="comment">// 原函数地址</span></span><br><span class="line"><span class="comment">// 开始Hook函数</span></span><br><span class="line">SSDTHook(</span><br><span class="line">    &amp;KeServiceDescriptorTable.ServiceTableBase[SERVICE_ID(ZwTerminateProcess)],</span><br><span class="line">    ProxyNtTerminateProcess,</span><br><span class="line">    &amp;OriginalNtTerminateProcess);</span><br></pre></td></tr></table></figure>

<p>由于我们需要写系统关键处的内存，所以就需要先关闭写保护，如下为相关汇编代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 关闭R0级写保护</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WPOff</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        cli</span><br><span class="line">        mov eax, cr0</span><br><span class="line">        <span class="keyword">and</span> eax, <span class="keyword">not</span> <span class="number">10000</span>h</span><br><span class="line">        mov cr0, eax</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 恢复R0级写保护</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WPOn</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    __asm</span><br><span class="line">    &#123;</span><br><span class="line">        mov    eax, cr0</span><br><span class="line">        <span class="keyword">or</span> eax, <span class="number">10000</span>h</span><br><span class="line">        mov cr0, eax</span><br><span class="line">        sti</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后是我们自定义函数的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(*PNTP)</span><span class="params">(HANDLE, NTSTATUS)</span></span>; <span class="comment">// NtTerminateProcess</span></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">ProxyNtTerminateProcess</span><span class="params">(HANDLE ProcessHandle, NTSTATUS ExitStatus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 检查参数</span></span><br><span class="line">        <span class="keyword">if</span> (ProcessHandle == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ProcessHandle == (HANDLE)<span class="number">-1</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 本次操作对应的进程</span></span><br><span class="line">        PsGetCurrentProcessId();</span><br><span class="line">        <span class="comment">// 使用ZwQueryInformationProcess查询进程名</span></span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">            <span class="keyword">return</span> STATUS_ACCESS_DENIED; <span class="comment">// 拦截操作</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 调用原始函数</span></span><br><span class="line">    <span class="keyword">if</span> (OriginalNtTerminateProcess != <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> ((PNTP)OriginalNtTerminateProcess)(ProcessHandle, ExitStatus);</span><br><span class="line">    <span class="keyword">return</span> STATUS_ACCESS_DENIED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="OBJECTHOOK的原理"><a href="#OBJECTHOOK的原理" class="headerlink" title="OBJECTHOOK的原理"></a>OBJECTHOOK的原理</h4><p>所谓的OBJECTHOOK就是对进程内核对象结构体中，对应的几个进程相关操作函数地址进行替换，<br>一般情况下我们都是替换OpenProcedure函数的地址，这个函数在打开进程句柄时会被调用。</p>
<p>如何找到这些信息？在不同的操作系统中，内核对象结构体是不同的，所以需要我们搭建VMWARE调试<br>环境，通过WINDBG来实际查看目标系统的信息，这里以 <code>Windows Server 2003 x64</code> 系统为例进行说明。</p>
<p>操作系统中的所有进程内核对象，是一个链表结构，链表头部是一个全局变量，名称为 <code>PsProcessType</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> POBJECT_TYPE *PsProcessType;</span><br></pre></td></tr></table></figure>

<p>这个全局变量已经被导出，我们可以使用 <code>dq</code> 指令来查看64位内存地址</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dq PsProcessType</span><br><span class="line">fffff800`<span class="number">011</span>d1fb8  fffffadf`e7a6da00 fffffadf`e7a6d6c0</span><br><span class="line">fffff800`<span class="number">011</span>d1fc8  fffffa80`<span class="number">00002b</span>a0 <span class="number">00000000</span>`<span class="number">00000002</span></span><br><span class="line">fffff800`<span class="number">011</span>d1fd8  <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br><span class="line">fffff800`<span class="number">011</span>d1fe8  <span class="number">00000000</span>`<span class="number">00000000</span> <span class="number">00000000</span>`<span class="number">00000000</span></span><br></pre></td></tr></table></figure>

<p>因为它是一个 <code>OBJECT_TYPE</code> 结构体类型指针，我们查看对应结构体信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dt _OBJECT_TYPE fffffadf`e7a6da00</span><br><span class="line">ACPI!_OBJECT_TYPE</span><br><span class="line">   +<span class="number">0x000</span> Mutex            : _ERESOURCE</span><br><span class="line">   +<span class="number">0x068</span> TypeList         : _LIST_ENTRY [ <span class="number">0xfffffadf</span>`e7a6da68 - <span class="number">0xfffffadf</span>`e7a6da68 ]</span><br><span class="line">   +<span class="number">0x078</span> Name             : _UNICODE_STRING <span class="string">&quot;Process&quot;</span></span><br><span class="line">   +<span class="number">0x088</span> DefaultObject    : (null) </span><br><span class="line">   +<span class="number">0x090</span> Index            : <span class="number">5</span></span><br><span class="line">   +<span class="number">0x094</span> TotalNumberOfObjects : <span class="number">0x16</span></span><br><span class="line">   +<span class="number">0x098</span> TotalNumberOfHandles : <span class="number">0x70</span></span><br><span class="line">   +<span class="number">0x09c</span> HighWaterNumberOfObjects : <span class="number">0x18</span></span><br><span class="line">   +<span class="number">0x0a0</span> HighWaterNumberOfHandles : <span class="number">0x70</span></span><br><span class="line">   +<span class="number">0x0a8</span> TypeInfo         : _OBJECT_TYPE_INITIALIZER</span><br><span class="line">   +<span class="number">0x118</span> Key              : <span class="number">0x636f7250</span></span><br><span class="line">   +<span class="number">0x120</span> ObjectLocks      : [<span class="number">4</span>] _ERESOURCE</span><br></pre></td></tr></table></figure>

<p>其中 <code>TypeList</code> 成员，是一个链表头，可以通过遍历这个链表，来找到所有的进程对象。<br>然后查看 <code>TypeInfo</code> 成员，对应结构体为 <code>OBJECT_TYPE_INITIALIZER</code> 类型</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>: kd&gt; dx -r1 (*((ACPI!_OBJECT_TYPE_INITIALIZER *)<span class="number">0xfffffadfe7a6daa8</span>))</span><br><span class="line">(*((ACPI!_OBJECT_TYPE_INITIALIZER *)<span class="number">0xfffffadfe7a6daa8</span>))                 [Type: _OBJECT_TYPE_INITIALIZER]</span><br><span class="line">    [+<span class="number">0x000</span>] Length           : <span class="number">0x70</span> [Type: <span class="keyword">unsigned</span> <span class="keyword">short</span>]</span><br><span class="line">    [+<span class="number">0x002</span>] UseDefaultObject : <span class="number">0x0</span> [Type: <span class="keyword">unsigned</span> <span class="keyword">char</span>]</span><br><span class="line">    [+<span class="number">0x003</span>] CaseInsensitive  : <span class="number">0x0</span> [Type: <span class="keyword">unsigned</span> <span class="keyword">char</span>]</span><br><span class="line">    [+<span class="number">0x004</span>] InvalidAttributes : <span class="number">0xb0</span> [Type: <span class="keyword">unsigned</span> <span class="keyword">long</span>]</span><br><span class="line">    [+<span class="number">0x008</span>] GenericMapping   [Type: _GENERIC_MAPPING]</span><br><span class="line">    [+<span class="number">0x018</span>] ValidAccessMask  : <span class="number">0x1f0fff</span> [Type: <span class="keyword">unsigned</span> <span class="keyword">long</span>]</span><br><span class="line">    [+<span class="number">0x01c</span>] SecurityRequired : <span class="number">0x1</span> [Type: <span class="keyword">unsigned</span> <span class="keyword">char</span>]</span><br><span class="line">    [+<span class="number">0x01d</span>] MaintainHandleCount : <span class="number">0x0</span> [Type: <span class="keyword">unsigned</span> <span class="keyword">char</span>]</span><br><span class="line">    [+<span class="number">0x01e</span>] MaintainTypeList : <span class="number">0x0</span> [Type: <span class="keyword">unsigned</span> <span class="keyword">char</span>]</span><br><span class="line">    [+<span class="number">0x020</span>] PoolType         : NonPagedPool (<span class="number">0</span>) [Type: _POOL_TYPE]</span><br><span class="line">    [+<span class="number">0x024</span>] DefaultPagedPoolCharge : <span class="number">0x1000</span> [Type: <span class="keyword">unsigned</span> <span class="keyword">long</span>]</span><br><span class="line">    [+<span class="number">0x028</span>] DefaultNonPagedPoolCharge : <span class="number">0x438</span> [Type: <span class="keyword">unsigned</span> <span class="keyword">long</span>]</span><br><span class="line">    [+<span class="number">0x030</span>] DumpProcedure    : <span class="number">0x0</span> [Type: <span class="keyword">void</span> (__cdecl*)(<span class="keyword">void</span> *,_OBJECT_DUMP_CONTROL *)]</span><br><span class="line">    [+<span class="number">0x038</span>] OpenProcedure    : <span class="number">0x0</span> [Type: <span class="keyword">long</span> (__cdecl*)(_OB_OPEN_REASON,_EPROCESS *,<span class="keyword">void</span> *,<span class="keyword">unsigned</span> <span class="keyword">long</span>,<span class="keyword">unsigned</span> <span class="keyword">long</span>)]</span><br><span class="line">    [+<span class="number">0x040</span>] CloseProcedure   : <span class="number">0x0</span> [Type: <span class="keyword">void</span> (__cdecl*)(_EPROCESS *,<span class="keyword">void</span> *,<span class="keyword">unsigned</span> <span class="keyword">long</span>,<span class="keyword">unsigned</span> __int64,<span class="keyword">unsigned</span> __int64)]</span><br><span class="line">    [+<span class="number">0x048</span>] DeleteProcedure  : <span class="number">0xfffff800012875b0</span> [Type: <span class="keyword">void</span> (__cdecl*)(<span class="keyword">void</span> *)]</span><br><span class="line">    [+<span class="number">0x050</span>] ParseProcedure   : <span class="number">0x0</span> [Type: <span class="keyword">long</span> (__cdecl*)(<span class="keyword">void</span> *,<span class="keyword">void</span> *,_ACCESS_STATE *,<span class="keyword">char</span>,<span class="keyword">unsigned</span> <span class="keyword">long</span>,_UNICODE_STRING *,_UNICODE_STRING *,<span class="keyword">void</span> *,_SECURITY_QUALITY_OF_SERVICE *,<span class="keyword">void</span> * *)]</span><br><span class="line">    [+<span class="number">0x058</span>] SecurityProcedure : <span class="number">0xfffff800012884f0</span> [Type: <span class="keyword">long</span> (__cdecl*)(<span class="keyword">void</span> *,_SECURITY_OPERATION_CODE,<span class="keyword">unsigned</span> <span class="keyword">long</span> *,<span class="keyword">void</span> *,<span class="keyword">unsigned</span> <span class="keyword">long</span> *,<span class="keyword">void</span> * *,_POOL_TYPE,_GENERIC_MAPPING *,<span class="keyword">char</span>)]</span><br><span class="line">    [+<span class="number">0x060</span>] QueryNameProcedure : <span class="number">0x0</span> [Type: <span class="keyword">long</span> (__cdecl*)(<span class="keyword">void</span> *,<span class="keyword">unsigned</span> <span class="keyword">char</span>,_OBJECT_NAME_INFORMATION *,<span class="keyword">unsigned</span> <span class="keyword">long</span>,<span class="keyword">unsigned</span> <span class="keyword">long</span> *,<span class="keyword">char</span>)]</span><br><span class="line">    [+0x068] OkayToCloseProcedure : 0x0 [Type: unsigned char (__cdecl*)(_EPROCESS *,void *,void *,char)]</span><br></pre></td></tr></table></figure>

<p>到这里可以看到 <code>OpenProcedure</code> 函数指针目前内容为 <code>0x0</code>，对应的函数类型为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> (__cdecl*)(_OB_OPEN_REASON,_EPROCESS *,<span class="keyword">void</span> *,<span class="keyword">unsigned</span> <span class="keyword">long</span>,<span class="keyword">unsigned</span> <span class="keyword">long</span>)</span><br></pre></td></tr></table></figure>

<p>经过计算，可以得出 <code>OpenProcedure</code> 指针的地址，相对于 <code>OBJECT_TYPE</code> 类型偏移为 <code>0xE0</code> ，也就是说<br><code>((ULONGLONG)*PsProcessType + 0xE0)</code> 表示当前 <code>OpenProcedure</code> 指针的位置，通过替换该指针的内容，<br>就可以实现OBJECTHOOK操作，如下为处理函数的相关定义和内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _OB_OPEN_REASON &#123;</span><br><span class="line">    ObCreateHandle = <span class="number">0x0</span>,</span><br><span class="line">    ObOpenHandle = <span class="number">0x1</span>,</span><br><span class="line">    ObDuplicateHandle = <span class="number">0x2</span>,</span><br><span class="line">    ObInheritHandle = <span class="number">0x3</span>,</span><br><span class="line">    ObMaxOpenReason = <span class="number">0x4</span></span><br><span class="line">&#125; OB_OPEN_REASON, *POB_OPEN_REASON;</span><br><span class="line"><span class="comment">// 函数类型定义</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(*OPENPROCEDURE)</span><span class="params">(OB_OPEN_REASON, PEPROCESS, PVOID, ULONG, ULONG)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ULONGLONG OldOpenProcedure = <span class="number">0</span>; <span class="comment">// 原函数地址</span></span><br><span class="line"><span class="comment">// 开始HOOK函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetObjectHook</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    OldOpenProcedure = *(ULONGLONG*)((ULONGLONG)*PsProcessType + <span class="number">0xE0</span>);</span><br><span class="line">    *(ULONGLONG*)((ULONGLONG)*PsProcessType + <span class="number">0xE0</span>) = (ULONGLONG)MyOpenProcedure;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MyOpenProcedure</span><span class="params">(OB_OPEN_REASON Reason, PEPROCESS Process, PVOID Object, ULONG arg4, ULONG arg5)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOLEAN bDeny = FALSE;</span><br><span class="line">    UNREFERENCED_PARAMETER(arg4);</span><br><span class="line">    UNREFERENCED_PARAMETER(arg5);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 判断进程是不是系统进程</span></span><br><span class="line">        <span class="keyword">if</span> (PsGetProcessId(Process) == (HANDLE)<span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (PsGetProcessId(Object) == (HANDLE)<span class="number">4</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 创建时EPROCESS全路径是空的</span></span><br><span class="line">        <span class="keyword">if</span> (Reason == ObCreateHandle) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 判断目标进程是不是当前进程自己</span></span><br><span class="line">        <span class="keyword">if</span> ((PVOID)Object == (PVOID)Process) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 因为使用ZwQueryInformationProcess会触发重入</span></span><br><span class="line">        <span class="comment">// 所以这里直接查找在EPROCESS结构体中对应的进程路径</span></span><br><span class="line">        (PUNICODE_STRING*)((PUCHAR)Process + <span class="number">0x318</span>);</span><br><span class="line">        <span class="comment">// 拦截打开进程的操作</span></span><br><span class="line">        <span class="keyword">if</span> (bDeny) <span class="keyword">return</span> STATUS_ACCESS_DENIED;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 因为原地址为0x0所以不再调用原地址</span></span><br><span class="line">    <span class="comment">// if (OldOpenProcedure != 0)</span></span><br><span class="line">    <span class="comment">//    return ((OPENPROCEDURE)OldOpenProcedure)(Reason, Process, Object, arg4, arg5);</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，不同的系统中 <code>OpenProcedure</code> 的 <code>指针位置</code> 以及 <code>函数类型</code> 有可能是不同的，不能照搬使用。</p>
]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>使用SetWindowsHookEx监控窗口消息(1)</title>
    <url>/2019/12/25/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E4%BD%BF%E7%94%A8SetWindowsHookEx%E7%9B%91%E6%8E%A7%E7%AA%97%E5%8F%A3%E6%B6%88%E6%81%AF-1/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>使用 <code>ShellHook</code> 监控窗口消息不需要注入DLL，但是存在着无法抓取子窗口的缺陷，<br>所以这里使用 <code>SetWindowsHookEx</code> 注入DLL的方式来监控 <code>WH_CBT</code> 消息。</p>
<h4 id="HOOK代码实现"><a href="#HOOK代码实现" class="headerlink" title="HOOK代码实现"></a>HOOK代码实现</h4><p>关于 <code>SetWindowsHookEx</code> 的用法，在 <code>低级键盘钩子</code> 文章中曾经介绍过，这里直接给出代码，<br>注意32位DLL只能注入到32位程序中，64位DLL只能注入到64位程序中，所以在64位系统中，<br>如果想要监控所有的程序，需要32位程序和64位程序都要进行DLL注入。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DLL中的共享数据块</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;.shared&quot;</span>)</span></span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>;</span><br><span class="line">BOOL g_bEnable = FALSE; <span class="comment">// 是否启用</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/section:.shared,rws&quot;</span>)</span></span><br><span class="line"><span class="comment">// HOOK的回调函数</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">CbtHookProc</span><span class="params">(<span class="keyword">int</span> nCode, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// 窗口激活消息</span></span><br><span class="line">	<span class="keyword">if</span> ((g_bEnable) &amp;&amp; (nCode == HCBT_ACTIVATE))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">char</span> szTitle[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">		GetWindowText((HWND)wParam, szTitle, <span class="number">512</span>);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(szTitle, <span class="string">&quot;Internet 协议 (TCP/IP) 属性&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="comment">// 关闭指定的窗口</span></span><br><span class="line">			SendMessage((HWND)wParam, WM_CLOSE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册HOOK</span></span><br><span class="line"><span class="function">BOOL <span class="title">SetHookDll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	g_hHook = SetWindowsHookEx(</span><br><span class="line">		WH_CBT, CbtHookProc, (HINSTANCE)GetModuleHandle(<span class="string">&quot;CbtHook.dll&quot;</span>), <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (g_hHook == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">	<span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 卸载HOOK</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnHookDll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> UnhookWindowsHookEx(g_hHook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="WM-CBT消息"><a href="#WM-CBT消息" class="headerlink" title="WM_CBT消息"></a>WM_CBT消息</h4><p>在 <code>WM_CBT</code> 中监控各种窗口行为，如果Code值小于0，则必须调用 <code>CallNextHookEx</code> 继续传递消息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CBT Hook Codes</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HCBT_MOVESIZE       0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HCBT_MINMAX         1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HCBT_QS             2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HCBT_CREATEWND      3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HCBT_DESTROYWND     4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HCBT_ACTIVATE       5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HCBT_CLICKSKIPPED   6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HCBT_KEYSKIPPED     7</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HCBT_SYSCOMMAND     8</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HCBT_SETFOCUS       9</span></span><br></pre></td></tr></table></figure>

<p>在如下几种行为中，可以通过返回 <code>0值</code> 来允许本次操作，返回 <code>1值</code> 来阻止本次操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HCBT_ACTIVATE    (5)</span><br><span class="line">HCBT_CREATEWND   (3)</span><br><span class="line">HCBT_DESTROYWND  (4)</span><br><span class="line">HCBT_MINMAX      (1)</span><br><span class="line">HCBT_MOVESIZE    (0)</span><br><span class="line">HCBT_SETFOCUS    (9)</span><br><span class="line">HCBT_SYSCOMMAND  (8)</span><br></pre></td></tr></table></figure>

<p>更多的信息可以通过如下链接来了解：<br><a href="https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms644977(v=vs.85)">https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms644977(v=vs.85)</a></p>
]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>使用ShellHook监控窗口消息(1)</title>
    <url>/2019/12/25/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E4%BD%BF%E7%94%A8ShellHook%E7%9B%91%E6%8E%A7%E7%AA%97%E5%8F%A3%E6%B6%88%E6%81%AF-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>当进入到WINDOWS操作系统后，系统会启动一个SHELL程序，也就是 <code>explorer.exe</code> 程序，<br>当我们创建、激活、关闭某个窗口时，<code>explorer.exe</code> 就会捕捉到对应消息，然后更新任务栏状态，<br>这其中捕捉消息的方法，就是使用了 <code>ShellHook</code> 技术。</p>
<h4 id="替换SHELL程序"><a href="#替换SHELL程序" class="headerlink" title="替换SHELL程序"></a>替换SHELL程序</h4><p>进入操作系统后，首先启动的这个SHELL程序，可以通过修改注册表的方式进行更换，<br>首先需要获取准备替换的账户的 <code>SID</code> 信息，在获取 <code>管理员权限</code> 的情况下启动 <code>CMD</code> 命令行，<br>运行 <code>whoami /user</code> 可以获取到当前登录账户的 <code>SID</code> 信息。</p>
<p><img src="01.png" alt="查询当前用户"></p>
<p>在XP系统中 <code>whoami</code> 工具没有默认被安装上，我们还可以借助于 <code>WMI</code> 来进行查询，<br>运行 <code>wmic useraccount get name,sid</code> 查询 <code>账户名称</code> 和对应的 <code>SID</code> 信息。</p>
<p><img src="02.png" alt="查询所有用户"></p>
<p>如果修改当前用户的SHELL启动程序，可以直接在注册表编辑器中，依照如下路径所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_USERS&#x2F;(SID)&#x2F;Softwares&#x2F;Microsoft&#x2F;Windows NT&#x2F;CurrentVersion&#x2F;Winlogon</span><br></pre></td></tr></table></figure>

<p>上边的(SID)就是当前用户的SID，创建名称为 <code>Shell</code> 的 <code>字符串</code> 值，内容设置为 <code>cmd.exe</code></p>
<p><img src="03.png" alt="创建注册表"></p>
<p>注销当前用户，并重新登录时，就会在初始运行 <code>cmd.exe</code> 程序。</p>
<p>如果注册表中没有某账户的SID信息，可以使用 <code>runas /user:hello notepad.exe</code> 指令，<br>即使用 <code>hello</code> 账户运行 <code>notepad.exe</code> 程序，注意不要关闭该 <code>notepad.exe</code> 程序，然后<br>注册表中就会出现 <code>hello</code> 账户的SID信息。</p>
<h4 id="ShellHook实现"><a href="#ShellHook实现" class="headerlink" title="ShellHook实现"></a>ShellHook实现</h4><p>注册 <code>ShellHook</code> 的流程，首先需要使用 <code>RegisterWindowMessage</code> 函数注册 <code>SHELLHOOK</code> 消息，<br>然后使用 <code>RegisterShellHookWindow</code> 关联用来接收和处理<code>SHELLHOOK</code>消息的窗口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UINT WM_SHELLHOOKMESSAGE; <span class="comment">// 自定义消息</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">SetShellHook</span><span class="params">(HWND hWnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hWnd == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    WM_SHELLHOOKMESSAGE = RegisterWindowMessage(<span class="string">&quot;SHELLHOOK&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (WM_SHELLHOOKMESSAGE == <span class="number">0</span>) retrun FALSE;</span><br><span class="line">    <span class="keyword">return</span> RegisterShellHookWindow(hWnd);</span><br><span class="line">&#125; <span class="comment">// 注册ShellHook</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">UnSetShellHook</span><span class="params">(HWND hWnd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hWnd == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">return</span> DeregisterShellHookWindow(hWnd);</span><br><span class="line">&#125; <span class="comment">// 卸载ShellHook</span></span><br></pre></td></tr></table></figure>

<p>窗口回调函数和SHELLHOOK消息的处理代码，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">WndProc</span><span class="params">(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 处理ShellHook消息</span></span><br><span class="line">    <span class="keyword">if</span> (uMsg == WM_SHELLHOOKMESSAGE)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 窗口激活消息</span></span><br><span class="line">        <span class="keyword">if</span> ((wParam == HSHELL_WINDOWACTIVATED) ||</span><br><span class="line">            (wParam == HSHELL_RUDEAPPACTIVATED))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> szTitle[<span class="number">260</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">            GetWindowText((HWND)lParam, szTitle, <span class="number">260</span>);</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(szTitle, <span class="string">&quot;计算器&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 关闭指定的窗口</span></span><br><span class="line">                SendMessage((HWND)wParam, WM_CLOSE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 窗口回调消息处理</span></span><br><span class="line">    <span class="keyword">switch</span> (uMsg)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span>  WM_CREATE:</span><br><span class="line">        SetShellHook(hWnd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_DESTROY:</span><br><span class="line">        PostQuitMessage(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> WM_CLOSE:</span><br><span class="line">        UnSetShellHook(hWnd);</span><br><span class="line">        DestroyWindow(hWnd);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> DefWindowProc(hWnd, uMsg, wParam, lParam);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>关于ShellHook可以监控的消息的更多解释见如下链接：<br><a href="https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registershellhookwindow">https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-registershellhookwindow</a></p>
<h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>经测试发现，使用 <code>ShellHook</code> 只能抓取 <code>最上层</code> 窗口句柄，比如在 <code>本地连接 属性</code> 窗口里，点击<br>打开 <code>Internet 协议 (TCP/IP) 属性</code> 子窗口，而 <code>ShellHook</code> 始终只展示 <code>本地连接 属性</code>  窗口。</p>
]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>使用注册表回调实现注册表过滤(1)</title>
    <url>/2019/07/05/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E4%BD%BF%E7%94%A8%E6%B3%A8%E5%86%8C%E8%A1%A8%E5%9B%9E%E8%B0%83%E5%AE%9E%E7%8E%B0%E6%B3%A8%E5%86%8C%E8%A1%A8%E8%BF%87%E6%BB%A4-1/</url>
    <content><![CDATA[<h4 id="回调函数的注册与卸载"><a href="#回调函数的注册与卸载" class="headerlink" title="回调函数的注册与卸载"></a>回调函数的注册与卸载</h4><p>在驱动中进行注册表保护，可以通过 <code>注册表回调</code> 函数来实现。<br>在VISTA以下的系统中，使用 <code>CmRegisterCallback</code> 函数来注册回调，<br>在VISTA及以上的系统中，微软提供了新的 <code>CmRegisterCallbackEx</code> 函数来进行替代，<br>并引入了 <code>Altitude</code> 的概念，数值越大越先调用，比如 <code>423000 -&gt; 422000 -&gt; 421000</code>，<br>对于旧的 <code>CmRegisterCallback</code> 函数，系统会使用 <code>nt!CmLegacyAltitude</code> 的全局变量，<br>内容为 <code>L&quot;425000&quot;</code> 的 <code>UNICODE_STRING</code> ，注意：其他 <code>Altitude</code> 值无法注册两个相同的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">CmRegisterCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     PEX_CALLBACK_FUNCTION Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ PVOID                 Context,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_    PLARGE_INTEGER        Cookie</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">CmRegisterCallbackEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_       PEX_CALLBACK_FUNCTION Function,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_       PCUNICODE_STRING      Altitude,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_       PVOID                 Driver,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_   PVOID                 Context,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_      PLARGE_INTEGER        Cookie,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Reserved_ PVOID                 Reserved</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>两个函数注册的回调函数格式相同，如下所示。参数 <code>CallbackContext</code> 对应注册时 <code>Context</code>，<br>参数 <code>Argument1</code> 为本次操作类型，参数 <code>Argument2</code> 为本次操作类型对应的结构体信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">RegistryCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      PVOID CallbackContext,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  PVOID Argument1,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_  PVOID Argument2</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>卸载回调函数时也是使用同一个卸载函数，如果驱动自身提供卸载功能，<br>需要在 <code>DriverUnload</code> 中卸载注册时生成的 <code>Cookie</code> 信息，通常情况下都不会提供卸载。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">CmUnRegisterCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LARGE_INTEGER Cookie</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<h4 id="操作注册表时触发的动作"><a href="#操作注册表时触发的动作" class="headerlink" title="操作注册表时触发的动作"></a>操作注册表时触发的动作</h4><p>需要处理的注册表操作共有以下几类：<br>(1)创建注册表键或值  (2)修改注册表键或值  (3)删除注册表键或值</p>
<p>在回调函数中，操作类型分为 <code>动作之前</code> 和 <code>动作之后</code> 两种：<br>做拦截和保护时，需要在 <code>动作之前</code> 进行处理。做行为监控时，可以在 <code>动作之后</code> 进行处理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">RegCallback</span><span class="params">(IN PVOID Context, IN PVOID Argument1, IN PVOID Argument2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(Context);</span><br><span class="line">    <span class="comment">// 本次操作对应的进程</span></span><br><span class="line">    PsGetCurrentProcessId();</span><br><span class="line">    <span class="comment">// 本次注册表操作类型</span></span><br><span class="line">    <span class="keyword">switch</span> ((ULONG_PTR)Argument1)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> RegNtPreDeleteKey: <span class="comment">// 删除键</span></span><br><span class="line">        <span class="comment">// 键的路径，使用ObQueryNameString查询信息</span></span><br><span class="line">        ((PREG_DELETE_KEY_INFORMATION)Argument2)-&gt;Object;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> RegNtPreSetValueKey: <span class="comment">// 创建或修改值</span></span><br><span class="line">        <span class="comment">// 键的路径，使用ObQueryNameString查询信息</span></span><br><span class="line">        ((PREG_SET_VALUE_KEY_INFORMATION)Argument2)-&gt;Object;</span><br><span class="line">        <span class="comment">// 值的名称，是UNICODE_STRING类型数据</span></span><br><span class="line">        ((PREG_SET_VALUE_KEY_INFORMATION)Argument2)-&gt;ValueName;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> RegNtPreDeleteValueKey: <span class="comment">// 删除值</span></span><br><span class="line">        <span class="comment">// 键的路径，使用ObQueryNameString查询信息</span></span><br><span class="line">        ((PREG_DELETE_VALUE_KEY_INFORMATION)Argument2)-&gt;Object;</span><br><span class="line">        <span class="comment">// 值的名称，是UNICODE_STRING类型数据</span></span><br><span class="line">        ((PREG_DELETE_VALUE_KEY_INFORMATION)Argument2)-&gt;ValueName;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// Vista以下系统，是用新建和删除来实现的修改键</span></span><br><span class="line">    <span class="keyword">case</span> RegNtPreRenameKey: <span class="comment">// Vista修改键</span></span><br><span class="line">        <span class="comment">// 键的路径，使用ObQueryNameString查询信息</span></span><br><span class="line">        ((PREG_RENAME_KEY_INFORMATION)Argument2)-&gt;Object;</span><br><span class="line">        <span class="comment">// 新键的路径，是UNICODE_STRING类型数据</span></span><br><span class="line">        ((PREG_RENAME_KEY_INFORMATION)Argument2)-&gt;NewName;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> RegNtPreCreateKey: <span class="comment">// 创建键</span></span><br><span class="line">        <span class="comment">// 键的路径，是UNICODE_STRING类型数据</span></span><br><span class="line">        ((PREG_CREATE_KEY_INFORMATION)Argument2)-&gt;CompleteName;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">case</span> RegNtPreCreateKeyEx: <span class="comment">// Vista创建键</span></span><br><span class="line">        <span class="comment">// 键的父路径，使用ObQueryNameString查询信息</span></span><br><span class="line">        ((PREG_CREATE_KEY_INFORMATION)Argument2)-&gt;RootObject;</span><br><span class="line">        <span class="comment">// 键的子路径，是UNICODE_STRING类型数据</span></span><br><span class="line">        ((PREG_CREATE_KEY_INFORMATION)Argument2)-&gt;CompleteName;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回STATUS_ACCESS_DENIED表示拦截</span></span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="重要的注意事项"><a href="#重要的注意事项" class="headerlink" title="重要的注意事项"></a>重要的注意事项</h4><p>在WIN7及以上系统中（未测VISTA），在当前注册表回调中，再次操作注册表比如打开，<br>会触发回调链表中，当前回调的下一个回调，并不会从初始位置调用，所以就不会导致重入，<br>比如 A -&gt; B -&gt; C 三层，如果在B层中，执行打开，就只会触发C层，而在XP系统是从A开始</p>
]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>劫持用户双击目标到启动的流程(1)</title>
    <url>/2021/03/04/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E5%8A%AB%E6%8C%81%E7%94%A8%E6%88%B7%E5%8F%8C%E5%87%BB%E7%9B%AE%E6%A0%87%E5%88%B0%E5%90%AF%E5%8A%A8%E7%9A%84%E6%B5%81%E7%A8%8B-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>有时候我们需要拦截用户双击启动的行为，比如用户运行A程序，我们拦截后改运行B程序，<br>可以在整个启动流程中进行HOOK操作，通常的办法都是针对 <code>CreateProcess</code> 进行处理，<br>我们这里改在更早的 <code>CDefFolderMenu::InvokeCommand</code> 处进行拦截</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>我们使用 <code>WinDbg</code> 附加到 <code>explorer.exe</code> 中，并在 <code>CreateProcess</code> 处下断点，然后双击某程序<br>触发断点后，使用 <code>k</code> 指令查看函数调用栈，可以知道从双击开始到程序运行，中间经过了哪些操作，<br>经过测试 <code>双击程序</code> <code>右键运行程序</code> <code>双击快捷方式</code> <code>右键运行快捷方式</code> 几种操作的函数调用栈，结合通用性<br>和时间早两点考虑，找到了 <code>SHELL32!CDefFolderMenu::InvokeCommand</code> 这个函数</p>
<p>这个函数是 <code>CDefFolderMenu</code> 类的虚函数，所以我们可以找到这个类在shell32中的地址，并HOOK<br>虚函数表对应的位置。在shell32中导出了 <code>CDefFolderMenu_Create2</code> 函数，我们可以由此函数获取到<br><code>CDefFolderMenu</code> 类的虚函数表位置，而虚函数表中的 <code>InvokeCommand</code> 是继承自 <code>IContextMenu</code> 接口，<br>使用IDA反汇编 <code>CDefFolderMenu</code> 类可以找到 <code>InvokeCommand</code> 位于虚函数表的第 <code>[4]</code> 位置</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shlobj.h&gt;</span></span></span><br><span class="line"><span class="comment">// CDefFolderMenu::InvokeCommand</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HRESULT</span><span class="params">(__stdcall *INVOKECOMMAND)</span><span class="params">(IContextMenu *pcm, CMINVOKECOMMANDINFO *pici)</span></span>;</span><br><span class="line">ULONG_PTR* gVtbl = <span class="literal">NULL</span>; <span class="comment">// 虚函数表地址</span></span><br><span class="line">ULONG_PTR* gAddr = <span class="literal">NULL</span>; <span class="comment">// 虚函数地址指针</span></span><br><span class="line">INVOKECOMMAND pOldInvokeCommand = <span class="literal">NULL</span>; <span class="comment">// 虚函数地址 </span></span><br></pre></td></tr></table></figure>

<p>查找虚函数表并进行HOOK</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HookVirtualTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pOldInvokeCommand) <span class="keyword">return</span>;</span><br><span class="line">    IContextMenu *pcm = <span class="literal">NULL</span>;</span><br><span class="line">    HRESULT hr = CDefFolderMenu_Create2(<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, &amp;pcm);</span><br><span class="line">    <span class="keyword">if</span> (FAILED(hr)) <span class="keyword">return</span>;</span><br><span class="line">    gVtbl = *(ULONG_PTR**)pcm;</span><br><span class="line">    gAddr = (ULONG_PTR*)&amp;(gVtbl[<span class="number">4</span>]);</span><br><span class="line">    pOldInvokeCommand = (INVOKECOMMAND)*gAddr;</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">    VirtualProtect(gAddr, <span class="keyword">sizeof</span>(ULONG_PTR), PAGE_READWRITE, &amp;oldProtect);</span><br><span class="line">    InterlockedExchange64((LONG64*)gAddr, (LONG64)MyInvokeCommand);</span><br><span class="line">    VirtualProtect(gAddr, <span class="keyword">sizeof</span>(ULONG_PTR), oldProtect, &amp;oldProtect);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">UnHookVritualTable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pOldInvokeCommand) <span class="keyword">return</span>;</span><br><span class="line">    DWORD oldProtect = <span class="number">0</span>;</span><br><span class="line">    VirtualProtect(gAddr, <span class="keyword">sizeof</span>(ULONG_PTR), PAGE_READWRITE, &amp;oldProtect);</span><br><span class="line">    InterlockedExchange64((LONG64*)gAddr, (LONG64)pOldInvokeCommand);</span><br><span class="line">    VirtualProtect(gAddr, <span class="keyword">sizeof</span>(ULONG_PTR), oldProtect, &amp;oldProtect);</span><br><span class="line">    pOldInvokeCommand = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们自定义的 <code>InvokeCommand</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HRESULT <span class="title">MyInvokeCommand</span><span class="params">(IContextMenu *pcm, CMINVOKECOMMANDINFO *pici)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HRESULT hr = S_OK;</span><br><span class="line">    <span class="keyword">char</span> cmd[<span class="number">32</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pcm || !pici) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 获取操作的动作</span></span><br><span class="line">        <span class="keyword">if</span> (!IS_INTRESOURCE(pici-&gt;lpVerb)) <span class="keyword">break</span>;</span><br><span class="line">        hr = pcm-&gt;GetCommandString((UINT_PTR)pici-&gt;lpVerb, GCS_VERBA, <span class="literal">NULL</span>, cmd, <span class="number">32</span>);</span><br><span class="line">        <span class="keyword">if</span> (FAILED(hr)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 判断是不是运行操作</span></span><br><span class="line">        <span class="keyword">if</span> (_stricmp(cmd, <span class="string">&quot;open&quot;</span>) &amp;&amp; _stricmp(cmd, <span class="string">&quot;runas&quot;</span>)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 如果匹配到目标文件就直接返回</span></span><br><span class="line">        <span class="comment">// 注意：选中多个目标的情况下有影响</span></span><br><span class="line">        <span class="keyword">if</span> (CheckDragFileList(pcm)) <span class="keyword">return</span> S_OK;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 调用原始函数</span></span><br><span class="line">    <span class="keyword">if</span> (pOldInvokeCommand)</span><br><span class="line">        hr = pOldInvokeCommand(pcm, pici);</span><br><span class="line">    <span class="keyword">return</span> hr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>检查操作的目标文件名称的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CheckDragFileList</span><span class="params">(IContextMenu *pcm)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IObjectWithSelection *pSelection = <span class="literal">NULL</span>;</span><br><span class="line">    HRESULT hr = pcm-&gt;QueryInterface(IID_IObjectWithSelection, (VOID**)&amp;pSelection);</span><br><span class="line">    <span class="keyword">if</span> (SUCCEEDED(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        IDataObject *pObject = <span class="literal">NULL</span>;</span><br><span class="line">        hr = pSelection-&gt;GetSelection(IID_IDataObject, (VOID**)&amp;pObject);</span><br><span class="line">        <span class="keyword">if</span> (SUCCEEDED(hr))</span><br><span class="line">        &#123;</span><br><span class="line">            STGMEDIUM stg = &#123; TYMED_HGLOBAL &#125;;</span><br><span class="line">            FORMATETC etc = &#123; CF_HDROP, <span class="literal">NULL</span>, DVASPECT_CONTENT, <span class="number">-1</span>, TYMED_HGLOBAL &#125;;</span><br><span class="line">            <span class="comment">// 获取文件列表指针,它们存储在HDROP格式中</span></span><br><span class="line">            hr = pObject-&gt;GetData(&amp;etc, &amp;stg);</span><br><span class="line">            <span class="keyword">if</span> (SUCCEEDED(hr))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 取得HDROP句柄</span></span><br><span class="line">                HDROP hDrop = (HDROP)GlobalLock(stg.hGlobal);</span><br><span class="line">                <span class="comment">// 获取操作中被选中的文件的数目</span></span><br><span class="line">                UINT n = DragQueryFileW(hDrop, <span class="number">0xFFFFFFFF</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">for</span> (UINT i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 获取被选中的文件路径</span></span><br><span class="line">                    WCHAR szPath[MAX_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                    DragQueryFileW(hDrop, i, szPath, MAX_PATH);</span><br><span class="line">                    <span class="comment">// 检查是否是目标文件，并执行其他操作</span></span><br><span class="line">                    <span class="keyword">if</span> (wcsstr(szPath, <span class="string">L&quot;\\mytest.exe&quot;</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        system(<span class="string">&quot;calc.exe&quot;</span>); <span class="comment">// 运行计算器</span></span><br><span class="line">                        <span class="keyword">return</span> TRUE;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                GlobalUnlock(stg.hGlobal);</span><br><span class="line">                ReleaseStgMedium(&amp;stg);</span><br><span class="line">            &#125;</span><br><span class="line">            pObject-&gt;Release();</span><br><span class="line">        &#125;</span><br><span class="line">        pSelection-&gt;Release();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：通常情况下用户不会同时选中多个程序运行，更严谨的做法是已处理过的文件名从列表中去除</p>
]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>使用进程回调函实现进程过滤(1)</title>
    <url>/2019/07/08/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E4%BD%BF%E7%94%A8%E8%BF%9B%E7%A8%8B%E5%9B%9E%E8%B0%83%E5%87%BD%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E8%BF%87%E6%BB%A4-1/</url>
    <content><![CDATA[<h4 id="回调函数的注册和卸载"><a href="#回调函数的注册和卸载" class="headerlink" title="回调函数的注册和卸载"></a>回调函数的注册和卸载</h4><p>在VISTA以下的系统中，想要进行进程的保护，只能通过HOOK的方式来实现。<br>在VISTA及以上的系统中，微软提供了一个 <code>进程回调函数</code> 来实现对 <code>线程</code> 和 <code>进程</code> 进行管理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ObRegisterCallbacks</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  POB_CALLBACK_REGISTRATION CallBackRegistration,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_ PVOID                     *RegistrationHandle</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 注册回调</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ObUnRegisterCallbacks</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ PVOID RegistrationHandle</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 卸载回调</span></span><br></pre></td></tr></table></figure>

<p>在注册时，需要先初始化一个用来描述回调注册信息的结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_CALLBACK_REGISTRATION</span> &#123;</span></span><br><span class="line">  USHORT                    Version;</span><br><span class="line">  USHORT                    OperationRegistrationCount;</span><br><span class="line">  UNICODE_STRING            Altitude;</span><br><span class="line">  PVOID                     RegistrationContext;</span><br><span class="line">  OB_OPERATION_REGISTRATION *OperationRegistration;</span><br><span class="line">&#125; OB_CALLBACK_REGISTRATION, *POB_CALLBACK_REGISTRATION;</span><br></pre></td></tr></table></figure>

<p>在这个结构体中引入了 <code>altitude</code> 的概念，这个参数本身是一个字符串形式表述的数字，<br>微软将其划分为不同的区段，来表示不同的功能，这里使用的是 <code>WDK</code> 例子中使用的 <code>L&quot;321124&quot;</code> ，<br>其参数成员 <code>OB_OPERATION_REGISTRATION</code> 用来定义具体的行为信息，结构体定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OB_OPERATION_REGISTRATION</span> &#123;</span></span><br><span class="line">  POBJECT_TYPE                *ObjectType;</span><br><span class="line">  OB_OPERATION                Operations;</span><br><span class="line">  POB_PRE_OPERATION_CALLBACK  PreOperation;</span><br><span class="line">  POB_POST_OPERATION_CALLBACK PostOperation;</span><br><span class="line">&#125; OB_OPERATION_REGISTRATION, *POB_OPERATION_REGISTRATION;</span><br></pre></td></tr></table></figure>

<p>其中 <code>ObjectType</code> 参数表明我们想要处理的 <code>对象类型</code> ，可取值内容为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PsProcessType <span class="comment">// 进程类型</span></span><br><span class="line">PsThreadType <span class="comment">// 线程类型</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>Operations</code> 参数表明我们想要处理的 <code>操作类型</code> ，可取值内容为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OB_OPERATION_HANDLE_CREATE <span class="comment">// 创建操作</span></span><br><span class="line">OB_OPERATION_HANDLE_DUPLICATE <span class="comment">// 复制操作</span></span><br></pre></td></tr></table></figure>

<p>其中 <code>PreOperation</code> 表示 <code>动作之前</code> 进行处理，而 <code>PostOperation</code> 表示 <code>动作之后</code> 进行处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">OB_PREOP_CALLBACK_STATUS <span class="title">ObjectPreCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ PVOID                         RegistrationContext,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ POB_PRE_OPERATION_INFORMATION OperationInformation</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 动作之前 函数类型</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">ObjectPostCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  PVOID RegistrationContext,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  POB_POST_OPERATION_INFORMATION OperationInformation</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 动作之后 函数类型</span></span><br></pre></td></tr></table></figure>

<p>这里我们只处理 <code>动作之前</code> 的行为，而 <code>动作之后</code> 忽略，设置为 <code>NULL</code> 值，相关代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 结构体变量的定义，放到函数的开头</span></span><br><span class="line">OB_OPERATION_REGISTRATION OperationRegister = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">OB_CALLBACK_REGISTRATION CallbackRegister = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化OB_OPERATION_REGISTRATION结构体</span></span><br><span class="line">OperationRegister.ObjectType = PsProcessType;</span><br><span class="line">OperationRegister.Operations = OB_OPERATION_HANDLE_CREATE | OB_OPERATION_HANDLE_DUPLICATE;</span><br><span class="line">OperationRegister.PreOperation = ProcPreOperation;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化OB_CALLBACK_REGISTRATION结构体</span></span><br><span class="line">CallbackRegister.Version = OB_FLT_REGISTRATION_VERSION;</span><br><span class="line">CallbackRegister.OperationRegistrationCount = <span class="number">1</span>;</span><br><span class="line">RtlInitUnicodeString(&amp;CallbackRegister.Altitude, <span class="string">L&quot;321124&quot;</span>);</span><br><span class="line">CallbackRegister.OperationRegistration = &amp;OperationRegister;</span><br></pre></td></tr></table></figure>

<h4 id="操作的类型和行为的处理"><a href="#操作的类型和行为的处理" class="headerlink" title="操作的类型和行为的处理"></a>操作的类型和行为的处理</h4><p>在 <code>动作之前</code> 的处理函数中，我们可以通过取消句柄的退出权限，来阻止进程被退出</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">OB_PREOP_CALLBACK_STATUS <span class="title">ProcPreOperation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID Context,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN POB_PRE_OPERATION_INFORMATION PreOperInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(Context);</span><br><span class="line">    <span class="comment">// 判断对象类型是不是进程类型</span></span><br><span class="line">    (PreOperInfo-&gt;ObjectType != *PsProcessType);</span><br><span class="line">    <span class="comment">// 本次操作对应的进程</span></span><br><span class="line">    PsGetCurrentProcessId();</span><br><span class="line">    <span class="comment">// 判断操作的进程是不是当前进程自己</span></span><br><span class="line">    ((PEPROCESS)(PreOperInfo-&gt;Object) == PsGetCurrentProcess());</span><br><span class="line">    <span class="comment">// 判断对进程的操作类型</span></span><br><span class="line">    <span class="keyword">if</span> (PreOperInfo-&gt;Operation == OB_OPERATION_HANDLE_CREATE) <span class="comment">// 句柄创建</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果存在退出权限，则取消退出权限PROCESS_TERMINATE</span></span><br><span class="line">        <span class="keyword">if</span> (PreOperInfo-&gt;Parameters-&gt;CreateHandleInformation.OriginalDesiredAccess &amp; <span class="number">0x0001</span>)</span><br><span class="line">            PreOperInfo-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess &amp;= ~<span class="number">0x0001</span>;</span><br><span class="line">        <span class="comment">// 如果存在句柄复制权限，则取消句柄复制权限PROCESS_DUP_HANDLE</span></span><br><span class="line">        <span class="keyword">if</span> (PreOperInfo-&gt;Parameters-&gt;CreateHandleInformation.OriginalDesiredAccess &amp; <span class="number">0x0040</span>)</span><br><span class="line">            PreOperInfo-&gt;Parameters-&gt;CreateHandleInformation.DesiredAccess &amp;= ~<span class="number">0x0040</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (PreOperInfo-&gt;Operation == OB_OPERATION_HANDLE_DUPLICATE) <span class="comment">// 句柄复制</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果存在退出权限，则取消退出权限PROCESS_TERMINATE</span></span><br><span class="line">        <span class="keyword">if</span> (PreOperInfo-&gt;Parameters-&gt;DuplicateHandleInformation.OriginalDesiredAccess &amp; <span class="number">0x0001</span>)</span><br><span class="line">            PreOperInfo-&gt;Parameters-&gt;DuplicateHandleInformation.DesiredAccess &amp;= ~<span class="number">0x0001</span>;</span><br><span class="line">        <span class="comment">// 如果存在句柄复制权限，则取消句柄复制权限PROCESS_DUP_HANDLE</span></span><br><span class="line">        <span class="keyword">if</span> (PreOperInfo-&gt;Parameters-&gt;DuplicateHandleInformation.OriginalDesiredAccess &amp; <span class="number">0x0040</span>)</span><br><span class="line">            PreOperInfo-&gt;Parameters-&gt;DuplicateHandleInformation.DesiredAccess &amp;= ~<span class="number">0x0040</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> OB_PREOP_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关于句柄复制权限的问题"><a href="#关于句柄复制权限的问题" class="headerlink" title="关于句柄复制权限的问题"></a>关于句柄复制权限的问题</h4><p>在以上的代码中，我们可以看到，只是做自保护防退出，为什么连 <code>句柄复制</code> 权限都要取消？<br>这是因为从WIN8开始，操作系统的 <code>任务管理器</code> 发生了很大的变化，尽管只是取消 <code>退出权限</code> 就能实现<br>自保护，但是之后会发生CPU占用率飙升到100%的现象。</p>
<p>经过用WINDBG和IDA对新的任务管理器进行分析后，发现在结束进程时，任务管理器会首先使用<br><code>DuplicateHandle</code> 函数复制要结束进程的句柄，然后使用 <code>QueueUserWorkItem</code> 线程池函数，来运行<br>退出的代码，就是这个线程池函数导致CPU占用率飙升到了100%。所以在它之前，我们取消 <code>句柄复制</code><br>的权限，任务管理器在复制句柄时失败，就不会再调用线程池函数。</p>
<h4 id="关于获取进程名的问题"><a href="#关于获取进程名的问题" class="headerlink" title="关于获取进程名的问题"></a>关于获取进程名的问题</h4><p>判断进程是不是我们想要保护的进程时，需要获取进程的全路径，一般使用 <code>ZwQueryInformationProcess</code><br>函数来获取进程的全路径。这就产生一个问题，调用这个函数会触发 <code>进程回调</code> 行为，从而再次进入回调函数<br>中，造成了函数调用的重入问题（<code>注：在Win10系统上，已变为从当前回调的下一个回调继续调用，所以就不会再出现</code><br><code>重入的问题。在注册表回调中操作注册表时，也是相同的处理方式，不会出现重入。</code>）</p>
<p>通过查看WRK1.2源码和IDA进行分析，发现这个函数会调用一次 <code>ObReferenceObjectByHandle</code> 函数，正是<br>这个引用句柄的函数导致了重入。接着再往下分析，找到是<code>SeLocateProcessImageName</code> 这个函数读取的进程<br>路径，把 <code>ntoskrnl.exe</code> 拖到PE工具里看一下导出表，正好导出了这个函数，我们直接声明这个函数的定义，<br>就可以使用了，使用这个函数不会触发重入问题。但需要注意的是，我们需要手动释放其返回的内存空间。</p>
<p>另外我们还可以先使用 <code>PsReferenceProcessFilePointer</code> 获取进程的文件对象，然后再根据文件对象使用<br><code>IoQueryFileDosDeviceName</code> 查询对应的路径。因为涉及到磁盘读写操作，查询速度较慢，频繁查询会卡顿，<br>就需要把查询过的EPROCESS缓存起来，加快处理速度。</p>
<h4 id="进程路径中盘符的转换"><a href="#进程路径中盘符的转换" class="headerlink" title="进程路径中盘符的转换"></a>进程路径中盘符的转换</h4><p>在以上操作中获取到的进程路径，有可能并不是我们常见的 <code>C:\\</code> 盘符的形式，<br>而是 <code>\\Device\\HarddiskVolume1\\</code> 这种卷的形式，所以还需要我们对其进行转换<br>在XP中可以使用 <code>RtlVolumeDeviceToDosName</code> 和在VISTA中使用 <code>IoVolumeDeviceToDosName</code><br>来查询设备对象的盘符路径，这里使用的是 <code>查询符号链接</code> 的方式来进行转换 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">WCHAR <span class="title">GetDosNameWideChar</span><span class="params">(PUNICODE_STRING Volume)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    WCHAR Ch = <span class="string">L&#x27;A&#x27;</span>; <span class="comment">// 盘符变量</span></span><br><span class="line">    WCHAR DosBuffer[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;  <span class="comment">// L&quot;\\??\\C:&quot;</span></span><br><span class="line">    UNICODE_STRING DosName = &#123; <span class="number">0</span> &#125;; <span class="comment">// 查询用盘符名称</span></span><br><span class="line">    WCHAR VolumeBuffer[<span class="number">40</span>] = &#123; <span class="number">0</span> &#125;;  <span class="comment">// L&quot;\\Device\\HarddiskVolume1&quot;</span></span><br><span class="line">    UNICODE_STRING VolumeName = &#123; <span class="number">0</span> &#125;; <span class="comment">// 查询用卷标名称</span></span><br><span class="line">    HANDLE LinkHandle = <span class="literal">NULL</span>; <span class="comment">// 卷名查询盘符所用句柄</span></span><br><span class="line">    OBJECT_ATTRIBUTES ObjectAttributes = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    <span class="comment">// 检查参数是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (Volume == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">L&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (Volume-&gt;Buffer == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">L&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">// 初始化 UNICODE_STRING</span></span><br><span class="line">    DosName.Buffer = DosBuffer;</span><br><span class="line">    DosName.Length = <span class="number">0</span>;</span><br><span class="line">    DosName.MaximumLength = <span class="keyword">sizeof</span>(DosBuffer);</span><br><span class="line">    VolumeName.Buffer = VolumeBuffer;</span><br><span class="line">    VolumeName.Length = <span class="number">0</span>;</span><br><span class="line">    VolumeName.MaximumLength = <span class="keyword">sizeof</span>(VolumeBuffer);</span><br><span class="line">    <span class="comment">// 组合盘符名称</span></span><br><span class="line">    RtlCopyMemory(DosName.Buffer, <span class="string">L&quot;\\??\\C:&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">L&quot;\\??\\C:&quot;</span>));</span><br><span class="line">    DosName.Length = <span class="keyword">sizeof</span>(<span class="string">L&quot;\\??\\C:&quot;</span>) - <span class="keyword">sizeof</span>(<span class="string">L&#x27;\0&#x27;</span>);</span><br><span class="line">    <span class="comment">// 检查IRQL是否符合接下来的操作</span></span><br><span class="line">    <span class="keyword">if</span> (KeGetCurrentIrql() &gt; PASSIVE_LEVEL) <span class="keyword">return</span> <span class="string">L&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="comment">// 循环检测盘符</span></span><br><span class="line">    <span class="keyword">for</span> (Ch = <span class="string">L&#x27;A&#x27;</span>; Ch &lt;= <span class="string">L&#x27;Z&#x27;</span>; ++Ch)</span><br><span class="line">    &#123;</span><br><span class="line">        DosName.Buffer[<span class="number">4</span>] = Ch; <span class="comment">// 改变盘符</span></span><br><span class="line">        InitializeObjectAttributes(&amp;ObjectAttributes, &amp;DosName, OBJ_KERNEL_HANDLE, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="comment">// 打开盘符链接名称</span></span><br><span class="line">        Status = ZwOpenSymbolicLinkObject(&amp;LinkHandle, GENERIC_READ, &amp;ObjectAttributes);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">continue</span>; <span class="comment">// 打开失败则跳过</span></span><br><span class="line">        <span class="comment">// 查询盘符链接名称对应的驱动器名称</span></span><br><span class="line">        Status = ZwQuerySymbolicLinkObject(LinkHandle, &amp;VolumeName, <span class="literal">NULL</span>);</span><br><span class="line">        ZwClose(LinkHandle); <span class="comment">// 句柄使用结束</span></span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">continue</span>; <span class="comment">// 查询失败则跳过</span></span><br><span class="line">        <span class="comment">// 比较是不是对应的驱动器名称</span></span><br><span class="line">        <span class="keyword">if</span> (RtlCompareUnicodeString(&amp;VolumeName, Volume, TRUE) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Ch; <span class="comment">// 返回盘符</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">L&#x27;\0&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>在内核中使用APC注入DLL到R3进程(2)</title>
    <url>/2021/01/04/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E4%BD%BF%E7%94%A8APC%E6%B3%A8%E5%85%A5DLL%E5%88%B0R3%E8%BF%9B%E7%A8%8B-2/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>另外还可以在内核中使用APC的方式进行注入，这里参照Github中的例子进行修改<br>内核注入DLL到R3进程：<a href="https://github.com/wbenny/injdrv">https://github.com/wbenny/injdrv</a><br>简化后的代码（推荐）：<a href="https://github.com/GoodstudyChina/APC-injection-x86-x64">https://github.com/GoodstudyChina/APC-injection-x86-x64</a></p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>使用 <code>PsSetCreateProcessNotifyRoutineEx</code> 和 <code>PsSetLoadImageNotifyRoutine</code> 两个通知。<br>在进程通知中，记录路径、PID、已加载模块、是否要注入等信息到链表中，在模块通知中，遍历<br>链表并更新对应已加载模块信息，如果所需的模块已全部加载完毕（触发通知时，模块尚未加载），<br>根据相关标志位信息进行注入（注意只需要注入一次）</p>
<p>注入的内容为APC函数格式的shellcode指令，因为当前线程就在目标进程中，所以不需要切换环境，<br>直接使用 <code>ZwAllocateVirtualMemory</code> 申请可读写执行权限的内存，保存相关shellcode信息，然后<br>使用 <code>KeInsertQueueApc</code> 插入到APC队列中，最后调用 <code>KeTestAlertThread</code> 进入alertable状态</p>
<h4 id="封装APC函数"><a href="#封装APC函数" class="headerlink" title="封装APC函数"></a>封装APC函数</h4><p>关于APC所使用的进程环境设置如下所示，一般总是使用 <code>OriginalApcEnvironment</code> 原始环境，<br>当进程 <code>KeAttachProcess/KeDetachProcess</code> 时，APC环境就会发生变化，可以参考WRK源码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _KAPC_ENVIRONMENT &#123;</span><br><span class="line">    OriginalApcEnvironment = <span class="number">0</span>, <span class="comment">// 原始的进程环境</span></span><br><span class="line">    AttachedApcEnvironment,     <span class="comment">// 挂靠后的进程环境</span></span><br><span class="line">    CurrentApcEnvironment,      <span class="comment">// 当前环境</span></span><br><span class="line">    InsertApcEnvironment        <span class="comment">// 被插入时的环境</span></span><br><span class="line">&#125; KAPC_ENVIRONMENT, *PKAPC_ENVIRONMENT;</span><br></pre></td></tr></table></figure>

<p>关于APC函数参数中功能函数类型的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span><span class="params">(NTAPI *PKNORMAL_ROUTINE)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PVOID NormalContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    PVOID SystemArgument1,</span></span></span><br><span class="line"><span class="function"><span class="params">    PVOID SystemArgument2)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span><span class="params">(NTAPI* PKKERNEL_ROUTINE)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    PRKAPC Apc,</span></span></span><br><span class="line"><span class="function"><span class="params">    PKNORMAL_ROUTINE *NormalRoutine,</span></span></span><br><span class="line"><span class="function"><span class="params">    PVOID *NormalContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    PVOID *SystemArgument1,</span></span></span><br><span class="line"><span class="function"><span class="params">    PVOID *SystemArgument2)</span></span>;</span><br></pre></td></tr></table></figure>

<p>插入APC的函数封装</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID NTAPI <span class="title">InjpApcKernelRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PKAPC Apc,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT PKNORMAL_ROUTINE* NormalRoutine,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT PVOID* NormalContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT PVOID* SystemArgument1,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT PVOID* SystemArgument2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(NormalRoutine);</span><br><span class="line">    UNREFERENCED_PARAMETER(NormalContext);</span><br><span class="line">    UNREFERENCED_PARAMETER(SystemArgument1);</span><br><span class="line">    UNREFERENCED_PARAMETER(SystemArgument2);</span><br><span class="line">    <span class="keyword">if</span> (Apc) ExFreePool(Apc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">InjpInsertQueueApc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN KPROCESSOR_MODE ApcMode,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PKNORMAL_ROUTINE NormalRoutine,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID NormalContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID SystemArgument1,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID SystemArgument2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PKAPC Apc = <span class="literal">NULL</span>;</span><br><span class="line">    BOOLEAN Result = FALSE;</span><br><span class="line">    Apc = ExAllocatePool(NonPagedPool, <span class="keyword">sizeof</span>(KAPC));</span><br><span class="line">    <span class="keyword">if</span> (!Apc)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">    KeInitializeApc(Apc,        <span class="comment">// Apc</span></span><br><span class="line">        PsGetCurrentThread(),   <span class="comment">// Thread</span></span><br><span class="line">        OriginalApcEnvironment, <span class="comment">// Environment</span></span><br><span class="line">        &amp;InjpApcKernelRoutine,  <span class="comment">// KernelRoutine</span></span><br><span class="line">        <span class="literal">NULL</span>,                   <span class="comment">// RundownRoutine</span></span><br><span class="line">        NormalRoutine,          <span class="comment">// NormalRoutine</span></span><br><span class="line">        ApcMode,                <span class="comment">// ApcMode</span></span><br><span class="line">        NormalContext);         <span class="comment">// NormalContext</span></span><br><span class="line">    Result = KeInsertQueueApc(Apc, <span class="comment">// Apc</span></span><br><span class="line">        SystemArgument1,           <span class="comment">// SystemArgument1</span></span><br><span class="line">        SystemArgument2,           <span class="comment">// SystemArgument2</span></span><br><span class="line">        <span class="number">0</span>);                        <span class="comment">// Increment</span></span><br><span class="line">    <span class="keyword">if</span> (!Result)</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePool(Apc);</span><br><span class="line">        <span class="keyword">return</span> STATUS_THREAD_IS_TERMINATING;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="注入的函数"><a href="#注入的函数" class="headerlink" title="注入的函数"></a>注入的函数</h4><p>相关shellcode请自行生成，注意32位系统与64位系统所用shellcode不同</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">INJECT_CONTEXT</span> &#123;</span></span><br><span class="line">    BYTE user_mode_normal_routine[<span class="number">512</span>]; <span class="comment">// shellcode代码</span></span><br><span class="line">    WCHAR dll_full_path[<span class="number">260</span>]; <span class="comment">// 注入的DLL全路径</span></span><br><span class="line">    CHAR procedure_name[<span class="number">64</span>]; <span class="comment">// DLL导出的函数名称</span></span><br><span class="line">    ULONG_PTR ldr_load_dll; <span class="comment">// 当前进程LdrLoadDll地址</span></span><br><span class="line">    ULONG_PTR ldr_get_procedure_address; <span class="comment">// 当前进程LdrGetProcedureAddress地址</span></span><br><span class="line">&#125; INJECT_CONTEXT, *PINJECT_CONTEXT;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">InjpAPCInject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOLEAN IsWow64 = FALSE;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PINJECT_CONTEXT InjectContext = <span class="literal">NULL</span>;</span><br><span class="line">    SIZE_T InjectContextSize = <span class="keyword">sizeof</span>(INJECT_CONTEXT);</span><br><span class="line">    PVOID ApcContext = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID ApcRoutine = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 被系统保护的进程不注入</span></span><br><span class="line">    <span class="keyword">if</span> (PsIsProtectedProcess(PsGetCurrentProcess()))</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="comment">// 检测当前进程是否是Wow程序</span></span><br><span class="line">    IsWow64 = PsGetProcessWow64Process(PsGetCurrentProcess());</span><br><span class="line">    <span class="comment">// 申请可读写执行的内存</span></span><br><span class="line">    Status = ZwAllocateVirtualMemory(</span><br><span class="line">        NtCurrentProcess(), (PVOID*)&amp;InjectContext, <span class="number">0</span>, &amp;InjectContextSize,</span><br><span class="line">        MEM_TOP_DOWN | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">    <span class="comment">// 复制相关信息</span></span><br><span class="line">    ApcContext = InjectContext;</span><br><span class="line">    ApcRoutine = InjectContext-&gt;user_mode_normal_routine;</span><br><span class="line">    <span class="keyword">if</span> (IsWow64)</span><br><span class="line">        RtlCopyMemory(ApcRoutine, ShellCodeWow64, <span class="keyword">sizeof</span>(ShellCodeWow64));</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        RtlCopyMemory(ApcRoutine, ShellCode, <span class="keyword">sizeof</span>(ShellCode));</span><br><span class="line">    wcscpy_s(InjectContext-&gt;dll_full_path, <span class="number">260</span>, DllFullPath);</span><br><span class="line">    strcpy_s(InjectContext-&gt;procedure_name, <span class="number">64</span>, <span class="string">&quot;FuncName&quot;</span>);</span><br><span class="line">    InjectContext-&gt;ldr_load_dll = LdrLoadDll;</span><br><span class="line">    InjectContext-&gt;ldr_get_procedure_address = LdrGetProcedureAddress;</span><br><span class="line">    <span class="comment">// 处理Wow64地址转换</span></span><br><span class="line">    <span class="keyword">if</span> (IsWow64)</span><br><span class="line">        PsWrapApcWow64Thread(&amp;ApcContext, &amp;ApcRoutine);</span><br><span class="line">    <span class="comment">// 插入用户APC函数</span></span><br><span class="line">    Status = InjpInsertQueueApc(</span><br><span class="line">        UserMode, (PKNORMAL_ROUTINE)ApcRoutine, ApcContext, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 插入APC失败 释放空间</span></span><br><span class="line">        ZwFreeVirtualMemory(NtCurrentProcess(), </span><br><span class="line">            (PVOID*)&amp;InjectContext, &amp;InjectContextSize, MEM_RELEASE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 插入APC成功 主动触发alertable</span></span><br><span class="line">        KeTestAlertThread(UserMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>在内核中创建线程注入DLL到R3进程(3)</title>
    <url>/2021/02/23/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5DLL%E5%88%B0R3%E8%BF%9B%E7%A8%8B-3/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>使用通知的方式只能在进程创建的时候注入，而我们想注入一个已经运行的进程时，<br>可以使用与应用层类似的，申请注入shellcode的内存，并创建线程来运行的方式。<br>这里参照 <code>Blackbone</code> 的部分代码进行修改：<a href="https://github.com/DarthTon/Blackbone">https://github.com/DarthTon/Blackbone</a></p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>推荐的方法是获取SSDT表，找到 <code>NtCreateThreadEx</code> 函数来创建线程。在64位系统中获取SSDT的方法，<br>通常是搜索特征码，可以从 <code>Blackbone</code> 中查看，这里暂不讨论。另外 <code>RtlCreateUserThread</code> 函数也<br>可以创建线程，<strong>但好像还涉及 <code>PrevMode</code> 等信息，虽然测试未出现蓝屏现象，这种方法待议</strong>。<br>参见： <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/previousmode">https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/previousmode</a></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">RtlCreateUserThread</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN HANDLE ProcessHandle, <span class="comment">// 目标进程</span></span></span></span><br><span class="line"><span class="function"><span class="params">    IN PSECURITY_DESCRIPTOR SecurityDescriptor OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN BOOLEAN CreateSuspended, <span class="comment">// 创建后是否挂起</span></span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG StackZeroBits OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN SIZE_T StackReserve OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN SIZE_T StackCommit OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID StartAddress, <span class="comment">// 线程函数地址</span></span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID Parameter OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PHANDLE ThreadHandle OPTIONAL,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PCLIENT_ID ClientId OPTIONAL)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这里使用 <code>在内核中获取进程的DLL和导出函数(1)</code> 文章中获取的 <code>WinExec</code> 导出函数为例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 以调用WinExec函数为目标生成的ShellCode</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> AMD64</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ShellCode[] = &#123;</span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xEC</span>, <span class="number">0x28</span>,                                     <span class="comment">// sub rsp,28h</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xBA</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// mov rdx,5</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xB9</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// mov rcx,xx</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// mov rax,xx</span></span><br><span class="line">    <span class="number">0xFF</span>, <span class="number">0xD0</span>,                                                 <span class="comment">// call rax</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x31</span>, <span class="number">0xC0</span>,                                           <span class="comment">// xor rax,rax</span></span><br><span class="line">    <span class="number">0x48</span>, <span class="number">0x83</span>, <span class="number">0xC4</span>, <span class="number">0x28</span>,                                     <span class="comment">// add rsp,28h</span></span><br><span class="line">    <span class="number">0xC3</span> &#125;;                                                     <span class="comment">// ret</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> ShellCode[] = &#123;</span><br><span class="line">    <span class="number">0x68</span>, <span class="number">0x05</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// push 5</span></span><br><span class="line">    <span class="number">0x68</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// push xx</span></span><br><span class="line">    <span class="number">0xB8</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00</span>, <span class="comment">// mov eax,xx</span></span><br><span class="line">    <span class="number">0xFF</span>, <span class="number">0xD0</span>,                   <span class="comment">// call eax</span></span><br><span class="line">    <span class="number">0x33</span>, <span class="number">0xC0</span>,                   <span class="comment">// xor eax,eax</span></span><br><span class="line">    <span class="number">0xC2</span>, <span class="number">0x04</span>, <span class="number">0x00</span> &#125;;           <span class="comment">// ret 4</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>调用的函数如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">InjectExplorerProcess</span><span class="params">(IN PCCHAR RunCmd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    HANDLE ProcessId = <span class="literal">NULL</span>;</span><br><span class="line">    PEPROCESS Process = <span class="literal">NULL</span>;</span><br><span class="line">    KAPC_STATE ApcState = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PEPROCESS CurrProcess = <span class="literal">NULL</span>;</span><br><span class="line">    PUCHAR Buffer = <span class="literal">NULL</span>;</span><br><span class="line">    SIZE_T BufferSize = <span class="number">0</span>;</span><br><span class="line">    SIZE_T RunCmdSize = <span class="number">0</span>;</span><br><span class="line">    HANDLE ThreadHandle = <span class="literal">NULL</span>;</span><br><span class="line">    LARGE_INTEGER Timeout = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PVOID Kernel32Addr = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID WinExecAddr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 检查参数的有效性</span></span><br><span class="line">    <span class="keyword">if</span> (!RunCmd) <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">    RunCmdSize = <span class="built_in">strlen</span>(RunCmd) + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 获取Explorer进程ID</span></span><br><span class="line">    Status = GetExplorerProcessId(&amp;ProcessId);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">return</span> Status;</span><br><span class="line">    <span class="comment">// 检查是否是当前进程</span></span><br><span class="line">    CurrProcess = PsGetCurrentProcess();</span><br><span class="line">    PsLookupProcessByProcessId(ProcessId, &amp;Process);</span><br><span class="line">    <span class="comment">// 检查是否是受保护的进程</span></span><br><span class="line">     <span class="keyword">if</span> (PsIsProtectedProcess(Process))</span><br><span class="line">        <span class="keyword">return</span> STATUS_ACCESS_DENIED;</span><br><span class="line">    <span class="comment">// 附加到目标进程中</span></span><br><span class="line">    <span class="keyword">if</span> (Process != CurrProcess)</span><br><span class="line">        KeStackAttachProcess(Process, &amp;ApcState);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取Kernel32的地址</span></span><br><span class="line">        Kernel32Addr = GetKernel32Address(Process, FALSE);</span><br><span class="line">        <span class="keyword">if</span> (!Kernel32Addr) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 获取WinExec导出函数</span></span><br><span class="line">        WinExecAddr = GetExportFuncAddr(Kernel32Addr, <span class="string">&quot;WinExec&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!WinExecAddr) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 在目标进程中申请内存</span></span><br><span class="line">        BufferSize = <span class="keyword">sizeof</span>(ShellCode) + RunCmdSize;</span><br><span class="line">        Status = ZwAllocateVirtualMemory(</span><br><span class="line">            NtCurrentProcess(), (PVOID)&amp;Buffer, <span class="number">0</span>, &amp;BufferSize,</span><br><span class="line">            MEM_TOP_DOWN | MEM_COMMIT, PAGE_EXECUTE_READWRITE);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 拷贝ShellCode和RunCmd信息</span></span><br><span class="line">        RtlCopyMemory(Buffer, ShellCode, <span class="keyword">sizeof</span>(ShellCode));</span><br><span class="line">        RtlCopyMemory(Buffer + <span class="keyword">sizeof</span>(ShellCode), RunCmd, RunCmdSize);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">        *(PULONG_PTR)(Buffer + <span class="number">16</span>) = (ULONG_PTR)(Buffer + <span class="keyword">sizeof</span>(ShellCode));</span><br><span class="line">        *(PULONG_PTR)(Buffer + <span class="number">26</span>) = (ULONG_PTR)WinExecAddr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        *(PULONG_PTR)(Buffer + <span class="number">6</span>) = (ULONG_PTR)(Buffer + <span class="keyword">sizeof</span>(ShellCode));</span><br><span class="line">        *(PULONG_PTR)(Buffer + <span class="number">11</span>) = (ULONG_PTR)WinExecAddr;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">// 创建用户线程(推荐使用NtCreateThreadEx函数)</span></span><br><span class="line">        Status = RtlCreateUserThread(NtCurrentProcess(),</span><br><span class="line">            <span class="literal">NULL</span>, FALSE, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, Buffer, <span class="literal">NULL</span>, &amp;ThreadHandle, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (NT_SUCCESS(Status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 等待线程结束</span></span><br><span class="line">            Timeout.QuadPart = <span class="number">-10L</span>L * <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">3</span>; <span class="comment">// 3秒</span></span><br><span class="line">            ZwWaitForSingleObject(ThreadHandle, FALSE, &amp;Timeout);</span><br><span class="line">            ZwClose(ThreadHandle);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 释放申请的空间</span></span><br><span class="line">    <span class="keyword">if</span> (Buffer)</span><br><span class="line">    &#123;</span><br><span class="line">        ZwFreeVirtualMemory(</span><br><span class="line">            NtCurrentProcess(), &amp;Buffer, &amp;BufferSize, MEM_RELEASE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分离目标进程</span></span><br><span class="line">    <span class="keyword">if</span> (Process != CurrProcess)</span><br><span class="line">        KeUnstackDetachProcess(&amp;ApcState);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>在内核中获取SSDT地址和函数索引(2)</title>
    <url>/2021/06/23/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E8%8E%B7%E5%8F%96SSDT%E5%9C%B0%E5%9D%80%E5%92%8C%E5%87%BD%E6%95%B0%E7%B4%A2%E5%BC%95-2/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在32位系统中SSDT已经直接导出，这里主要是在64位系统中获取SSDT地址，<br>同样参照 <code>Blackbone</code> 的部分代码进行修改：<a href="https://github.com/DarthTon/Blackbone">https://github.com/DarthTon/Blackbone</a></p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><h5 id="1-获取系统模块地址"><a href="#1-获取系统模块地址" class="headerlink" title="1.获取系统模块地址"></a>1.获取系统模块地址</h5><p>与上一篇文章中获取进程的DLL类似，这里使用 <code>ZwQuerySystemInformation</code> 函数，<br>指定其class参数为11<code>(SystemModuleInformation)</code> 时，可以获取系统全部模块的数组</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">ZwQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG SystemInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT PVOID SystemInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG SystemInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PULONG ReturnLength OPTIONAL)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对应数组的结构体如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_MODULE_INFO</span> &#123;</span></span><br><span class="line">    HANDLE Section;</span><br><span class="line">    PVOID MappedBase;</span><br><span class="line">    PVOID ImageBase;</span><br><span class="line">    ULONG ImageSize;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadOrderIndex;</span><br><span class="line">    USHORT InitOrderIndex;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT OffsetToFileName;</span><br><span class="line">    UCHAR FullPathName[<span class="number">256</span>];</span><br><span class="line">&#125; PROCESS_MODULE_INFO, *PPROCESS_MODULE_INFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PROCESS_MODULES</span> &#123;</span></span><br><span class="line">    ULONG NumberOfModules;</span><br><span class="line">    PROCESS_MODULE_INFO Modules[<span class="number">1</span>];</span><br><span class="line">&#125; PROCESS_MODULES, *PPROCESS_MODULES;</span><br></pre></td></tr></table></figure>

<p>为了查找内核模块，我们使用 <code>&quot;NtOpenFile&quot;</code> 函数的地址作为定位条件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ULONG gKernelSize = <span class="number">0</span>;</span><br><span class="line">PVOID gKernelAddr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">PVOID <span class="title">GetKernelAddress</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    UNICODE_STRING FuncName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PUCHAR FuncAddr = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG RetLen = <span class="number">0</span>;</span><br><span class="line">    PPROCESS_MODULES ProcMods = <span class="literal">NULL</span>;</span><br><span class="line">    PPROCESS_MODULE_INFO ModInfo = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (gKernelAddr)</span><br><span class="line">        <span class="keyword">return</span> gKernelAddr;</span><br><span class="line">    <span class="comment">// 获取NtOpenFile函数的地址</span></span><br><span class="line">    RtlInitUnicodeString(&amp;FuncName, <span class="string">L&quot;NtOpenFile&quot;</span>);</span><br><span class="line">    FuncAddr = (PUCHAR)MmGetSystemRoutineAddress(&amp;FuncName);</span><br><span class="line">    <span class="keyword">if</span> (!FuncAddr)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 查询需要的大小 SystemModuleInformation 11</span></span><br><span class="line">    Status = ZwQuerySystemInformation(<span class="number">11</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;RetLen);</span><br><span class="line">    <span class="keyword">if</span> (Status != STATUS_INFO_LENGTH_MISMATCH)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 申请内存空间</span></span><br><span class="line">    ProcMods = (PPROCESS_MODULES)ExAllocatePoolWithTag(NonPagedPool, RetLen * 2, &#x27;ssss&#x27;);</span><br><span class="line">    <span class="keyword">if</span> (!ProcMods)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    RtlZeroMemory(ProcMods, RetLen * <span class="number">2</span>);</span><br><span class="line">    <span class="comment">// 查询系统模块的信息</span></span><br><span class="line">    Status = ZwQuerySystemInformation(<span class="number">11</span>, ProcMods, RetLen * <span class="number">2</span>, &amp;RetLen);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePoolWithTag(ProcMods, POOL_TAG);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环匹配NtOpenFile地址是否在目标模块中</span></span><br><span class="line">    ModInfo = ProcMods-&gt;Modules;</span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; ProcMods-&gt;NumberOfModules; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((FuncAddr &gt;= (PUCHAR)ModInfo[i].ImageBase) &amp;&amp;</span><br><span class="line">            (FuncAddr &lt; (PUCHAR)ModInfo[i].ImageBase + ModInfo[i].ImageSize))</span><br><span class="line">        &#123;</span><br><span class="line">            gKernelAddr = ModInfo[i].ImageBase;</span><br><span class="line">            gKernelSize = ModInfo[i].ImageSize;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ExFreePoolWithTag(ProcMods, POOL_TAG);</span><br><span class="line">    <span class="keyword">return</span> gKernelAddr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-获取SSDT地址"><a href="#2-获取SSDT地址" class="headerlink" title="2.获取SSDT地址"></a>2.获取SSDT地址</h5><p>使用搜索特征码的方式查找，特征码搜索函数如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SearchPattern</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PUCHAR Pattern, IN UCHAR Wildcard, IN ULONG Len,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PUCHAR BaseAddr, IN ULONG Size, OUT PUCHAR* Target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Pattern || !BaseAddr ||!Target)</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="comment">// 循环匹配特征码</span></span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; (Size - Len); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        BOOLEAN Found = TRUE;</span><br><span class="line">        <span class="keyword">for</span> (ULONG j = <span class="number">0</span>; j &lt; Len; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ((Pattern[j] != Wildcard) &amp;&amp; (Pattern[j] != BaseAddr[i + j]))</span><br><span class="line">            &#123;</span><br><span class="line">                Found = FALSE;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否符合</span></span><br><span class="line">        <span class="keyword">if</span> (Found)</span><br><span class="line">        &#123;</span><br><span class="line">            *Target = BaseAddr + i;</span><br><span class="line">            <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在WIN7中，使用 <code>__readmsr(0xC0000082)</code> 读取 <code>C0000082</code> 寄存器，得到 <code>KiSystemCall64</code><br>的地址，然后再搜索 <code>4C8D15</code> 字节码，就可以找到 <code>KeServiceDescriptorTable</code> 的地址，但是<br>在WIN10中有变化，所以我们这里改为，在代码段中搜索带通配符的特征码来定位SSDT地址，<br>需要在上篇文章中定义的相关PE结构体信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_SERVICE_TABLE</span> &#123;</span></span><br><span class="line">    PULONG_PTR ServiceTableBase;</span><br><span class="line">    PULONG ServiceCounterTableBase;</span><br><span class="line">    ULONG_PTR NumberOfServices;</span><br><span class="line">    PUCHAR ParamTableBase;</span><br><span class="line">&#125; SYSTEM_SERVICE_TABLE, *PSYSTEM_SERVICE_TABLE;</span><br><span class="line">PSYSTEM_SERVICE_TABLE gSsdtAddr = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">PSYSTEM_SERVICE_TABLE <span class="title">GetSSDTAddress</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PUCHAR KernelAddr = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_DOS_HDR DosHdr = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HDR64 NtHdr64 = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_SECTION_HDR SecHdr = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">if</span> (gSsdtAddr)</span><br><span class="line">        <span class="keyword">return</span> gSsdtAddr;</span><br><span class="line">    <span class="comment">// 获取内核模块地址</span></span><br><span class="line">    KernelAddr = GetKernelAddress();</span><br><span class="line">    <span class="keyword">if</span> (!KernelAddr)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 检测DOS头是否匹配</span></span><br><span class="line">    DosHdr = (PIMAGE_DOS_HDR)KernelAddr;</span><br><span class="line">    <span class="keyword">if</span> (DosHdr-&gt;e_magic != IMAGE_DOS_SIGN)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 检测NT头是否匹配</span></span><br><span class="line">    NtHdr64 = (PIMAGE_NT_HDR64)(KernelAddr + DosHdr-&gt;e_lfanew);</span><br><span class="line">    <span class="keyword">if</span> (NtHdr64-&gt;Signature != IMAGE_NT_SIGN)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 检测是不是64位PE文件</span></span><br><span class="line">    <span class="keyword">if</span> (NtHdr64-&gt;OptHeader64.Magic != IMAGE_NT_OPT_HDR64_MAGIC)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 循环遍历代码段</span></span><br><span class="line">    SecHdr = (PIMAGE_SECTION_HDR)(NtHdr64 + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (USHORT i = <span class="number">0</span>; i &lt; NtHdr64-&gt;FileHeader.NumberOfSections; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((SecHdr[i].Characteristics &amp; IMAGE_SCN_MEM_NOT_PAGED) &amp;&amp;</span><br><span class="line">            (SecHdr[i].Characteristics &amp; IMAGE_SCN_MEM_EXECUTE) &amp;&amp;</span><br><span class="line">            !(SecHdr[i].Characteristics &amp; IMAGE_SCN_MEM_DISCARDABLE) &amp;&amp;</span><br><span class="line">            (*(PULONG)SecHdr[i].Name != &#x27;TINI&#x27;) &amp;&amp;</span><br><span class="line">            (*(PULONG)SecHdr[i].Name != &#x27;EGAP&#x27;))</span><br><span class="line">        &#123;</span><br><span class="line">            PUCHAR Target = <span class="literal">NULL</span>;</span><br><span class="line">            UCHAR Pattern[] = <span class="string">&quot;\x4C\x8D\x15\xcc\xcc\xcc\xcc\x4C\x8D\x1D\xcc\xcc\xcc\xcc\xF7&quot;</span>;</span><br><span class="line">            Status = SearchPattern(Pattern, <span class="number">0xCC</span>, <span class="keyword">sizeof</span>(Pattern) - <span class="number">1</span>,</span><br><span class="line">                KernelAddr + SecHdr[i].VirtualAddress, SecHdr[i].Misc.VirtualSize, &amp;Target);</span><br><span class="line">            <span class="keyword">if</span> (NT_SUCCESS(Status))</span><br><span class="line">            &#123;</span><br><span class="line">                gSsdtAddr = (PSYSTEM_SERVICE_TABLE)(Target + *(PULONG)(Target + <span class="number">3</span>) + <span class="number">7</span>);</span><br><span class="line">                <span class="keyword">return</span> gSsdtAddr;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-获取函数的索引"><a href="#3-获取函数的索引" class="headerlink" title="3.获取函数的索引"></a>3.获取函数的索引</h5><p>从应用层API进入内核时，通过调用对应SSDT表中的索引，来调用对应函数，<br>这里借助于32位的 <code>ntdll.dll</code> 中导出的函数，根据字节码 <code>B8</code> 获取调用号，<br>要需要在上篇文章中获取导出函数的函数 <code>GetExportFuncAddr</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">GetSSDTEntryByNtdll</span><span class="params">(IN PCSTR name)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hSection = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID DllBase = <span class="literal">NULL</span>;</span><br><span class="line">    SIZE_T ViewSize = <span class="number">0</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    IO_STATUS_BLOCK IoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OBJECT_ATTRIBUTES ObjAttrib = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UNICODE_STRING NtDllName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PUCHAR FuncAddr = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG Index = <span class="number">0</span>;</span><br><span class="line">    PVOID KernelAddr = <span class="literal">NULL</span>;</span><br><span class="line">    PSYSTEM_SERVICE_TABLE SSDTAddr = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 获取32位的ntdll.dll</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">    RtlInitUnicodeString(&amp;NtDllName, <span class="string">L&quot;\\SystemRoot\\SysWOW64\\ntdll.dll&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    RtlInitUnicodeString(&amp;NtDllName, <span class="string">L&quot;\\SystemRoot\\System32\\ntdll.dll&quot;</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">// 打开ntdll.dll并进行映射</span></span><br><span class="line">    InitializeObjectAttributes(&amp;ObjAttrib, &amp;NtDllName,</span><br><span class="line">        OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    Status = ZwOpenFile(&amp;hFile, FILE_GENERIC_READ, &amp;ObjAttrib,</span><br><span class="line">        &amp;IoStatus, FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    InitializeObjectAttributes(&amp;ObjAttrib, <span class="literal">NULL</span>, OBJ_KERNEL_HANDLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    Status = ZwCreateSection(&amp;hSection,</span><br><span class="line">        SECTION_MAP_READ, &amp;ObjAttrib, <span class="number">0</span>, PAGE_READONLY, <span class="number">0x01000000</span>, hFile);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        ZwClose(hFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Status = ZwMapViewOfSection(hSection, ZwCurrentProcess(),</span><br><span class="line">        &amp;DllBase, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;ViewSize, ViewShare, MEM_TOP_DOWN, PAGE_READONLY);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        ZwClose(hSection);</span><br><span class="line">        ZwClose(hFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取导出函数的地址</span></span><br><span class="line">    FuncAddr = GetExportFuncAddr(DllBase, name);</span><br><span class="line">    <span class="keyword">if</span> (!FuncAddr)</span><br><span class="line">    &#123;</span><br><span class="line">        ZwUnmapViewOfSection(ZwCurrentProcess(), DllBase);</span><br><span class="line">        ZwClose(hSection);</span><br><span class="line">        ZwClose(hFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取调用号 字节码B8xxxxxxxx</span></span><br><span class="line">    Index = *(PULONG)(FuncAddr + <span class="number">1</span>);</span><br><span class="line">    ZwUnmapViewOfSection(ZwCurrentProcess(), DllBase);</span><br><span class="line">    ZwClose(hSection);</span><br><span class="line">    ZwClose(hFile);</span><br><span class="line">    <span class="comment">// 根据索引获取对应地址</span></span><br><span class="line">    KernelAddr = GetKernelAddress();</span><br><span class="line">    SSDTAddr = GetSSDTAddress();</span><br><span class="line">    <span class="keyword">if</span> (KernelAddr &amp;&amp; SSDTAddr)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Index &gt; SSDTAddr-&gt;NumberOfServices)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> (PVOID)((PUCHAR)SSDTAddr-&gt;ServiceTableBase +</span><br><span class="line">            (((PLONG)SSDTAddr-&gt;ServiceTableBase)[Index] &gt;&gt; <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>在内核中获取进程的DLL和导出函数(1)</title>
    <url>/2021/03/08/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E5%9C%A8%E5%86%85%E6%A0%B8%E4%B8%AD%E8%8E%B7%E5%8F%96%E8%BF%9B%E7%A8%8B%E7%9A%84DLL%E5%92%8C%E5%AF%BC%E5%87%BA%E5%87%BD%E6%95%B0-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在很多情况下，我们需要获取某进程所加载的DLL信息，以及DLL中的导出函数地址，<br>这里参照 <code>Blackbone</code> 的部分代码进行修改：<a href="https://github.com/DarthTon/Blackbone">https://github.com/DarthTon/Blackbone</a></p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><h5 id="1-获取进程ID"><a href="#1-获取进程ID" class="headerlink" title="1.获取进程ID"></a>1.获取进程ID</h5><p>在驱动中遍历进程需要使用 <code>ZwQuerySystemInformation</code> 函数，指定其class参数为5<br><code>(SystemProcessesAndThreadsInformation)</code> 时，可以获取一个全部进程的快照链表</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">ZwQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG SystemInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT PVOID SystemInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG SystemInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PULONG ReturnLength OPTIONAL)</span></span>;</span><br></pre></td></tr></table></figure>

<p>对应快照链表的结构体如下所示，这里只定义出了一些关键参数名称</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_PROCESS_INFO</span> &#123;</span></span><br><span class="line">    ULONG NextEntryOffset; <span class="comment">// 下个节点</span></span><br><span class="line">    ULONG NumberOfThreads;</span><br><span class="line">    UCHAR Reserved1[<span class="number">48</span>];</span><br><span class="line">    UNICODE_STRING ImageName; <span class="comment">// 进程名</span></span><br><span class="line">    KPRIORITY BasePriority;</span><br><span class="line">    HANDLE UniqueProcessId; <span class="comment">// 进程PID</span></span><br><span class="line">    PVOID Reserved2;</span><br><span class="line">    ULONG HandleCount;</span><br><span class="line">    ULONG SessionId;</span><br><span class="line">    PVOID Reserved3;</span><br><span class="line">    SIZE_T PeakVirtualSize;</span><br><span class="line">    SIZE_T VirtualSize;</span><br><span class="line">    ULONG Reserved4;</span><br><span class="line">    SIZE_T PeakWorkingSetSize;</span><br><span class="line">    SIZE_T WorkingSetSize;</span><br><span class="line">    PVOID Reserved5;</span><br><span class="line">    SIZE_T QuotaPagedPoolUsage;</span><br><span class="line">    PVOID Reserved6;</span><br><span class="line">    SIZE_T QuotaNonPagedPoolUsage;</span><br><span class="line">    SIZE_T PagefileUsage;</span><br><span class="line">    SIZE_T PeakPagefileUsage;</span><br><span class="line">    SIZE_T PrivatePageCount;</span><br><span class="line">    LARGE_INTEGER Reserved7[<span class="number">6</span>];</span><br><span class="line">&#125; SYSTEM_PROCESS_INFO, *PSYSTEM_PROCESS_INFO;</span><br></pre></td></tr></table></figure>

<p>这里以 <code>explorer.exe</code> 进程为例，获取其PID信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">GetExplorerProcessId</span><span class="params">(OUT HANDLE *ProcessId)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG RetLen = <span class="number">0</span>;</span><br><span class="line">    PVOID Buffer = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PSYSTEM_PROCESS_INFO ProcInfo = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 查询所有进程信息</span></span><br><span class="line">    <span class="keyword">if</span> (!ProcessId) <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="comment">// SystemProcessesAndThreadsInformation 5</span></span><br><span class="line">    Status = ZwQuerySystemInformation(<span class="number">5</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;RetLen);</span><br><span class="line">    <span class="keyword">if</span> (Status != STATUS_INFO_LENGTH_MISMATCH) <span class="keyword">return</span> Status;</span><br><span class="line">    Buffer = ExAllocatePool(NonPagedPoolNx, RetLen * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Buffer) <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">    Status = ZwQuerySystemInformation(<span class="number">5</span>, Buffer, RetLen * <span class="number">2</span>, &amp;RetLen);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePool(Buffer);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环遍历进程链表</span></span><br><span class="line">    Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    ProcInfo = (PSYSTEM_PROCESS_INFO)Buffer;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 因为explorer.exe不在会话0中</span></span><br><span class="line">        <span class="keyword">if</span> (ProcInfo-&gt;SessionId &amp;&amp; (ProcInfo-&gt;UniqueProcessId &gt; (HANDLE)<span class="number">4</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ProcInfo-&gt;ImageName.Buffer &amp;&amp; ProcInfo-&gt;ImageName.Length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 对比进程名称</span></span><br><span class="line">                <span class="keyword">if</span> (!_wcsnicmp(ProcInfo-&gt;ImageName.Buffer,</span><br><span class="line">                    <span class="string">L&quot;explorer.exe&quot;</span>, ProcInfo-&gt;ImageName.Length / <span class="number">2</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    *ProcessId = ProcInfo-&gt;UniqueProcessId;</span><br><span class="line">                    Status = STATUS_SUCCESS;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ProcInfo-&gt;NextEntryOffset) <span class="keyword">break</span>;</span><br><span class="line">        ProcInfo = (PSYSTEM_PROCESS_INFO)(</span><br><span class="line">            (PCHAR)ProcInfo + ProcInfo-&gt;NextEntryOffset);</span><br><span class="line">    &#125;</span><br><span class="line">    ExFreePool(Buffer);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-获取DLL地址"><a href="#2-获取DLL地址" class="headerlink" title="2.获取DLL地址"></a>2.获取DLL地址</h5><p>进程所加载的DLL列表在 <code>PEB-&gt;LDR</code> 中保存，我们可以遍历LDR链表来查询DLL模块地址，<br>注意：在驱动中访问应用层地址，必须加 <code>try/except</code> 和 <code>ProbeForRead/Write</code> 来检测有效性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 64位PEB相关结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA</span> &#123;</span></span><br><span class="line">    ULONG Length;</span><br><span class="line">    UCHAR Initialized;</span><br><span class="line">    PVOID SsHandle;</span><br><span class="line">    LIST_ENTRY InLoadOrderModuleList;</span><br><span class="line">    LIST_ENTRY InMemoryOrderModuleList;</span><br><span class="line">    LIST_ENTRY InInitializationOrderModuleList;</span><br><span class="line">&#125; PEB_LDR_DATA, *PPEB_LDR_DATA;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;</span><br><span class="line">    UNICODE_STRING BaseDllName;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT TlsIndex;</span><br><span class="line">    LIST_ENTRY HashLinks;</span><br><span class="line">    ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB</span> &#123;</span></span><br><span class="line">    UCHAR InheritedAddressSpace;</span><br><span class="line">    UCHAR ReadImageFileExecOptions;</span><br><span class="line">    UCHAR BeingDebugged;</span><br><span class="line">    UCHAR BitField;</span><br><span class="line">    PVOID Mutant;</span><br><span class="line">    PVOID ImageBaseAddress;</span><br><span class="line">    PPEB_LDR_DATA Ldr;</span><br><span class="line">    PVOID ProcessParameters;</span><br><span class="line">    PVOID SubSystemData;</span><br><span class="line">    PVOID ProcessHeap;</span><br><span class="line">    PVOID FastPebLock;</span><br><span class="line">    PVOID AtlThunkSListPtr;</span><br><span class="line">    PVOID IFEOKey;</span><br><span class="line">    PVOID CrossProcessFlags;</span><br><span class="line">    PVOID UserSharedInfoPtr;</span><br><span class="line">    ULONG SystemReserved;</span><br><span class="line">    ULONG AtlThunkSListPtr32;</span><br><span class="line">    PVOID ApiSetMap;</span><br><span class="line">&#125; PEB, *PPEB;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 32位PEB相关结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB_LDR_DATA32</span> &#123;</span></span><br><span class="line">    ULONG Length;</span><br><span class="line">    UCHAR Initialized;</span><br><span class="line">    ULONG SsHandle;</span><br><span class="line">    LIST_ENTRY32 InLoadOrderModuleList;</span><br><span class="line">    LIST_ENTRY32 InMemoryOrderModuleList;</span><br><span class="line">    LIST_ENTRY32 InInitializationOrderModuleList;</span><br><span class="line">&#125; PEB_LDR_DATA32, *PPEB_LDR_DATA32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY32</span> &#123;</span></span><br><span class="line">    LIST_ENTRY32 InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY32 InMemoryOrderLinks;</span><br><span class="line">    LIST_ENTRY32 InInitializationOrderLinks;</span><br><span class="line">    ULONG DllBase;</span><br><span class="line">    ULONG EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING32 FullDllName;</span><br><span class="line">    UNICODE_STRING32 BaseDllName;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT TlsIndex;</span><br><span class="line">    LIST_ENTRY32 HashLinks;</span><br><span class="line">    ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY32, *PLDR_DATA_TABLE_ENTRY32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">PEB32</span> &#123;</span></span><br><span class="line">    UCHAR InheritedAddressSpace;</span><br><span class="line">    UCHAR ReadImageFileExecOptions;</span><br><span class="line">    UCHAR BeingDebugged;</span><br><span class="line">    UCHAR BitField;</span><br><span class="line">    ULONG Mutant;</span><br><span class="line">    ULONG ImageBaseAddress;</span><br><span class="line">    ULONG Ldr;</span><br><span class="line">    ULONG ProcessParameters;</span><br><span class="line">    ULONG SubSystemData;</span><br><span class="line">    ULONG ProcessHeap;</span><br><span class="line">    ULONG FastPebLock;</span><br><span class="line">    ULONG AtlThunkSListPtr;</span><br><span class="line">    ULONG IFEOKey;</span><br><span class="line">    ULONG CrossProcessFlags;</span><br><span class="line">    ULONG UserSharedInfoPtr;</span><br><span class="line">    ULONG SystemReserved;</span><br><span class="line">    ULONG AtlThunkSListPtr32;</span><br><span class="line">    ULONG ApiSetMap;</span><br><span class="line">&#125; PEB32, *PPEB32;</span><br></pre></td></tr></table></figure>

<p>需要用到的已导出但未文档化相关函数的声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSYSAPI BOOLEAN NTAPI <span class="title">PsIsProtectedProcess</span><span class="params">(IN PEPROCESS Process)</span></span>; <span class="comment">// 检测进程是否受保护</span></span><br><span class="line"><span class="function">NTSYSAPI PVOID NTAPI <span class="title">PsGetProcessPeb</span><span class="params">(IN PEPROCESS Process)</span></span>; <span class="comment">// 获取进程的PEB</span></span><br><span class="line"><span class="function">NTSYSAPI PVOID NTAPI <span class="title">PsGetProcessWow64Process</span><span class="params">(IN PEPROCESS Process)</span></span>; <span class="comment">// 获取WOW64进程的PEB</span></span><br></pre></td></tr></table></figure>

<p>这里以获取 <code>explorer.exe</code> 程序的 <code>kernel32.dll</code> 模块地址为例，需要注意的是：<br>遍历某进程的模块，需要先 <code>KeStackAttachProcess</code> 到目标进程中，但是受保护的进程不能Attach，<br>访问 <code>PEB</code> 的成员信息，要使用 <code>__try&#123;&#125; __except(EXCEPTION_EXECUTE_HANDLER)&#123;&#125;</code> 来检测有效性</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">GetKernel32Address</span><span class="params">(IN PEPROCESS Process, IN BOOLEAN IsWow64)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    LARGE_INTEGER Timeout = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    __try &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">        <span class="keyword">if</span> (IsWow64)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 在64位进程中遍历WOW64模块</span></span><br><span class="line">            PLIST_ENTRY32 ListEntry32 = <span class="literal">NULL</span>;</span><br><span class="line">            PPEB_LDR_DATA32 PebLdrData32 = <span class="literal">NULL</span>;</span><br><span class="line">            PLDR_DATA_TABLE_ENTRY32 TableEntry32 = <span class="literal">NULL</span>;</span><br><span class="line">            PPEB32 Peb32 = (PPEB32)PsGetProcessWow64Process(Process);</span><br><span class="line">            <span class="keyword">if</span> (!Peb32) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 等待Ldr已初始化完毕</span></span><br><span class="line">            Timeout.QuadPart = <span class="number">-10L</span>L * <span class="number">1000</span> * <span class="number">250</span>; <span class="comment">// 250毫秒</span></span><br><span class="line">            <span class="keyword">for</span> (INT i = <span class="number">0</span>; (!Peb32-&gt;Ldr) &amp;&amp; (i &lt; <span class="number">10</span>); i++)</span><br><span class="line">                KeDelayExecutionThread(KernelMode, FALSE, &amp;Timeout);</span><br><span class="line">            <span class="keyword">if</span> (!Peb32-&gt;Ldr) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 遍历已加载模块列表(注意多线程竞争问题)</span></span><br><span class="line">            <span class="comment">// 在R3中是用快照的方式获取，其中使用的是临界区</span></span><br><span class="line">            PebLdrData32 = (PPEB_LDR_DATA32)Peb32-&gt;Ldr;</span><br><span class="line">            ListEntry32 = (PLIST_ENTRY32)PebLdrData32-&gt;InLoadOrderModuleList.Flink;</span><br><span class="line">            <span class="keyword">while</span> (ListEntry32 != &amp;PebLdrData32-&gt;InLoadOrderModuleList)</span><br><span class="line">            &#123;</span><br><span class="line">                TableEntry32 = CONTAINING_RECORD(</span><br><span class="line">                    ListEntry32, LDR_DATA_TABLE_ENTRY32, InLoadOrderLinks);</span><br><span class="line">                <span class="keyword">if</span> (TableEntry32-&gt;BaseDllName.Buffer &amp;&amp; TableEntry32-&gt;BaseDllName.Length)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 对比模块名称</span></span><br><span class="line">                    <span class="keyword">if</span> (!_wcsnicmp((PWCHAR)TableEntry32-&gt;BaseDllName.Buffer,</span><br><span class="line">                        <span class="string">L&quot;Kernel32.dll&quot;</span>, TableEntry32-&gt;BaseDllName.Length / <span class="number">2</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> (PVOID)TableEntry32-&gt;DllBase;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ListEntry32 = (PLIST_ENTRY32)ListEntry32-&gt;Flink;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">#endif</span><br><span class="line">            <span class="comment">// 获取进程的PEB信息</span></span><br><span class="line">            PLIST_ENTRY ListEntry = <span class="literal">NULL</span>;</span><br><span class="line">            PPEB_LDR_DATA PebLdrData = <span class="literal">NULL</span>;</span><br><span class="line">            PLDR_DATA_TABLE_ENTRY TableEntry = <span class="literal">NULL</span>;</span><br><span class="line">            PPEB Peb = PsGetProcessPeb(Process);</span><br><span class="line">            <span class="keyword">if</span> (!Peb) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> AMD64</span></span><br><span class="line">            UNREFERENCED_PARAMETER(IsWow64);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            <span class="comment">// 等待Ldr已初始化完毕</span></span><br><span class="line">            Timeout.QuadPart = <span class="number">-10L</span>L * <span class="number">1000</span> * <span class="number">250</span>; <span class="comment">// 250毫秒</span></span><br><span class="line">            <span class="keyword">for</span> (INT i = <span class="number">0</span>; (!Peb-&gt;Ldr) &amp;&amp; (i &lt; <span class="number">10</span>); i++)</span><br><span class="line">                KeDelayExecutionThread(KernelMode, FALSE, &amp;Timeout);</span><br><span class="line">            <span class="keyword">if</span> (!Peb-&gt;Ldr) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            <span class="comment">// 遍历已加载模块列表(注意多线程竞争问题)</span></span><br><span class="line">            <span class="comment">// 在R3中是用快照的方式获取，其中使用的是临界区</span></span><br><span class="line">            PebLdrData = (PPEB_LDR_DATA)Peb-&gt;Ldr;</span><br><span class="line">            ListEntry = (PLIST_ENTRY)PebLdrData-&gt;InLoadOrderModuleList.Flink;</span><br><span class="line">            <span class="keyword">while</span> (ListEntry != &amp;PebLdrData-&gt;InLoadOrderModuleList)</span><br><span class="line">            &#123;</span><br><span class="line">                TableEntry = CONTAINING_RECORD(</span><br><span class="line">                    ListEntry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);</span><br><span class="line">                <span class="keyword">if</span> (TableEntry-&gt;BaseDllName.Buffer &amp;&amp; TableEntry-&gt;BaseDllName.Length)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// 对比模块名称</span></span><br><span class="line">                    <span class="keyword">if</span> (!_wcsnicmp(TableEntry-&gt;BaseDllName.Buffer,</span><br><span class="line">                        <span class="string">L&quot;Kernel32.dll&quot;</span>, TableEntry-&gt;BaseDllName.Length / <span class="number">2</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">return</span> (PVOID)TableEntry-&gt;DllBase;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ListEntry = (PLIST_ENTRY)ListEntry-&gt;Flink;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> AMD64</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-获取导出函数"><a href="#3-获取导出函数" class="headerlink" title="3.获取导出函数"></a>3.获取导出函数</h5><p>获取导出表的信息需要解析PE文件结构，如下为相关定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DOS_SIGN 0x5A4D     <span class="comment">// MZ</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_NT_SIGN 0x00004550  <span class="comment">// PE00</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_NT_OPT_HDR32_MAGIC 0x10B <span class="comment">// 32位PE</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_NT_OPT_HDR64_MAGIC 0x20B <span class="comment">// 64位PE</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HDR</span> &#123;</span></span><br><span class="line">    USHORT e_magic;</span><br><span class="line">    USHORT e_cblp;</span><br><span class="line">    USHORT e_cp;</span><br><span class="line">    USHORT e_crlc;</span><br><span class="line">    USHORT e_cparhdr;</span><br><span class="line">    USHORT e_minalloc;</span><br><span class="line">    USHORT e_maxalloc;</span><br><span class="line">    USHORT e_ss;</span><br><span class="line">    USHORT e_sp;</span><br><span class="line">    USHORT e_csum;</span><br><span class="line">    USHORT e_ip;</span><br><span class="line">    USHORT e_cs;</span><br><span class="line">    USHORT e_lfarlc;</span><br><span class="line">    USHORT e_ovno;</span><br><span class="line">    USHORT e_res[<span class="number">4</span>];</span><br><span class="line">    USHORT e_oemid;</span><br><span class="line">    USHORT e_oeminfo;</span><br><span class="line">    USHORT e_res2[<span class="number">10</span>];</span><br><span class="line">    LONG e_lfanew;</span><br><span class="line">&#125; IMAGE_DOS_HDR, *PIMAGE_DOS_HDR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HDR</span> &#123;</span></span><br><span class="line">    USHORT Machine;</span><br><span class="line">    USHORT NumberOfSections;</span><br><span class="line">    ULONG TimeDateStamp;</span><br><span class="line">    ULONG PointerToSymbolTable;</span><br><span class="line">    ULONG NumberOfSymbols;</span><br><span class="line">    USHORT SizeOfOptionalHeader;</span><br><span class="line">    USHORT Characteristics;</span><br><span class="line">&#125; IMAGE_FILE_HDR, *PIMAGE_FILE_HDR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIR</span> &#123;</span></span><br><span class="line">    ULONG VirtualAddress;</span><br><span class="line">    ULONG Size;</span><br><span class="line">&#125; IMAGE_DATA_DIR, *PIMAGE_DATA_DIR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPT_HDR64</span> &#123;</span></span><br><span class="line">    USHORT Magic;</span><br><span class="line">    UCHAR MajorLinkerVersion;</span><br><span class="line">    UCHAR MinorLinkerVersion;</span><br><span class="line">    ULONG SizeOfCode;</span><br><span class="line">    ULONG SizeOfInitializedData;</span><br><span class="line">    ULONG SizeOfUninitializedData;</span><br><span class="line">    ULONG AddressOfEntryPoint;</span><br><span class="line">    ULONG BaseOfCode;</span><br><span class="line">    ULONGLONG ImageBase;</span><br><span class="line">    ULONG SectionAlignment;</span><br><span class="line">    ULONG FileAlignment;</span><br><span class="line">    USHORT MajorOperatingSystemVersion;</span><br><span class="line">    USHORT MinorOperatingSystemVersion;</span><br><span class="line">    USHORT MajorImageVersion;</span><br><span class="line">    USHORT MinorImageVersion;</span><br><span class="line">    USHORT MajorSubsystemVersion;</span><br><span class="line">    USHORT MinorSubsystemVersion;</span><br><span class="line">    ULONG Win32VersionValue;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    ULONG SizeOfHeaders;</span><br><span class="line">    ULONG CheckSum;</span><br><span class="line">    USHORT Subsystem;</span><br><span class="line">    USHORT DllCharacteristics;</span><br><span class="line">    ULONGLONG SizeOfStackReserve;</span><br><span class="line">    ULONGLONG SizeOfStackCommit;</span><br><span class="line">    ULONGLONG SizeOfHeapReserve;</span><br><span class="line">    ULONGLONG SizeOfHeapCommit;</span><br><span class="line">    ULONG LoaderFlags;</span><br><span class="line">    ULONG NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIR DataDirectory[<span class="number">16</span>];</span><br><span class="line">&#125; IMAGE_OPT_HDR64, *PIMAGE_OPT_HDR64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPT_HDR32</span> &#123;</span></span><br><span class="line">    USHORT Magic;</span><br><span class="line">    UCHAR MajorLinkerVersion;</span><br><span class="line">    UCHAR MinorLinkerVersion;</span><br><span class="line">    ULONG SizeOfCode;</span><br><span class="line">    ULONG SizeOfInitializedData;</span><br><span class="line">    ULONG SizeOfUninitializedData;</span><br><span class="line">    ULONG AddressOfEntryPoint;</span><br><span class="line">    ULONG BaseOfCode;</span><br><span class="line">    ULONG BaseOfData;</span><br><span class="line">    ULONG ImageBase;</span><br><span class="line">    ULONG SectionAlignment;</span><br><span class="line">    ULONG FileAlignment;</span><br><span class="line">    USHORT MajorOperatingSystemVersion;</span><br><span class="line">    USHORT MinorOperatingSystemVersion;</span><br><span class="line">    USHORT MajorImageVersion;</span><br><span class="line">    USHORT MinorImageVersion;</span><br><span class="line">    USHORT MajorSubsystemVersion;</span><br><span class="line">    USHORT MinorSubsystemVersion;</span><br><span class="line">    ULONG Win32VersionValue;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    ULONG SizeOfHeaders;</span><br><span class="line">    ULONG CheckSum;</span><br><span class="line">    USHORT Subsystem;</span><br><span class="line">    USHORT DllCharacteristics;</span><br><span class="line">    ULONG SizeOfStackReserve;</span><br><span class="line">    ULONG SizeOfStackCommit;</span><br><span class="line">    ULONG SizeOfHeapReserve;</span><br><span class="line">    ULONG SizeOfHeapCommit;</span><br><span class="line">    ULONG LoaderFlags;</span><br><span class="line">    ULONG NumberOfRvaAndSizes;</span><br><span class="line">    IMAGE_DATA_DIR DataDirectory[<span class="number">16</span>];</span><br><span class="line">&#125; IMAGE_OPT_HDR32, *PIMAGE_OPT_HDR32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HDR32</span> &#123;</span></span><br><span class="line">    ULONG Signature;</span><br><span class="line">    IMAGE_FILE_HDR FileHeader;</span><br><span class="line">    IMAGE_OPT_HDR32 OptHeader32;</span><br><span class="line">&#125; IMAGE_NT_HDR32, *PIMAGE_NT_HDR32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HDR64</span> &#123;</span></span><br><span class="line">    ULONG Signature;</span><br><span class="line">    IMAGE_FILE_HDR FileHeader;</span><br><span class="line">    IMAGE_OPT_HDR64 OptHeader64;</span><br><span class="line">&#125; IMAGE_NT_HDR64, *PIMAGE_NT_HDR64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIR</span> &#123;</span></span><br><span class="line">    ULONG Characteristics;</span><br><span class="line">    ULONG TimeDateStamp;</span><br><span class="line">    USHORT MajorVersion;</span><br><span class="line">    USHORT MinorVersion;</span><br><span class="line">    ULONG Name;</span><br><span class="line">    ULONG Base;</span><br><span class="line">    ULONG NumberOfFunctions;</span><br><span class="line">    ULONG NumberOfNames;</span><br><span class="line">    ULONG AddressOfFunctions;</span><br><span class="line">    ULONG AddressOfNames;</span><br><span class="line">    ULONG AddressOfNameOrdinals;</span><br><span class="line">&#125; IMAGE_EXPORT_DIR, *PIMAGE_EXPORT_DIR;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HDR</span> &#123;</span></span><br><span class="line">    UCHAR Name[<span class="number">8</span>];</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        ULONG PhysicalAddress;</span><br><span class="line">        ULONG VirtualSize;</span><br><span class="line">    &#125; Misc;</span><br><span class="line">    ULONG VirtualAddress;</span><br><span class="line">    ULONG SizeOfRawData;</span><br><span class="line">    ULONG PointerToRawData;</span><br><span class="line">    ULONG PointerToRelocations;</span><br><span class="line">    ULONG PointerToLinenumbers;</span><br><span class="line">    USHORT NumberOfRelocations;</span><br><span class="line">    USHORT NumberOfLinenumbers;</span><br><span class="line">    ULONG Characteristics;</span><br><span class="line">&#125; IMAGE_SECTION_HDR, *PIMAGE_SECTION_HDR;</span><br></pre></td></tr></table></figure>

<p>这里以获取 <code>Kernel32.dll</code> 的 <code>WinExec</code> 函数地址为例，<br>注意：在访问不确定的地址时，一定要记得加 <code>__try</code> 异常处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PVOID <span class="title">GetExportFuncAddr</span><span class="params">(IN PVOID DllBase, IN PCSTR FuncName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PULONG Ent = <span class="literal">NULL</span>; <span class="comment">// 名称表</span></span><br><span class="line">    PULONG Eat = <span class="literal">NULL</span>; <span class="comment">// 地址表</span></span><br><span class="line">    PUSHORT Eot = <span class="literal">NULL</span>; <span class="comment">// 序号表</span></span><br><span class="line">    PIMAGE_DOS_HDR DosHdr = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HDR32 NtHdr32 = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_NT_HDR64 NtHdr64 = <span class="literal">NULL</span>;</span><br><span class="line">    PIMAGE_EXPORT_DIR ExportDir = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 检测参数是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (!DllBase || !FuncName) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    __try &#123;</span><br><span class="line">        <span class="comment">// 检测DOS头是否匹配</span></span><br><span class="line">        DosHdr = (PIMAGE_DOS_HDR)DllBase;</span><br><span class="line">        <span class="keyword">if</span> (DosHdr-&gt;e_magic != IMAGE_DOS_SIGN) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 检测NT头是否匹配</span></span><br><span class="line">        NtHdr32 = (PIMAGE_NT_HDR32)((PUCHAR)DllBase + DosHdr-&gt;e_lfanew);</span><br><span class="line">        NtHdr64 = (PIMAGE_NT_HDR64)((PUCHAR)DllBase + DosHdr-&gt;e_lfanew);</span><br><span class="line">        <span class="keyword">if</span> (NtHdr32-&gt;Signature != IMAGE_NT_SIGN) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">// 检测是32位PE文件还是64位PE文件</span></span><br><span class="line">        <span class="keyword">if</span> (NtHdr32-&gt;OptHeader32.Magic == IMAGE_NT_OPT_HDR32_MAGIC)</span><br><span class="line">        &#123;</span><br><span class="line">            ExportDir = (PIMAGE_EXPORT_DIR)(NtHdr32-&gt;OptHeader32.</span><br><span class="line">                DataDirectory[<span class="number">0</span>].VirtualAddress + (ULONG_PTR)DllBase);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ExportDir = (PIMAGE_EXPORT_DIR)(NtHdr64-&gt;OptHeader64.</span><br><span class="line">                DataDirectory[<span class="number">0</span>].VirtualAddress + (ULONG_PTR)DllBase);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获取导出表的相关信息</span></span><br><span class="line">        Eot = (PUSHORT)(ExportDir-&gt;AddressOfNameOrdinals + (ULONG_PTR)DllBase);</span><br><span class="line">        Ent = (PULONG)(ExportDir-&gt;AddressOfNames + (ULONG_PTR)DllBase);</span><br><span class="line">        Eat = (PULONG)(ExportDir-&gt;AddressOfFunctions + (ULONG_PTR)DllBase);</span><br><span class="line">        <span class="comment">// 对比名称表中的函数名是否匹配</span></span><br><span class="line">        <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; ExportDir-&gt;NumberOfNames; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 在序号表中相同的位置存储了地址表的索引</span></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">strcmp</span>((PCHAR)(Ent[i] + (ULONG_PTR)DllBase), FuncName))</span><br><span class="line">                <span class="keyword">return</span> (PVOID)(Eat[Eot[i]] + (ULONG_PTR)DllBase);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (EXCEPTION_EXECUTE_HANDLER) &#123;&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>在应用层远程线程注入DLL到R3进程(1)</title>
    <url>/2021/01/03/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E5%9C%A8%E5%BA%94%E7%94%A8%E5%B1%82%E8%BF%9C%E7%A8%8B%E7%BA%BF%E7%A8%8B%E6%B3%A8%E5%85%A5DLL%E5%88%B0R3%E8%BF%9B%E7%A8%8B-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>由于各进程内存空间隔离，所以要想修改目标进程的数据，就需要先注入到目标进程中，<br>这里介绍最常见的一种注入方法，也就是远程线程注入</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>先从目标进程中申请一段内存，保存注入的DLL路径，然后获取 <code>LoadLibraryW</code> 函数的地址，<br>作为 <code>CreateRemoteThread</code> 创建线程的函数，参数就是DLL的路径。同理还可以注入自定义<br>的shellcode代码，来实现其他的操作。注意x86和x64程序需要对应版本的DLL才能注入</p>
<h4 id="相关代码"><a href="#相关代码" class="headerlink" title="相关代码"></a>相关代码</h4><p>设置进程调试权限 <code>SE_DEBUG_NAME</code> 的函数如下所示<strong>（注：不提权也能注入）</strong></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">EnableDebugPrivilege</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE hToken = <span class="literal">NULL</span>;</span><br><span class="line">    TOKEN_PRIVILEGES priv = &#123; <span class="number">1</span>,&#123; <span class="number">0</span>, <span class="number">0</span>, SE_PRIVILEGE_ENABLED &#125; &#125;;</span><br><span class="line">    BOOL ret = LookupPrivilegeValueW(<span class="number">0</span>, SE_DEBUG_NAME, &amp;priv.Privileges[<span class="number">0</span>].Luid);</span><br><span class="line">    <span class="keyword">if</span> (!ret) <span class="keyword">return</span> FALSE;</span><br><span class="line">    ret = OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES, &amp;hToken);</span><br><span class="line">    <span class="keyword">if</span> (!ret) <span class="keyword">return</span> FALSE;</span><br><span class="line">    ret = AdjustTokenPrivileges(hToken, FALSE, &amp;priv, <span class="keyword">sizeof</span>(priv), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    CloseHandle(hToken);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要注入到UWP程序中，还需要给DLL文件设置 <code>ALL APPLICATION PACKAGES</code> 访问权限</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;accctrl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;aclapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sddl.h&gt;</span></span></span><br><span class="line"><span class="function">BOOL <span class="title">SetAccessControl</span><span class="params">(PCWSTR pPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pPath || !pPath[<span class="number">0</span>]) <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    PACL pACLCurr = <span class="literal">NULL</span>;</span><br><span class="line">    PSECURITY_DESCRIPTOR pSecurity = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwError = GetNamedSecurityInfoW(pPath, SE_FILE_OBJECT,</span><br><span class="line">        DACL_SECURITY_INFORMATION, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;pACLCurr, <span class="literal">NULL</span>, &amp;pSecurity);</span><br><span class="line">    <span class="keyword">if</span> (dwError != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    PSID pSID = <span class="literal">NULL</span>;</span><br><span class="line">    PACL pACLNew = <span class="literal">NULL</span>;</span><br><span class="line">    BOOL bRet = FALSE;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 用户和组 ALL APPLICATION PACKAGES</span></span><br><span class="line">        <span class="keyword">if</span>(!ConvertStringSidToSidW(<span class="string">L&quot;S-1-15-2-1&quot;</span>, &amp;pSID)) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        EXPLICIT_ACCESSW stExplicit = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">        stExplicit.grfAccessPermissions = GENERIC_ALL;</span><br><span class="line">        stExplicit.grfAccessMode = SET_ACCESS;</span><br><span class="line">        stExplicit.grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;</span><br><span class="line">        stExplicit.Trustee.TrusteeForm = TRUSTEE_IS_SID;</span><br><span class="line">        stExplicit.Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;</span><br><span class="line">        stExplicit.Trustee.ptstrName = (PWSTR)pSID;</span><br><span class="line"></span><br><span class="line">        dwError = SetEntriesInAclW(<span class="number">1</span>, &amp;stExplicit, pACLCurr, &amp;pACLNew);</span><br><span class="line">        <span class="keyword">if</span> (dwError != ERROR_SUCCESS) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        dwError = SetNamedSecurityInfoW((PWSTR)pPath, SE_FILE_OBJECT,</span><br><span class="line">            DACL_SECURITY_INFORMATION, <span class="literal">NULL</span>, <span class="literal">NULL</span>, pACLNew, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (dwError != ERROR_SUCCESS) <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        bRet = TRUE;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pSecurity) LocalFree((HLOCAL)pSecurity);</span><br><span class="line">    <span class="keyword">if</span> (pACLNew) LocalFree((HLOCAL)pACLNew);</span><br><span class="line">    <span class="keyword">if</span> (pSID) LocalFree((HLOCAL)pSID);</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取目标进程PID的函数为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tlhelp32.h&gt;</span></span></span><br><span class="line"><span class="function">DWORD <span class="title">GetPidByName</span><span class="params">(PCWSTR pName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!pName) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    HANDLE hSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hSnapshot == INVALID_HANDLE_VALUE) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    PROCESSENTRY32W pe32 = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    pe32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32W);</span><br><span class="line">    <span class="keyword">if</span> (!Process32FirstW(hSnapshot, &amp;pe32))</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(hSnapshot);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!_wcsicmp(pe32.szExeFile, pName))</span><br><span class="line">        &#123;</span><br><span class="line">            CloseHandle(hSnapshot);</span><br><span class="line">            <span class="keyword">return</span> pe32.th32ProcessID;</span><br><span class="line">        &#125;</span><br><span class="line">        ZeroMemory(&amp;pe32, <span class="keyword">sizeof</span>(PROCESSENTRY32W));</span><br><span class="line">        pe32.dwSize = <span class="keyword">sizeof</span>(PROCESSENTRY32W);</span><br><span class="line">    &#125; <span class="keyword">while</span> (Process32NextW(hSnapshot, &amp;pe32));</span><br><span class="line">    CloseHandle(hSnapshot);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注入到目标进程的函数为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">LoadInjectDll</span><span class="params">(DWORD dwPid, PCWSTR pPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dwPid || !pPath) <span class="keyword">return</span> FALSE;</span><br><span class="line">    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwPid);</span><br><span class="line">    <span class="keyword">if</span> (!hProcess) <span class="keyword">return</span> FALSE;</span><br><span class="line">    BOOL result = FALSE;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        SIZE_T nLen = (wcslen(pPath) + <span class="number">1</span>) * <span class="keyword">sizeof</span>(WCHAR);</span><br><span class="line">        PVOID pBuffer = VirtualAllocEx(hProcess, <span class="literal">NULL</span>, nLen, MEM_COMMIT, PAGE_READWRITE);</span><br><span class="line">        <span class="keyword">if</span> (!pBuffer) <span class="keyword">break</span>;</span><br><span class="line">        SIZE_T nRet = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!WriteProcessMemory(hProcess, pBuffer, pPath, nLen, &amp;nRet)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (nLen != nRet) <span class="keyword">break</span>;</span><br><span class="line">        PTHREAD_START_ROUTINE pFunc = (PTHREAD_START_ROUTINE)GetProcAddress(</span><br><span class="line">            GetModuleHandleW(<span class="string">L&quot;Kernel32&quot;</span>), <span class="string">&quot;LoadLibraryW&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (!pFunc) <span class="keyword">break</span>;</span><br><span class="line">        HANDLE hThread = CreateRemoteThread(hProcess, <span class="literal">NULL</span>, <span class="number">0</span>, pFunc, pBuffer, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!hThread) <span class="keyword">break</span>;</span><br><span class="line">        CloseHandle(hThread);</span><br><span class="line">        result = TRUE;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    CloseHandle(hProcess);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>绕过MiniFilter强删文件(1)</title>
    <url>/2021/03/02/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E7%BB%95%E8%BF%87MiniFilter%E5%BC%BA%E5%88%A0%E6%96%87%E4%BB%B6-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>我们知道在内核中使用 <code>MiniFilter</code> 拦截文件操作来实现自保护，这里提供一种绕过的方法。<br>从原理上来说，所有的 <code>文件过滤驱动</code> 都是绑定到 <code>文件系统驱动(FSD)</code> 设备上，形成一个设备栈，<br>所有的文件操作生成的IRP请求，经过层层过滤，最终发送到FSD来完成实际的操作。所以实现<br>的方法就是我们自己生成一个IRP请求，然后直接发送给FSD，这样就绕过了各种过滤驱动。</p>
<h4 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h4><h5 id="1-查找文件系统卷设备"><a href="#1-查找文件系统卷设备" class="headerlink" title="1.查找文件系统卷设备"></a>1.查找文件系统卷设备</h5><p>删除不同盘下边的文件，最终由的对应的根目录设备来处理，所以我们首先要查找根目录设备</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">GetRootRealDevice</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN WCHAR RootName,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PDEVICE_OBJECT *RootDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PDEVICE_OBJECT *RealDevice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    HANDLE FileHandle = <span class="literal">NULL</span>;</span><br><span class="line">    IO_STATUS_BLOCK IoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OBJECT_ATTRIBUTES ObjAttrib = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PFILE_OBJECT FileObject = <span class="literal">NULL</span>;</span><br><span class="line">    WCHAR Buffer[<span class="number">8</span>] = <span class="string">L&quot;\\??\\C:\\&quot;</span>;</span><br><span class="line">    UNICODE_STRING NamePath = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RootDevice || !RealDevice)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    Buffer[<span class="number">4</span>] = RootName;</span><br><span class="line">    RtlInitUnicodeString(&amp;NamePath, Buffer);</span><br><span class="line"></span><br><span class="line">    InitializeObjectAttributes(&amp;ObjAttrib, &amp;NamePath,</span><br><span class="line">        OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    Status = ZwOpenFile(&amp;FileHandle,</span><br><span class="line">        FILE_GENERIC_READ, &amp;ObjAttrib, &amp;IoStatus, FILE_SHARE_READ,</span><br><span class="line">        FILE_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line"></span><br><span class="line">    Status = ObReferenceObjectByHandle(</span><br><span class="line">        FileHandle, FILE_ALL_ACCESS, *IoFileObjectType,</span><br><span class="line">        KernelMode, (PVOID*)&amp;FileObject, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        ZwClose(FileHandle);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!FileObject-&gt;Vpb ||</span><br><span class="line">        !FileObject-&gt;Vpb-&gt;DeviceObject ||</span><br><span class="line">        !FileObject-&gt;Vpb-&gt;RealDevice)</span><br><span class="line">    &#123;</span><br><span class="line">        ObDereferenceObject(FileObject);</span><br><span class="line">        ZwClose(FileHandle);</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    *RootDevice = FileObject-&gt;Vpb-&gt;DeviceObject; <span class="comment">// 卷设备</span></span><br><span class="line">    *RealDevice = FileObject-&gt;Vpb-&gt;RealDevice; <span class="comment">// 物理设备</span></span><br><span class="line"></span><br><span class="line">    ObDereferenceObject(FileObject);</span><br><span class="line">    ZwClose(FileHandle);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-创建自定义IRP请求"><a href="#2-创建自定义IRP请求" class="headerlink" title="2.创建自定义IRP请求"></a>2.创建自定义IRP请求</h5><p>创建IRP需要使用 <code>ObCreateObject</code> 和 <code>SeCreateAccessState</code> 两个已导出但未文档化的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NTSTATUS ObCreateObject(</span><br><span class="line">    IN KPROCESSOR_MODE ProbeMode,</span><br><span class="line">    IN POBJECT_TYPE ObjectType,</span><br><span class="line">    IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,</span><br><span class="line">    IN KPROCESSOR_MODE OwnershipMode,</span><br><span class="line">    IN OUT PVOID ParseContext OPTIONAL,</span><br><span class="line">    IN ULONG ObjectBodySize,</span><br><span class="line">    IN ULONG PagedPoolCharge,</span><br><span class="line">    IN ULONG NonPagedPoolCharge,</span><br><span class="line">    OUT PVOID* Object);</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">AUX_ACCESS_DATA</span> &#123;</span></span><br><span class="line">    PPRIVILEGE_SET  PrivilegesUsed;</span><br><span class="line">    GENERIC_MAPPING GenericMapping;</span><br><span class="line">    ACCESS_MASK     AccessesToAudit;</span><br><span class="line">    ACCESS_MASK     MaximumAuditMask;</span><br><span class="line">    ULONG           Unknown[<span class="number">256</span>];</span><br><span class="line">&#125; AUX_ACCESS_DATA, *PAUX_ACCESS_DATA;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SeCreateAccessState</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PACCESS_STATE AccessState,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PAUX_ACCESS_DATA AuxData,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PGENERIC_MAPPING GenericMapping OPTIONAL)</span></span>;</span><br></pre></td></tr></table></figure>

<p>发送IRP的通用完成函数如下定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCompletionRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PDEVICE_OBJECT DeviceObject,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PIRP Irp,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PMDL MdlNext = <span class="literal">NULL</span>;</span><br><span class="line">    PMDL MdlCurrent = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    UNREFERENCED_PARAMETER(DeviceObject);</span><br><span class="line">    UNREFERENCED_PARAMETER(Context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Irp-&gt;MdlAddress)</span><br><span class="line">    &#123;</span><br><span class="line">        MdlCurrent = Irp-&gt;MdlAddress;</span><br><span class="line">        <span class="keyword">while</span> (MdlCurrent)</span><br><span class="line">        &#123;</span><br><span class="line">            MdlNext = MdlCurrent-&gt;Next;</span><br><span class="line">            <span class="keyword">if</span> (MdlCurrent-&gt;MdlFlags &amp; MDL_PAGES_LOCKED)</span><br><span class="line">                MmUnlockPages(MdlCurrent);</span><br><span class="line">            IoFreeMdl(MdlCurrent);</span><br><span class="line">            MdlCurrent = MdlNext;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Irp-&gt;UserIosb)</span><br><span class="line">        *(Irp-&gt;UserIosb) = Irp-&gt;IoStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Irp-&gt;UserEvent)</span><br><span class="line">        KeSetEvent(Irp-&gt;UserEvent, IO_NO_INCREMENT, FALSE);</span><br><span class="line"></span><br><span class="line">    IoFreeIrp(Irp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> STATUS_MORE_PROCESSING_REQUIRED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-打开文件-IRP-MJ-CREATE"><a href="#3-打开文件-IRP-MJ-CREATE" class="headerlink" title="3.打开文件(IRP_MJ_CREATE)"></a>3.打开文件(IRP_MJ_CREATE)</h5><p>在打开文件的时候，同时也获取文件对应的卷设备</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IrpOpenFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PUNICODE_STRING FilePath,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PDEVICE_OBJECT* RootDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PFILE_OBJECT* FileObject,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PIO_STATUS_BLOCK IoStatus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PDEVICE_OBJECT RealDevice = <span class="literal">NULL</span>;</span><br><span class="line">    PDEVICE_OBJECT DeviceObject = <span class="literal">NULL</span>;</span><br><span class="line">    PFILE_OBJECT TempObject = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    OBJECT_ATTRIBUTES ObjAttrib = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UNICODE_STRING TempName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    PIRP Irp = <span class="literal">NULL</span>;</span><br><span class="line">    KEVENT LocalKEvent = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IO_STATUS_BLOCK LocalIoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PIO_STACK_LOCATION IrpSp = <span class="literal">NULL</span>;</span><br><span class="line">    AUX_ACCESS_DATA AuxData = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ACCESS_STATE AccessState = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IO_SECURITY_CONTEXT IoSecCtx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!FileObject || !RootDevice || !IoStatus ||</span><br><span class="line">        !FilePath || !FilePath-&gt;Buffer || !FilePath-&gt;Length)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 申请去除L&quot;\\??\\C:&quot;路径的内存</span></span><br><span class="line">    TempName.Length = FilePath-&gt;Length - <span class="keyword">sizeof</span>(WCHAR) * <span class="number">6</span>;</span><br><span class="line">    TempName.MaximumLength = TempName.Length;</span><br><span class="line">    TempName.Buffer = (PWCH)ExAllocatePoolWithTag(NonPagedPoolNx, TempName.Length, &#x27;test&#x27;);</span><br><span class="line">    <span class="keyword">if</span> (!TempName.Buffer)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">    RtlCopyMemory(TempName.Buffer, &amp;FilePath-&gt;Buffer[<span class="number">6</span>], TempName.Length);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取盘符根目录设备</span></span><br><span class="line">    Status = GetRootRealDevice(FilePath-&gt;Buffer[<span class="number">4</span>], &amp;DeviceObject, &amp;RealDevice);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePool(TempName.Buffer);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InitializeObjectAttributes(&amp;ObjAttrib, FilePath,</span><br><span class="line">        OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    Status = ObCreateObject(</span><br><span class="line">        KernelMode, *IoFileObjectType, &amp;ObjAttrib,</span><br><span class="line">        KernelMode, <span class="literal">NULL</span>, <span class="keyword">sizeof</span>(FILE_OBJECT), <span class="number">0</span>, <span class="number">0</span>, &amp;TempObject);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePool(TempName.Buffer);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RtlZeroMemory(TempObject, <span class="keyword">sizeof</span>(FILE_OBJECT));</span><br><span class="line">    TempObject-&gt;Type = IO_TYPE_FILE;</span><br><span class="line">    TempObject-&gt;Size = <span class="keyword">sizeof</span>(FILE_OBJECT);</span><br><span class="line">    TempObject-&gt;DeviceObject = RealDevice;</span><br><span class="line">    TempObject-&gt;Flags = FO_SYNCHRONOUS_IO | FO_WRITE_THROUGH;</span><br><span class="line">    KeInitializeEvent(&amp;TempObject-&gt;Lock, SynchronizationEvent, FALSE);</span><br><span class="line">    KeInitializeEvent(&amp;TempObject-&gt;Event, NotificationEvent, FALSE);</span><br><span class="line">    TempObject-&gt;FileName = TempName; <span class="comment">// 赋值文件路径</span></span><br><span class="line"></span><br><span class="line">    Status = SeCreateAccessState(</span><br><span class="line">        &amp;AccessState, &amp;AuxData, FILE_ALL_ACCESS, IoGetFileObjectGenericMapping());</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 系统自动释放TempObject-&gt;FileName.Buffer</span></span><br><span class="line">        ObDereferenceObject(TempObject);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KeInitializeEvent(&amp;LocalKEvent, NotificationEvent, FALSE);</span><br><span class="line">    Irp = IoAllocateIrp(DeviceObject-&gt;StackSize, FALSE);</span><br><span class="line">    <span class="keyword">if</span> (!Irp)</span><br><span class="line">    &#123;</span><br><span class="line">        ObDereferenceObject(TempObject);</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">    &#125;</span><br><span class="line">    Irp-&gt;Flags = IRP_CREATE_OPERATION | IRP_SYNCHRONOUS_API;</span><br><span class="line">    Irp-&gt;RequestorMode = KernelMode;</span><br><span class="line">    Irp-&gt;UserEvent = &amp;LocalKEvent;</span><br><span class="line">    Irp-&gt;UserIosb = &amp;LocalIoStatus;</span><br><span class="line">    Irp-&gt;Tail.Overlay.Thread = PsGetCurrentThread();</span><br><span class="line">    Irp-&gt;Tail.Overlay.OriginalFileObject = TempObject;</span><br><span class="line"></span><br><span class="line">    IoSecCtx.AccessState = &amp;AccessState;</span><br><span class="line">    IoSecCtx.DesiredAccess = DesiredAccess;</span><br><span class="line">    IrpSp = IoGetNextIrpStackLocation(Irp);</span><br><span class="line">    IrpSp-&gt;MajorFunction = IRP_MJ_CREATE;</span><br><span class="line">    IrpSp-&gt;DeviceObject = DeviceObject;</span><br><span class="line">    IrpSp-&gt;FileObject = TempObject;</span><br><span class="line">    IrpSp-&gt;Parameters.Create.SecurityContext = &amp;IoSecCtx;</span><br><span class="line">    IrpSp-&gt;Parameters.Create.Options = (FILE_OPEN &lt;&lt; <span class="number">24</span>) |</span><br><span class="line">        FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT | FILE_WRITE_THROUGH;</span><br><span class="line">    IrpSp-&gt;Parameters.Create.FileAttributes = FILE_ATTRIBUTE_NORMAL;</span><br><span class="line">    IrpSp-&gt;Parameters.Create.ShareAccess = <span class="number">0</span>;</span><br><span class="line">    IrpSp-&gt;Parameters.Create.EaLength = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    IoSetCompletionRoutine(Irp, IoCompletionRoutine, <span class="literal">NULL</span>, TRUE, TRUE, TRUE);</span><br><span class="line">    Status = IoCallDriver(DeviceObject, Irp);</span><br><span class="line">    <span class="keyword">if</span> (Status == STATUS_PENDING)</span><br><span class="line">    &#123;</span><br><span class="line">        KeWaitForSingleObject(&amp;LocalKEvent, Executive, KernelMode, TRUE, <span class="literal">NULL</span>);</span><br><span class="line">        Status = LocalIoStatus.Status;</span><br><span class="line">    &#125;</span><br><span class="line">    *IoStatus = LocalIoStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        ObDereferenceObject(TempObject);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    InterlockedIncrement(&amp;TempObject-&gt;DeviceObject-&gt;ReferenceCount);</span><br><span class="line">    <span class="keyword">if</span> (TempObject-&gt;Vpb)</span><br><span class="line">        InterlockedIncrement(&amp;(LONG)TempObject-&gt;Vpb-&gt;ReferenceCount);</span><br><span class="line">    *FileObject = TempObject;</span><br><span class="line">    *RootDevice = DeviceObject;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="4-获取属性-IRP-MJ-QUERY-INFORMATION"><a href="#4-获取属性-IRP-MJ-QUERY-INFORMATION" class="headerlink" title="4.获取属性(IRP_MJ_QUERY_INFORMATION)"></a>4.获取属性(IRP_MJ_QUERY_INFORMATION)</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IrpGetFileInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PDEVICE_OBJECT RootDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN FILE_INFORMATION_CLASS InfoClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PVOID FileInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG InfoSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PIO_STATUS_BLOCK IoStatus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    ULONG ClassLength = <span class="number">0</span>;</span><br><span class="line">    PIRP Irp = <span class="literal">NULL</span>;</span><br><span class="line">    KEVENT LocalKEvent = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IO_STATUS_BLOCK LocalIoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PIO_STACK_LOCATION IrpSp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RootDevice || !FileObject || !FileInfo || !IoStatus)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (InfoClass)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> FileBasicInformation:</span><br><span class="line">        ClassLength = <span class="keyword">sizeof</span>(FILE_BASIC_INFORMATION);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FileStandardInformation:</span><br><span class="line">        ClassLength = <span class="keyword">sizeof</span>(FILE_STANDARD_INFORMATION);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (InfoSize &lt; ClassLength)</span><br><span class="line">    &#123;</span><br><span class="line">        IoStatus-&gt;Information = ClassLength;</span><br><span class="line">        <span class="keyword">return</span> STATUS_INFO_LENGTH_MISMATCH;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    KeInitializeEvent(&amp;LocalKEvent, NotificationEvent, FALSE);</span><br><span class="line">    Irp = IoAllocateIrp(RootDevice-&gt;StackSize, FALSE);</span><br><span class="line">    <span class="keyword">if</span> (!Irp)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line"></span><br><span class="line">    Irp-&gt;Flags = IRP_BUFFERED_IO | IRP_SYNCHRONOUS_API |</span><br><span class="line">        IRP_INPUT_OPERATION | IRP_DEFER_IO_COMPLETION;</span><br><span class="line">    Irp-&gt;RequestorMode = KernelMode;</span><br><span class="line">    Irp-&gt;UserEvent = &amp;LocalKEvent;</span><br><span class="line">    Irp-&gt;UserIosb = &amp;LocalIoStatus;</span><br><span class="line">    Irp-&gt;Tail.Overlay.Thread = PsGetCurrentThread();</span><br><span class="line">    Irp-&gt;Tail.Overlay.OriginalFileObject = FileObject;</span><br><span class="line">    Irp-&gt;AssociatedIrp.SystemBuffer = FileInfo;</span><br><span class="line"></span><br><span class="line">    IrpSp = IoGetNextIrpStackLocation(Irp);</span><br><span class="line">    IrpSp-&gt;MajorFunction = IRP_MJ_QUERY_INFORMATION;</span><br><span class="line">    IrpSp-&gt;DeviceObject = RootDevice;</span><br><span class="line">    IrpSp-&gt;FileObject = FileObject;</span><br><span class="line">    IrpSp-&gt;Parameters.QueryFile.Length = InfoSize;</span><br><span class="line">    IrpSp-&gt;Parameters.QueryFile.FileInformationClass = InfoClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//KeClearEvent(&amp;FileObject-&gt;Event);</span></span><br><span class="line">    IoSetCompletionRoutine(Irp, IoCompletionRoutine, <span class="literal">NULL</span>, TRUE, TRUE, TRUE);</span><br><span class="line">    Status = IoCallDriver(RootDevice, Irp);</span><br><span class="line">    <span class="keyword">if</span> (Status == STATUS_PENDING)</span><br><span class="line">    &#123;</span><br><span class="line">        KeWaitForSingleObject(&amp;LocalKEvent, Executive, KernelMode, TRUE, <span class="literal">NULL</span>);</span><br><span class="line">        Status = LocalIoStatus.Status;</span><br><span class="line">    &#125;</span><br><span class="line">    *IoStatus = LocalIoStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="5-设置属性-IRP-MJ-SET-INFORMATION"><a href="#5-设置属性-IRP-MJ-SET-INFORMATION" class="headerlink" title="5.设置属性(IRP_MJ_SET_INFORMATION)"></a>5.设置属性(IRP_MJ_SET_INFORMATION)</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IrpSetFileInfo</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PDEVICE_OBJECT RootDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN FILE_INFORMATION_CLASS InfoClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID FileInfo,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG InfoSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PIO_STATUS_BLOCK IoStatus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    ULONG ClassLength = <span class="number">0</span>;</span><br><span class="line">    PIRP Irp = <span class="literal">NULL</span>;</span><br><span class="line">    KEVENT LocalKEvent = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IO_STATUS_BLOCK LocalIoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PIO_STACK_LOCATION IrpSp = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RootDevice || !FileObject || !FileInfo || !IoStatus)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (InfoClass)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> FileBasicInformation:</span><br><span class="line">        ClassLength = <span class="keyword">sizeof</span>(FILE_BASIC_INFORMATION);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FileRenameInformation:</span><br><span class="line">        ClassLength = <span class="keyword">sizeof</span>(FILE_RENAME_INFORMATION);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FileDispositionInformation:</span><br><span class="line">        ClassLength = <span class="keyword">sizeof</span>(FILE_DISPOSITION_INFORMATION);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (InfoSize &lt; ClassLength)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INFO_LENGTH_MISMATCH;</span><br><span class="line"></span><br><span class="line">    KeInitializeEvent(&amp;LocalKEvent, NotificationEvent, FALSE);</span><br><span class="line">    Irp = IoAllocateIrp(RootDevice-&gt;StackSize, FALSE);</span><br><span class="line">    <span class="keyword">if</span> (!Irp)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line"></span><br><span class="line">    Irp-&gt;Flags = IRP_BUFFERED_IO | IRP_SYNCHRONOUS_API | IRP_DEFER_IO_COMPLETION;</span><br><span class="line">    Irp-&gt;RequestorMode = KernelMode;</span><br><span class="line">    Irp-&gt;UserEvent = &amp;LocalKEvent;</span><br><span class="line">    Irp-&gt;UserIosb = &amp;LocalIoStatus;</span><br><span class="line">    Irp-&gt;Tail.Overlay.Thread = PsGetCurrentThread();</span><br><span class="line">    Irp-&gt;Tail.Overlay.OriginalFileObject = FileObject;</span><br><span class="line">    Irp-&gt;AssociatedIrp.SystemBuffer = FileInfo;</span><br><span class="line"></span><br><span class="line">    IrpSp = IoGetNextIrpStackLocation(Irp);</span><br><span class="line">    IrpSp-&gt;MajorFunction = IRP_MJ_SET_INFORMATION;</span><br><span class="line">    IrpSp-&gt;DeviceObject = RootDevice;</span><br><span class="line">    IrpSp-&gt;FileObject = FileObject;</span><br><span class="line">    IrpSp-&gt;Parameters.SetFile.Length = InfoSize;</span><br><span class="line">    IrpSp-&gt;Parameters.SetFile.FileInformationClass = InfoClass;</span><br><span class="line">    IrpSp-&gt;Parameters.SetFile.ReplaceIfExists = FALSE;</span><br><span class="line">    IrpSp-&gt;Parameters.SetFile.FileObject = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//KeClearEvent(&amp;FileObject-&gt;Event);</span></span><br><span class="line">    IoSetCompletionRoutine(Irp, IoCompletionRoutine, <span class="literal">NULL</span>, TRUE, TRUE, TRUE);</span><br><span class="line">    Status = IoCallDriver(RootDevice, Irp);</span><br><span class="line">    <span class="keyword">if</span> (Status == STATUS_PENDING)</span><br><span class="line">    &#123;</span><br><span class="line">        KeWaitForSingleObject(&amp;LocalKEvent, Executive, KernelMode, TRUE, <span class="literal">NULL</span>);</span><br><span class="line">        Status = LocalIoStatus.Status;</span><br><span class="line">    &#125;</span><br><span class="line">    *IoStatus = LocalIoStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="6-写文件数据-IRP-MJ-WRITE"><a href="#6-写文件数据-IRP-MJ-WRITE" class="headerlink" title="6.写文件数据(IRP_MJ_WRITE)"></a>6.写文件数据(IRP_MJ_WRITE)</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IrpWriteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PDEVICE_OBJECT RootDevice,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PFILE_OBJECT FileObject,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PVOID InfoBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG InfoLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PLARGE_INTEGER ByteOffset,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PIO_STATUS_BLOCK IoStatus)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PIRP Irp = <span class="literal">NULL</span>;</span><br><span class="line">    KEVENT LocalKEvent = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IO_STATUS_BLOCK LocalIoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PIO_STACK_LOCATION IrpSp = <span class="literal">NULL</span>;</span><br><span class="line">    PMDL Mdl = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!RootDevice || !FileObject || !IoStatus ||</span><br><span class="line">        !InfoBuffer || !InfoLength || !ByteOffset)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    KeInitializeEvent(&amp;LocalKEvent, NotificationEvent, FALSE);</span><br><span class="line">    Irp = IoAllocateIrp(RootDevice-&gt;StackSize, FALSE);</span><br><span class="line">    <span class="keyword">if</span> (!Irp)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (RootDevice-&gt;Flags &amp; DO_BUFFERED_IO)</span><br><span class="line">    &#123;</span><br><span class="line">        Irp-&gt;AssociatedIrp.SystemBuffer = ExAllocatePoolWithTag(NonPagedPoolNx, InfoLength, &#x27;test&#x27;);</span><br><span class="line">        <span class="keyword">if</span> (!Irp-&gt;AssociatedIrp.SystemBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            IoFreeIrp(Irp);</span><br><span class="line">            <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">        &#125;</span><br><span class="line">        RtlCopyMemory(Irp-&gt;AssociatedIrp.SystemBuffer, InfoBuffer, InfoLength);</span><br><span class="line">        Irp-&gt;Flags = IRP_BUFFERED_IO | IRP_DEALLOCATE_BUFFER;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (RootDevice-&gt;Flags &amp; DO_DIRECT_IO)</span><br><span class="line">    &#123;</span><br><span class="line">        Mdl = IoAllocateMdl(InfoBuffer, InfoLength, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!Mdl)</span><br><span class="line">        &#123;</span><br><span class="line">            IoFreeIrp(Irp);</span><br><span class="line">            <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">        &#125;</span><br><span class="line">        MmProbeAndLockPages(Mdl, KernelMode, IoReadAccess);</span><br><span class="line">        Irp-&gt;MdlAddress = Mdl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        Irp-&gt;UserBuffer = InfoBuffer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Irp-&gt;Flags = IRP_WRITE_OPERATION | IRP_SYNCHRONOUS_API |</span><br><span class="line">        IRP_DEFER_IO_COMPLETION | IRP_NOCACHE;</span><br><span class="line">    Irp-&gt;RequestorMode = KernelMode;</span><br><span class="line">    Irp-&gt;UserEvent = &amp;LocalKEvent;</span><br><span class="line">    Irp-&gt;UserIosb = &amp;LocalIoStatus;</span><br><span class="line">    Irp-&gt;Tail.Overlay.Thread = PsGetCurrentThread();</span><br><span class="line">    Irp-&gt;Tail.Overlay.OriginalFileObject = FileObject;</span><br><span class="line"></span><br><span class="line">    IrpSp = IoGetNextIrpStackLocation(Irp);</span><br><span class="line">    IrpSp-&gt;Flags = SL_WRITE_THROUGH;</span><br><span class="line">    IrpSp-&gt;MajorFunction = IRP_MJ_WRITE;</span><br><span class="line">    IrpSp-&gt;DeviceObject = RootDevice;</span><br><span class="line">    IrpSp-&gt;FileObject = FileObject;</span><br><span class="line">    IrpSp-&gt;Parameters.Write.Length = InfoLength;</span><br><span class="line">    IrpSp-&gt;Parameters.Write.Key = <span class="number">0</span>;</span><br><span class="line">    IrpSp-&gt;Parameters.Write.ByteOffset = *ByteOffset;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//KeClearEvent(&amp;FileObject-&gt;Event);</span></span><br><span class="line">    IoSetCompletionRoutine(Irp, IoCompletionRoutine, <span class="literal">NULL</span>, TRUE, TRUE, TRUE);</span><br><span class="line">    Status = IoCallDriver(RootDevice, Irp);</span><br><span class="line">    <span class="keyword">if</span> (Status == STATUS_PENDING)</span><br><span class="line">    &#123;</span><br><span class="line">        KeWaitForSingleObject(&amp;LocalKEvent, Executive, KernelMode, TRUE, <span class="literal">NULL</span>);</span><br><span class="line">        Status = LocalIoStatus.Status;</span><br><span class="line">    &#125;</span><br><span class="line">    *IoStatus = LocalIoStatus;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="去除文件只读属性"><a href="#去除文件只读属性" class="headerlink" title="去除文件只读属性"></a>去除文件只读属性</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LARGE_PATH 512</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">CheckPathFromat</span><span class="params">(IN PWCHAR FilePath, IN ULONG ByteLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!FilePath || (ByteLen &lt; <span class="keyword">sizeof</span>(<span class="string">L&quot;C:\\&quot;</span>)) ||</span><br><span class="line">        (ByteLen &gt; (LARGE_PATH - <span class="number">128</span>)))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">if</span> ((FilePath[<span class="number">0</span>] &lt; <span class="string">L&#x27;A&#x27;</span>) || (FilePath[<span class="number">0</span>] &gt; <span class="string">L&#x27;z&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">if</span> ((FilePath[<span class="number">0</span>] &gt; <span class="string">L&#x27;Z&#x27;</span>) &amp;&amp; (FilePath[<span class="number">0</span>] &lt; <span class="string">L&#x27;a&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">if</span> ((FilePath[<span class="number">1</span>] != <span class="string">L&#x27;:&#x27;</span>) || (FilePath[<span class="number">2</span>] != <span class="string">L&#x27;\\&#x27;</span>))</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MyRemoveReadOnly</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PWCHAR FilePath,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG PathByteLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PDEVICE_OBJECT RootDevice = <span class="literal">NULL</span>;</span><br><span class="line">    PFILE_OBJECT FileObject = <span class="literal">NULL</span>;</span><br><span class="line">    IO_STATUS_BLOCK IoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    FILE_BASIC_INFORMATION BasicInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UNICODE_STRING PathString = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    WCHAR PathBuffer[LARGE_PATH] = <span class="string">L&quot;\\??\\&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CheckPathFromat(FilePath, PathByteLen))</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    RtlCopyMemory(&amp;PathBuffer[<span class="number">4</span>], FilePath, PathByteLen);</span><br><span class="line">    RtlInitUnicodeString(&amp;PathString, PathBuffer);</span><br><span class="line"></span><br><span class="line">    Status = IrpOpenFile(&amp;PathString,</span><br><span class="line">        FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES | SYNCHRONIZE,</span><br><span class="line">        &amp;RootDevice, &amp;FileObject, &amp;IoStatus);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line"></span><br><span class="line">    Status = IrpGetFileInfo(</span><br><span class="line">        RootDevice, FileObject, FileBasicInformation,</span><br><span class="line">        &amp;BasicInfo, <span class="keyword">sizeof</span>(FILE_BASIC_INFORMATION), &amp;IoStatus);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        ObDereferenceObject(FileObject);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (BasicInfo.FileAttributes &amp; FILE_ATTRIBUTE_READONLY)</span><br><span class="line">    &#123;</span><br><span class="line">        BasicInfo.FileAttributes &amp;= ~FILE_ATTRIBUTE_READONLY;</span><br><span class="line">        Status = IrpSetFileInfo(</span><br><span class="line">            RootDevice, FileObject, FileBasicInformation,</span><br><span class="line">            &amp;BasicInfo, <span class="keyword">sizeof</span>(FILE_BASIC_INFORMATION), &amp;IoStatus);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObDereferenceObject(FileObject);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="强删文件函数"><a href="#强删文件函数" class="headerlink" title="强删文件函数"></a>强删文件函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE_BUF_LEN (1024 * 1024 * 20)</span></span><br><span class="line"><span class="function">NTSTATUS <span class="title">MyPowerEraseFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PWCHAR FilePath,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG PathByteLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PDEVICE_OBJECT RootDevice = <span class="literal">NULL</span>;</span><br><span class="line">    PFILE_OBJECT FileObject = <span class="literal">NULL</span>;</span><br><span class="line">    IO_STATUS_BLOCK IoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SECTION_OBJECT_POINTERS ObjPointer = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    FILE_DISPOSITION_INFORMATION DispInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    FILE_STANDARD_INFORMATION StandInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    PFILE_RENAME_INFORMATION RenameInfo = <span class="literal">NULL</span>;</span><br><span class="line">    UNICODE_STRING PathString = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    WCHAR PathBuffer[LARGE_PATH] = <span class="string">L&quot;\\??\\&quot;</span>;</span><br><span class="line">    LARGE_INTEGER ByteOffset = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CheckPathFromat(FilePath, PathByteLen))</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    RtlCopyMemory(&amp;PathBuffer[<span class="number">4</span>], FilePath, PathByteLen);</span><br><span class="line">    RtlInitUnicodeString(&amp;PathString, PathBuffer);</span><br><span class="line"></span><br><span class="line">    Status = IrpOpenFile(&amp;PathString, FILE_GENERIC_READ,</span><br><span class="line">        &amp;RootDevice, &amp;FileObject, &amp;IoStatus);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line"></span><br><span class="line">    Status = IrpGetFileInfo(RootDevice, FileObject, FileStandardInformation,</span><br><span class="line">        &amp;StandInfo, <span class="keyword">sizeof</span>(FILE_STANDARD_INFORMATION), &amp;IoStatus);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        ObDereferenceObject(FileObject);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StandInfo.EndOfFile.QuadPart &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        PVOID WriteBuffer = ExAllocatePoolWithTag(NonPagedPoolNx, WRITE_BUF_LEN, &#x27;test&#x27;);</span><br><span class="line">        <span class="keyword">if</span> (!WriteBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            ObDereferenceObject(FileObject);</span><br><span class="line">            <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(WriteBuffer, <span class="number">0</span>, WRITE_BUF_LEN);</span><br><span class="line">        <span class="keyword">while</span> ((ByteOffset.QuadPart + WRITE_BUF_LEN) &lt; StandInfo.EndOfFile.QuadPart)</span><br><span class="line">        &#123;</span><br><span class="line">            Status = IrpWriteFile(RootDevice, FileObject, WriteBuffer,</span><br><span class="line">                WRITE_BUF_LEN, &amp;ByteOffset, &amp;IoStatus);</span><br><span class="line">            <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">            &#123;</span><br><span class="line">                ExFreePool(WriteBuffer);</span><br><span class="line">                ObDereferenceObject(FileObject);</span><br><span class="line">                <span class="keyword">return</span> Status;</span><br><span class="line">            &#125;</span><br><span class="line">            ByteOffset.QuadPart += WRITE_BUF_LEN;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Status = IrpWriteFile(RootDevice, FileObject, WriteBuffer,</span><br><span class="line">            (ULONG)(StandInfo.EndOfFile.QuadPart - ByteOffset.QuadPart), &amp;ByteOffset, &amp;IoStatus);</span><br><span class="line">        ExFreePool(WriteBuffer);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">        &#123;</span><br><span class="line">            ObDereferenceObject(FileObject);</span><br><span class="line">            <span class="keyword">return</span> Status;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RenameInfo = (PFILE_RENAME_INFORMATION)PathBuffer;</span><br><span class="line">    RenameInfo-&gt;ReplaceIfExists = FALSE;</span><br><span class="line">    RenameInfo-&gt;RootDirectory = <span class="literal">NULL</span>;</span><br><span class="line">    RenameInfo-&gt;FileNameLength = <span class="keyword">sizeof</span>(<span class="string">L&quot;abcdefghi.txt&quot;</span>) - <span class="keyword">sizeof</span>(WCHAR);</span><br><span class="line">    RtlCopyMemory(RenameInfo-&gt;FileName, <span class="string">L&quot;abcdefghi.txt&quot;</span>, <span class="keyword">sizeof</span>(<span class="string">L&quot;abcdefghi.txt&quot;</span>));</span><br><span class="line">    Status = IrpSetFileInfo(RootDevice, FileObject, FileRenameInformation,</span><br><span class="line">        RenameInfo, LARGE_PATH * <span class="keyword">sizeof</span>(WCHAR), &amp;IoStatus);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        ObDereferenceObject(FileObject);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去除文件运行时的检测</span></span><br><span class="line">    <span class="keyword">if</span> (FileObject-&gt;SectionObjectPointer)</span><br><span class="line">    &#123;</span><br><span class="line">        ObjPointer = *(FileObject-&gt;SectionObjectPointer);</span><br><span class="line">        RtlZeroMemory(FileObject-&gt;SectionObjectPointer,</span><br><span class="line">            <span class="keyword">sizeof</span>(SECTION_OBJECT_POINTERS));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置删除文件</span></span><br><span class="line">    DispInfo.DeleteFile = TRUE;</span><br><span class="line">    Status = IrpSetFileInfo(RootDevice, FileObject, FileDispositionInformation,</span><br><span class="line">        &amp;DispInfo, <span class="keyword">sizeof</span>(FILE_DISPOSITION_INFORMATION), &amp;IoStatus);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (FileObject-&gt;SectionObjectPointer)</span><br><span class="line">    &#123;</span><br><span class="line">        *(FileObject-&gt;SectionObjectPointer) = ObjPointer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ObDereferenceObject(FileObject);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="关闭句柄占用"><a href="#关闭句柄占用" class="headerlink" title="关闭句柄占用"></a>关闭句柄占用</h4><p>假如目标文件正在被其他程序占用中，无法独占的方式打开和擦除数据并删除，就需要手动遍历句柄表，<br>关闭占用的句柄。此功能开 <code>verifier</code> 时验证不通过，不开时可以正常执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SystemHandleInformation 16</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_HANDLE_TABLE_ENTRY_INFO</span> &#123;</span></span><br><span class="line">    USHORT UniqueProcessId;</span><br><span class="line">    USHORT CreatorBackTraceIndex;</span><br><span class="line">    UCHAR ObjectTypeIndex;</span><br><span class="line">    UCHAR HandleAttributes;</span><br><span class="line">    USHORT HandleValue;</span><br><span class="line">    PVOID Object;</span><br><span class="line">    ULONG GrantedAccess;</span><br><span class="line">&#125; SYSTEM_HANDLE_TABLE_ENTRY_INFO, *PSYSTEM_HANDLE_TABLE_ENTRY_INFO;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SYSTEM_HANDLE_INFORMATION</span> &#123;</span></span><br><span class="line">    ULONG NumberOfHandles;</span><br><span class="line">    SYSTEM_HANDLE_TABLE_ENTRY_INFO Handles[<span class="number">1</span>];</span><br><span class="line">&#125; SYSTEM_HANDLE_INFORMATION, *PSYSTEM_HANDLE_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">ZwQuerySystemInformation</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG SystemInformationClass,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT PVOID SystemInformation,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG SystemInformationLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PULONG ReturnLength OPTIONAL)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">POBJECT_TYPE <span class="title">ObGetObjectType</span><span class="params">(IN PVOID Object)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用 <code>ZwQuerySystemInformation</code> 遍历句柄表，使用 <code>ObGetObjectType</code> 获取句柄对应的类型</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">CloseFileHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PUNICODE_STRING VolumePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PSYSTEM_HANDLE_INFORMATION HandelTable = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG HandleTableSize = <span class="number">0x80000</span>;</span><br><span class="line">    PSYSTEM_HANDLE_TABLE_ENTRY_INFO EntryInfo = <span class="number">0</span>;</span><br><span class="line">    POBJECT_TYPE ObjectType = <span class="literal">NULL</span>;</span><br><span class="line">    PFILE_OBJECT FileObject = <span class="literal">NULL</span>;</span><br><span class="line">    POBJECT_NAME_INFORMATION NameInfo = <span class="literal">NULL</span>;</span><br><span class="line">    WCHAR PathBuffer[LARGE_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ULONG RetLen = <span class="number">0</span>;</span><br><span class="line">    OBJECT_ATTRIBUTES ObjAttrib = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    HANDLE ProcessHandle = <span class="literal">NULL</span>;</span><br><span class="line">    CLIENT_ID ClientID = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!VolumePath || !VolumePath-&gt;Buffer || !VolumePath-&gt;Length)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 句柄表变化频繁需要多次查询</span></span><br><span class="line">        HandelTable = (PSYSTEM_HANDLE_INFORMATION)ExAllocatePoolWithTag(</span><br><span class="line">            NonPagedPoolNx, HandleTableSize, &#x27;test&#x27;);</span><br><span class="line">        <span class="keyword">if</span> (!HandelTable)</span><br><span class="line">            <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">        RtlZeroMemory(HandelTable, HandleTableSize);</span><br><span class="line">        Status = ZwQuerySystemInformation(</span><br><span class="line">            SystemHandleInformation, HandelTable, HandleTableSize, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">        &#123;</span><br><span class="line">            ExFreePool(HandelTable);</span><br><span class="line">            <span class="keyword">if</span> (Status != STATUS_INFO_LENGTH_MISMATCH)</span><br><span class="line">                <span class="keyword">return</span> Status;</span><br><span class="line">            HandleTableSize *= <span class="number">2</span>; <span class="comment">// 2倍增长</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (!NT_SUCCESS(Status));</span><br><span class="line">    <span class="comment">// 循环遍历句柄表</span></span><br><span class="line">    NameInfo = (POBJECT_NAME_INFORMATION)PathBuffer;</span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; HandelTable-&gt;NumberOfHandles; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        EntryInfo = &amp;HandelTable-&gt;Handles[i];</span><br><span class="line">        FileObject = (PFILE_OBJECT)EntryInfo-&gt;Object;</span><br><span class="line">        ObjectType = ObGetObjectType(EntryInfo-&gt;Object);</span><br><span class="line">        <span class="comment">// 不处理当前进程的句柄</span></span><br><span class="line">        <span class="keyword">if</span> ((HANDLE)EntryInfo-&gt;UniqueProcessId == PsGetCurrentProcessId())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 检测是否是文件对象</span></span><br><span class="line">        <span class="keyword">if</span> ((*IoFileObjectType != ObjectType) || (FileObject-&gt;Type != <span class="number">5</span>))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 获取文件对象的全路径</span></span><br><span class="line">        RtlZeroMemory(PathBuffer, LARGE_PATH * <span class="keyword">sizeof</span>(WCHAR));</span><br><span class="line">        Status = ObQueryNameString(</span><br><span class="line">            FileObject, NameInfo, LARGE_PATH * <span class="keyword">sizeof</span>(WCHAR), &amp;RetLen);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 比较文件全路径</span></span><br><span class="line">        <span class="keyword">if</span> (!RtlEqualUnicodeString(VolumePath, &amp;NameInfo-&gt;Name, TRUE))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 通过复制句柄的方式关闭</span></span><br><span class="line">        ClientID.UniqueProcess = (HANDLE)EntryInfo-&gt;UniqueProcessId;</span><br><span class="line">        InitializeObjectAttributes(&amp;ObjAttrib, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        Status = ZwOpenProcess(</span><br><span class="line">            &amp;ProcessHandle, PROCESS_DUP_HANDLE, &amp;ObjAttrib, &amp;ClientID);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">continue</span>;</span><br><span class="line">        Status = ZwDuplicateObject(</span><br><span class="line">            ProcessHandle, (HANDLE)EntryInfo-&gt;HandleValue,</span><br><span class="line">            <span class="literal">NULL</span>, <span class="literal">NULL</span>, PROCESS_DUP_HANDLE, <span class="number">0</span>, DUPLICATE_CLOSE_SOURCE);</span><br><span class="line">        ZwClose(ProcessHandle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取文件对应的卷设备路径</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">MyPowerCloseFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PWCHAR FilePath,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG PathByteLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE LinkHandle = <span class="literal">NULL</span>;</span><br><span class="line">    OBJECT_ATTRIBUTES ObjAttrib = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    UNICODE_STRING DosName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    WCHAR DosBuffer[<span class="number">8</span>] = <span class="string">L&quot;\\??\\C:&quot;</span>;</span><br><span class="line">    UNICODE_STRING VolumeName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UNICODE_STRING PathString = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    WCHAR PathBuffer[LARGE_PATH] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (KeGetCurrentIrql() != PASSIVE_LEVEL)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!CheckPathFromat(FilePath, PathByteLen))</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line"></span><br><span class="line">    DosBuffer[<span class="number">4</span>] = FilePath[<span class="number">0</span>];</span><br><span class="line">    RtlInitUnicodeString(&amp;DosName, DosBuffer);</span><br><span class="line"></span><br><span class="line">    InitializeObjectAttributes(&amp;ObjAttrib, &amp;DosName,</span><br><span class="line">        OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    Status = ZwOpenSymbolicLinkObject(&amp;LinkHandle, GENERIC_READ, &amp;ObjAttrib);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line"></span><br><span class="line">    VolumeName.Length = <span class="number">0</span>;</span><br><span class="line">    VolumeName.Buffer = PathBuffer;</span><br><span class="line">    VolumeName.MaximumLength = LARGE_PATH * <span class="keyword">sizeof</span>(WCHAR);</span><br><span class="line"></span><br><span class="line">    Status = ZwQuerySymbolicLinkObject(LinkHandle, &amp;VolumeName, <span class="literal">NULL</span>);</span><br><span class="line">    ZwClose(LinkHandle);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line"></span><br><span class="line">    RtlCopyMemory(&amp;PathBuffer[VolumeName.Length / <span class="keyword">sizeof</span>(WCHAR)],</span><br><span class="line">        &amp;FilePath[<span class="number">2</span>], PathByteLen - (<span class="keyword">sizeof</span>(WCHAR) * <span class="number">2</span>));</span><br><span class="line">    RtlInitUnicodeString(&amp;PathString, PathBuffer);</span><br><span class="line"></span><br><span class="line">    Status = CloseFileHandle(&amp;PathString);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>绕过UAC进行提权操作(1)</title>
    <url>/2021/03/15/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E7%BB%95%E8%BF%87UAC%E8%BF%9B%E8%A1%8C%E6%8F%90%E6%9D%83%E6%93%8D%E4%BD%9C-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>通常情况下我们登录的用户都是Users权限，只能进行有限的操作，当我们需要请求<br>Administrators权限时，操作系统就会弹出UAC提示框，那么如何绕过这个UAC提示框呢</p>
<p>可参考项目：<a href="https://github.com/hfiref0x/UACME">https://github.com/hfiref0x/UACME</a> 来选择绕过的方式</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>绕过UAC的基本原理就是：操作系统有一个提权时不会弹出UAC的白名单，我们就是借助于<br>这些白名单的程序，来启动我们自己的程序，从而实现提权但不弹出UAC提示窗。</p>
]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>遍历系统已加载的驱动文件(1)</title>
    <url>/2021/05/13/%E6%94%BB%E9%98%B2%E4%BF%9D%E6%8A%A4/%E9%81%8D%E5%8E%86%E7%B3%BB%E7%BB%9F%E5%B7%B2%E5%8A%A0%E8%BD%BD%E7%9A%84%E9%A9%B1%E5%8A%A8%E6%96%87%E4%BB%B6-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在一些场景下，我们需要知道某些驱动是否已加载，这就需要遍历操作系统中的驱动，<br>大致可以使用三种方法来进行遍历。</p>
<h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><h5 id="1-遍历”-Driver”中的对象"><a href="#1-遍历”-Driver”中的对象" class="headerlink" title="1.遍历”\Driver”中的对象"></a>1.遍历”\Driver”中的对象</h5><p>我们使用微软提供的 <code>WinObj.exe</code> 工具，可以查看 <code>&quot;\Driver&quot;</code> 对象目录下的信息，<br>这里存储着已加载的 <code>驱动服务名</code>，假如 <code>驱动名称</code> 和 <code>服务名称</code> 不一致，就无法查到真实驱动名。</p>
<p>实现的方法是使用 <code>ntdll.dll</code> 中的 <code>NtOpenDirectoryObject</code> 和 <code>NtQueryDirectoryObject</code> 函数，<br>假如在驱动中使用该方法，需要调用对应的 <code>ZwXXX</code> 函数，代码如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DIRECTORY_QUERY         (0x0001)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBJ_CASE_INSENSITIVE    0x00000040L</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_SUCCESS          ((NTSTATUS)0x00000000L)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_MORE_ENTRIES     ((NTSTATUS)0x00000105L)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_BUFFER_TOO_SMALL ((NTSTATUS)0xC0000023L)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> ULONG NTSTATUS;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">UNICODE_STRING</span> &#123;</span></span><br><span class="line">    USHORT Length;</span><br><span class="line">    USHORT MaximumLength;</span><br><span class="line">    PWSTR Buffer;</span><br><span class="line">&#125; UNICODE_STRING, *PUNICODE_STRING;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  _<span class="title">OBJECT_ATTRIBUTES</span> &#123;</span></span><br><span class="line">    ULONG Length;</span><br><span class="line">    HANDLE RootDirectory;</span><br><span class="line">    PUNICODE_STRING ObjectName;</span><br><span class="line">    ULONG Attributes;</span><br><span class="line">    PSECURITY_DESCRIPTOR SecurityDescriptor;</span><br><span class="line">    PSECURITY_QUALITY_OF_SERVICE SecurityQualityOfService;</span><br><span class="line">&#125; OBJECT_ATTRIBUTES, *POBJECT_ATTRIBUTES;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  _<span class="title">DIRECTORY_BASIC_INFORMATION</span> &#123;</span></span><br><span class="line">    UNICODE_STRING ObjectName;</span><br><span class="line">    UNICODE_STRING ObjectTypeName;</span><br><span class="line">&#125; DIRECTORY_BASIC_INFORMATION, *PDIRECTORY_BASIC_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> InitializeObjectAttributes(p,n,a,r,s)&#123;\</span></span><br><span class="line">    (p)-&gt;Length = <span class="keyword">sizeof</span>(OBJECT_ATTRIBUTES);  \</span><br><span class="line">    (p)-&gt;RootDirectory = r;                   \</span><br><span class="line">    (p)-&gt;Attributes = a;                      \</span><br><span class="line">    (p)-&gt;ObjectName = n;                      \</span><br><span class="line">    (p)-&gt;SecurityDescriptor = s;              \</span><br><span class="line">    (p)-&gt;SecurityQualityOfService = <span class="literal">NULL</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">VOID</span><span class="params">(NTAPI *RTLINITUNICODESTRING)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PUNICODE_STRING DestinationString,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PCWSTR SourceString)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI *NTOPENDIRECTORYOBJECT)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PHANDLE DirectoryHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN POBJECT_ATTRIBUTES ObjectAttributes)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI *NTQUERYDIRECTORYOBJECT)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN HANDLE DirectoryHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PVOID Buffer,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG BufferLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN BOOLEAN ReturnSingleEntry,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN BOOLEAN RestartScan,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT PULONG Context,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PULONG ReturnLength OPTIONAL)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">NTSTATUS</span><span class="params">(NTAPI *NTCLOSE)</span><span class="params">(IN HANDLE Handle)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">EnumDriverDirectoryObject</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HMODULE hNtdll = LoadLibraryW(<span class="string">L&quot;ntdll.dll&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hNtdll) <span class="keyword">return</span> FALSE;</span><br><span class="line"></span><br><span class="line">    RTLINITUNICODESTRING fnRtlInitUnicodeString =</span><br><span class="line">        (RTLINITUNICODESTRING)GetProcAddress(hNtdll, <span class="string">&quot;RtlInitUnicodeString&quot;</span>);</span><br><span class="line">    NTOPENDIRECTORYOBJECT fnNtOpenDirectoryObject =</span><br><span class="line">        (NTOPENDIRECTORYOBJECT)GetProcAddress(hNtdll, <span class="string">&quot;NtOpenDirectoryObject&quot;</span>);</span><br><span class="line">    NTQUERYDIRECTORYOBJECT fnNtQueryDirectoryObject =</span><br><span class="line">        (NTQUERYDIRECTORYOBJECT)GetProcAddress(hNtdll, <span class="string">&quot;NtQueryDirectoryObject&quot;</span>);</span><br><span class="line">    NTCLOSE fnNtClose = (NTCLOSE)GetProcAddress(hNtdll, <span class="string">&quot;NtClose&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!fnRtlInitUnicodeString || !fnNtOpenDirectoryObject ||</span><br><span class="line">        !fnNtQueryDirectoryObject || !fnNtClose)</span><br><span class="line">    &#123;</span><br><span class="line">        FreeLibrary(hNtdll);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    UNICODE_STRING strDirName = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OBJECT_ATTRIBUTES objAttrib = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    fnRtlInitUnicodeString(&amp;strDirName, <span class="string">L&quot;\\Driver&quot;</span>);</span><br><span class="line">    InitializeObjectAttributes(</span><br><span class="line">        &amp;objAttrib, &amp;strDirName, OBJ_CASE_INSENSITIVE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    HANDLE hDirectory = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS ntStatus = fnNtOpenDirectoryObject(&amp;hDirectory, DIRECTORY_QUERY, &amp;objAttrib);</span><br><span class="line">    <span class="keyword">if</span> (ntStatus != STATUS_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        FreeLibrary(hNtdll);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ULONG ulRet = <span class="number">0</span>;</span><br><span class="line">    ULONG ulContext = <span class="number">0</span>;</span><br><span class="line">    ULONG ulLength = <span class="number">0x800</span>;</span><br><span class="line">    PDIRECTORY_BASIC_INFORMATION pBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (!pBuffer) <span class="built_in">free</span>(pBuffer);</span><br><span class="line">        ulLength = ulLength * <span class="number">2</span>;</span><br><span class="line">        pBuffer = (PDIRECTORY_BASIC_INFORMATION)<span class="built_in">malloc</span>(ulLength);</span><br><span class="line">        <span class="keyword">if</span> (!pBuffer)</span><br><span class="line">        &#123;</span><br><span class="line">            fnNtClose(hDirectory);</span><br><span class="line">            FreeLibrary(hNtdll);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        ntStatus = fnNtQueryDirectoryObject(</span><br><span class="line">            hDirectory, pBuffer, ulLength, FALSE, TRUE, &amp;ulContext, &amp;ulRet);</span><br><span class="line">    &#125; <span class="keyword">while</span> (ntStatus == STATUS_MORE_ENTRIES || ntStatus == STATUS_BUFFER_TOO_SMALL);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ntStatus != STATUS_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(pBuffer);</span><br><span class="line">        fnNtClose(hDirectory);</span><br><span class="line">        FreeLibrary(hNtdll);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PDIRECTORY_BASIC_INFORMATION pBuffer2 = pBuffer;</span><br><span class="line">    <span class="keyword">while</span> (pBuffer2-&gt;ObjectName.Buffer &amp;&amp; pBuffer2-&gt;ObjectName.Length &amp;&amp;</span><br><span class="line">        pBuffer2-&gt;ObjectTypeName.Buffer &amp;&amp; pBuffer2-&gt;ObjectTypeName.Length)</span><br><span class="line">    &#123;</span><br><span class="line">        pBuffer2-&gt;ObjectName; <span class="comment">// 服务名</span></span><br><span class="line">        pBuffer2-&gt;ObjectTypeName; <span class="comment">// 类型driver</span></span><br><span class="line">        pBuffer2++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(pBuffer);</span><br><span class="line">    fnNtClose(hDirectory);</span><br><span class="line">    FreeLibrary(hNtdll);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="2-遍历系统加载模块"><a href="#2-遍历系统加载模块" class="headerlink" title="2.遍历系统加载模块"></a>2.遍历系统加载模块</h5><p>使用 <code>ntdll</code> 中的 <code>NtQuerySystemInformation</code> 函数，指定 <code>SYSTEM_INFORMATION_CLASS</code> 为 <code>11</code>，<br>可以查询到当前系统已加载的 <code>dll</code> 和 <code>sys</code> 文件，在驱动中要使用 <code>ZwQuerySystemInformation</code> 函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winternl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ntdll.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_SUCCESS                   ((NTSTATUS)0x00000000L)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_UNSUCCESSFUL              ((NTSTATUS)0xC0000001L)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_INFO_LENGTH_MISMATCH      ((NTSTATUS)0xC0000004L)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STATUS_INSUFFICIENT_RESOURCES    ((NTSTATUS)0xC000009AL)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_PROCESS_MODULE_INFORMATION</span> &#123;</span></span><br><span class="line">    HANDLE Section;</span><br><span class="line">    PVOID MappedBase;</span><br><span class="line">    PVOID ImageBase;</span><br><span class="line">    ULONG ImageSize;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadOrderIndex;</span><br><span class="line">    USHORT InitOrderIndex;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT OffsetToFileName;</span><br><span class="line">    CHAR FullPathName[<span class="number">256</span>];</span><br><span class="line">&#125; RTL_PROCESS_MODULE_INFORMATION, *PRTL_PROCESS_MODULE_INFORMATION;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">RTL_PROCESS_MODULES</span> &#123;</span></span><br><span class="line">    ULONG NumberOfModules;</span><br><span class="line">    RTL_PROCESS_MODULE_INFORMATION Modules[<span class="number">1</span>];</span><br><span class="line">&#125; RTL_PROCESS_MODULES, *PRTL_PROCESS_MODULES; <span class="comment">// wrk1.2中的定义</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">EnumSystemDriverModule</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG RetLen = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// SystemModuleInformation 11</span></span><br><span class="line">    NTSTATUS Status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)<span class="number">11</span>, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;RetLen);</span><br><span class="line">    <span class="keyword">if</span> (Status != STATUS_INFO_LENGTH_MISMATCH) <span class="keyword">return</span> Status;</span><br><span class="line"></span><br><span class="line">    PVOID Buffer = <span class="built_in">malloc</span>(RetLen * <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">if</span> (!Buffer) <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line"></span><br><span class="line">    Status = NtQuerySystemInformation((SYSTEM_INFORMATION_CLASS)<span class="number">11</span>, Buffer, RetLen * <span class="number">2</span>, &amp;RetLen);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(Buffer);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    PRTL_PROCESS_MODULES ModInfo = (PRTL_PROCESS_MODULES)Buffer;</span><br><span class="line">    <span class="keyword">if</span> (!ModInfo-&gt;NumberOfModules)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(Buffer);</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL; <span class="comment">// 不为0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (ULONG i = <span class="number">0</span>; i &lt; ModInfo-&gt;NumberOfModules; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 包含dll和sys文件，需要根据后缀过滤</span></span><br><span class="line">        <span class="comment">// 会出现\\SystemRoot\\前缀，或者\\??\\C:前缀，需要转换</span></span><br><span class="line">        <span class="comment">// 在内核中使用ZwOpenFile和IoQueryFileDosDeviceName查询</span></span><br><span class="line">        ModInfo-&gt;Modules[i].FullPathName; <span class="comment">// 模块路径</span></span><br><span class="line">        ModInfo-&gt;Modules[i].OffsetToFileName; <span class="comment">// 名字在路径中的偏移</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(Buffer);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3-遍历驱动的模块链表"><a href="#3-遍历驱动的模块链表" class="headerlink" title="3.遍历驱动的模块链表"></a>3.遍历驱动的模块链表</h5><p>使用 <code>ZwQuerySystemInformation</code> 函数查询系统模块，本质上也是在对 <code>DRIVER_OBJECT</code> 中的<br><code>DriverSection</code> 成员指向的 <code>LDR_DATA_TABLE_ENTRY</code> 链表进行遍历，所以我们可以手动遍历它，<br>注意：只要涉及到链表的操作，就必须要考虑多线程竞争的问题，所以不推荐这种操作。在不同的<br>系统中 <code>LDR_DATA_TABLE_ENTRY</code> 可能会有变化，可以用 <code>WinDbg</code> 进行确认</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">LDR_DATA_TABLE_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY InLoadOrderLinks;</span><br><span class="line">    LIST_ENTRY InMemoryOrderLinks;</span><br><span class="line">    LIST_ENTRY InInitializationOrderLinks;</span><br><span class="line">    PVOID DllBase;</span><br><span class="line">    PVOID EntryPoint;</span><br><span class="line">    ULONG SizeOfImage;</span><br><span class="line">    UNICODE_STRING FullDllName;</span><br><span class="line">    UNICODE_STRING BaseDllName;</span><br><span class="line">    ULONG Flags;</span><br><span class="line">    USHORT LoadCount;</span><br><span class="line">    USHORT TlsIndex;</span><br><span class="line">    LIST_ENTRY HashLinks;</span><br><span class="line">    ULONG TimeDateStamp;</span><br><span class="line">&#125; LDR_DATA_TABLE_ENTRY, *PLDR_DATA_TABLE_ENTRY; <span class="comment">// 没改变的部分</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">EnumSystemModule</span><span class="params">(PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PLIST_ENTRY Entry = <span class="literal">NULL</span>;</span><br><span class="line">    PLDR_DATA_TABLE_ENTRY ListEntry = <span class="literal">NULL</span>;</span><br><span class="line">    PLDR_DATA_TABLE_ENTRY TableEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!DriverObject) <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">    <span class="comment">// 在这里有驱动自身的信息</span></span><br><span class="line">    ListEntry = (PLDR_DATA_TABLE_ENTRY)DriverObject-&gt;DriverSection;</span><br><span class="line">    <span class="comment">// 遍历子链表，注意多线程竞争的问题</span></span><br><span class="line">    Entry = ListEntry-&gt;InLoadOrderLinks.Flink;</span><br><span class="line">    <span class="keyword">while</span> (Entry != &amp;ListEntry-&gt;InLoadOrderLinks)</span><br><span class="line">    &#123;</span><br><span class="line">        TableEntry = CONTAINING_RECORD(Entry, LDR_DATA_TABLE_ENTRY, InLoadOrderLinks);</span><br><span class="line">        <span class="keyword">if</span> (TableEntry-&gt;FullDllName.Buffer &amp;&amp; TableEntry-&gt;FullDllName.Length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 模块的路径，非全路径，测试时发现第1个信息为空，遍历完子链表不包含自身信息</span></span><br><span class="line">            DbgPrint(<span class="string">&quot;%p: %wZ\n&quot;</span>, TableEntry-&gt;DllBase, TableEntry-&gt;FullDllName);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry = Entry-&gt;Flink;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>攻防保护</category>
      </categories>
      <tags>
        <tag>攻防保护</tag>
      </tags>
  </entry>
  <entry>
    <title>内核驱动实现键盘按键过滤(2)</title>
    <url>/2019/07/14/%E6%8C%89%E9%94%AE%E8%BF%87%E6%BB%A4/%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E5%AE%9E%E7%8E%B0%E9%94%AE%E7%9B%98%E6%8C%89%E9%94%AE%E8%BF%87%E6%BB%A4-2/</url>
    <content><![CDATA[<h4 id="内核驱动中实现键盘过滤"><a href="#内核驱动中实现键盘过滤" class="headerlink" title="内核驱动中实现键盘过滤"></a>内核驱动中实现键盘过滤</h4><p>在WINDOWS中所有接入的键盘设备，都存储在 <code>kbdclass.sys</code> 这个驱动中。<br>我们可以通过监控 <code>键盘设备接入</code> 的动作，来遍历 <code>kbdclass.sys</code> 驱动中所有的设备。<br>然后创建 <code>过滤设备</code> 并附加到 <code>键盘设备</code> 上，就可以拦截到该设备 <code>键盘按键</code> 的操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntifs.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddkbd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 键盘设备驱动名称</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> KBD_DRIVER_NAME <span class="meta-string">L&quot;\\Driver\\kbdclass&quot;</span></span></span><br><span class="line"><span class="comment">// 驱动对象的类型</span></span><br><span class="line"><span class="keyword">extern</span> POBJECT_TYPE* IoDriverObjectType;</span><br><span class="line"><span class="comment">// 已附加的设备链表节点定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">ATTACH_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY Entry;</span><br><span class="line">    PDEVICE_OBJECT FilterDevice;</span><br><span class="line">    PDEVICE_OBJECT PhysicalDevice;</span><br><span class="line">&#125; ATTACH_ENTRY, *PATTACH_ENTRY;</span><br><span class="line"><span class="comment">// 设备扩展信息，保存附加的设备</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DEVICE_EXTENSION</span> &#123;</span></span><br><span class="line">    PDEVICE_OBJECT AttachedToDevice;</span><br><span class="line">&#125; DEVICE_EXTENSION, *PDEVICE_EXTENSION;</span><br><span class="line"><span class="comment">// 通过名称获取内核对象，已导出但未文档化的函数</span></span><br><span class="line"><span class="function">NTKERNELAPI NTSTATUS <span class="title">ObReferenceObjectByName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PUNICODE_STRING ObjectName,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG Attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PACCESS_STATE AccessState,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN POBJECT_TYPE ObjectType,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN KPROCESSOR_MODE AccessMode,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT PVOID ParseContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PVOID* Object)</span></span>;</span><br></pre></td></tr></table></figure>

<p>另外我们需要处理 <code>已经附加的设备</code> 的列表，已附加的设备要跳过，设备移除也要删除对应节点</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PATTACH_ENTRY <span class="title">FindPhysicalEntry</span><span class="params">(PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KIRQL OldIrql = <span class="number">0</span>;</span><br><span class="line">    PLIST_ENTRY Entry = <span class="literal">NULL</span>;</span><br><span class="line">    PATTACH_ENTRY AttachEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 检验参数是否为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (DeviceObject == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    KeAcquireSpinLock(&amp;AttachLock, &amp;OldIrql);</span><br><span class="line">    <span class="keyword">for</span> (Entry = AttachList.Flink; Entry != &amp;AttachList; Entry = Entry-&gt;Flink)</span><br><span class="line">    &#123;</span><br><span class="line">        AttachEntry = CONTAINING_RECORD(Entry, ATTACH_ENTRY, Entry);</span><br><span class="line">        <span class="keyword">if</span> (AttachEntry-&gt;PhysicalDevice == DeviceObject)</span><br><span class="line">        &#123;</span><br><span class="line">            KeReleaseSpinLock(&amp;AttachLock, OldIrql);</span><br><span class="line">            <span class="keyword">return</span> AttachEntry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    KeReleaseSpinLock(&amp;AttachLock, OldIrql);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PATTACH_ENTRY <span class="title">RemoveFilterEntry</span><span class="params">(PDEVICE_OBJECT DeviceObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KIRQL OldIrql = <span class="number">0</span>;</span><br><span class="line">    PLIST_ENTRY Entry = <span class="literal">NULL</span>;</span><br><span class="line">    PATTACH_ENTRY AttachEntry = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 检验参数是否为空指针</span></span><br><span class="line">    <span class="keyword">if</span> (DeviceObject == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 遍历链表</span></span><br><span class="line">    KeAcquireSpinLock(&amp;AttachLock, &amp;OldIrql);</span><br><span class="line">    <span class="keyword">for</span> (Entry = AttachList.Flink; Entry != &amp;AttachList; Entry = Entry-&gt;Flink)</span><br><span class="line">    &#123;</span><br><span class="line">        AttachEntry = CONTAINING_RECORD(Entry, ATTACH_ENTRY, Entry);</span><br><span class="line">        <span class="keyword">if</span> (AttachEntry-&gt;FilterDevice == DeviceObject)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 移除节点</span></span><br><span class="line">            RemoveEntryList(&amp;AttachEntry-&gt;Entry);</span><br><span class="line">            KeReleaseSpinLock(&amp;AttachLock, OldIrql);</span><br><span class="line">            <span class="keyword">return</span> AttachEntry;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    KeReleaseSpinLock(&amp;AttachLock, OldIrql);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="过滤驱动的处理"><a href="#过滤驱动的处理" class="headerlink" title="过滤驱动的处理"></a>过滤驱动的处理</h4><p>我们需要处理的驱动 <code>派遣函数</code>为  <code>IRP_MJ_READ</code> <code>IRP_MJ_POWER</code> <code>IRP_MJ_PNP</code> 共三项</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_READ] = DispatchRead;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_POWER] = DispatchPower;</span><br><span class="line">DriverObject-&gt;MajorFunction[IRP_MJ_PNP] = DispatchPnp;</span><br></pre></td></tr></table></figure>

<p>在 <code>IRP_MJ_READ</code> 中，我们处理获取到的 <code>键盘按键</code> 信息，注意是在 <code>完成函数</code> 中处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DispatchRead</span><span class="params">(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PDEVICE_EXTENSION DevExt = (PDEVICE_EXTENSION)DeviceObject-&gt;DeviceExtension;</span><br><span class="line">    <span class="comment">// 设置完成函数ReadCompletion</span></span><br><span class="line">    IoCopyCurrentIrpStackLocationToNext(Irp);</span><br><span class="line">    IoSetCompletionRoutine(Irp, ReadCompletion, <span class="literal">NULL</span>, TRUE, TRUE, TRUE);</span><br><span class="line">    <span class="keyword">return</span> IoCallDriver(DevExt-&gt;AttachedToDevice, Irp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">ReadCompletion</span><span class="params">(PDEVICE_OBJECT DeviceObject, PIRP Irp, PVOID Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG_PTR Index = <span class="number">0</span>;</span><br><span class="line">    ULONG_PTR NumKeys = <span class="number">0</span>;</span><br><span class="line">    PIO_STACK_LOCATION IrpSp = <span class="literal">NULL</span>;</span><br><span class="line">    PKEYBOARD_INPUT_DATA KeyData = <span class="literal">NULL</span>;</span><br><span class="line">    UNREFERENCED_PARAMETER(DeviceObject);</span><br><span class="line">    UNREFERENCED_PARAMETER(Context);</span><br><span class="line">    <span class="comment">// 如果读取键盘的操作成功</span></span><br><span class="line">    IrpSp = IoGetCurrentIrpStackLocation(Irp);</span><br><span class="line">    <span class="keyword">if</span> (Irp-&gt;IoStatus.Status == STATUS_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 系统在SystemBuffer中保存按键信息</span></span><br><span class="line">        KeyData = Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">        <span class="keyword">if</span> (KeyData != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取按键的数量</span></span><br><span class="line">            NumKeys = Irp-&gt;IoStatus.Information / <span class="keyword">sizeof</span>(KEYBOARD_INPUT_DATA);</span><br><span class="line">            <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; NumKeys; Index++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 检查按键码</span></span><br><span class="line">                <span class="keyword">if</span> (bKeyboardLock) <span class="comment">// 如果开启了过滤</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// (KeyData[Index].MakeCode == 29) // CTRL</span></span><br><span class="line">                    <span class="keyword">if</span> ((KeyData[Index].MakeCode == <span class="number">1</span>) || <span class="comment">// ESC</span></span><br><span class="line">                        (KeyData[Index].MakeCode == <span class="number">56</span>) || <span class="comment">// ALT</span></span><br><span class="line">                        (KeyData[Index].MakeCode == <span class="number">91</span>)) <span class="comment">// WIN</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="comment">// 把按下键修改为弹起键</span></span><br><span class="line">                        <span class="keyword">if</span> (KeyData[Index].Flags == <span class="number">0</span>) KeyData[Index].Flags = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (KeyData[Index].Flags == <span class="number">2</span>) KeyData[Index].Flags = <span class="number">3</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果IRP是PENDING状态，继续标记PENDING</span></span><br><span class="line">    <span class="keyword">if</span> (Irp-&gt;PendingReturned) IoMarkIrpPending(Irp);</span><br><span class="line">    <span class="keyword">return</span> Irp-&gt;IoStatus.Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>IRP_MJ_POWER</code> 中处理电源管理，因为我们是过滤驱动，只需要把IRP直接往下转发就行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DispatchPower</span><span class="params">(PDEVICE_OBJECT DeviceObject, PIRP Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PDEVICE_EXTENSION DevExt = (PDEVICE_EXTENSION)(DeviceObject-&gt;DeviceExtension);</span><br><span class="line">    <span class="comment">// 转发到下层设备，注意VISTA以上系统有变化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> (NTDDI_VERSION &lt; NTDDI_VISTA)</span></span><br><span class="line">    PoStartNextPowerIrp(Irp);</span><br><span class="line">    IoSkipCurrentIrpStackLocation(Irp);</span><br><span class="line">    <span class="keyword">return</span> PoCallDriver(DevExt-&gt;AttachedToDevice, Irp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    IoSkipCurrentIrpStackLocation(Irp);</span><br><span class="line">    <span class="keyword">return</span> IoCallDriver(DevExt-&gt;AttachedToDevice, Irp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>IRP_MJ_PNP</code> 中，我们要处理 <code>键盘设备移除</code> 时，解绑和删除 <code>过滤设备</code> 的操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DispatchPnp</span><span class="params">(PDEVICE_OBJECT DeviceObject, PIRP Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIO_STACK_LOCATION IrpSp = <span class="literal">NULL</span>;</span><br><span class="line">    PDEVICE_EXTENSION DevExt = (PDEVICE_EXTENSION)(DeviceObject-&gt;DeviceExtension);</span><br><span class="line">    <span class="comment">// 处理子功能</span></span><br><span class="line">    IrpSp = IoGetCurrentIrpStackLocation(Irp);</span><br><span class="line">    <span class="keyword">switch</span> (IrpSp-&gt;MinorFunction)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> IRP_MN_REMOVE_DEVICE: <span class="comment">// 设备移除</span></span><br><span class="line">        <span class="comment">// 从过滤设备列表中移除</span></span><br><span class="line">        AttachEntry = RemoveFilterEntry(DeviceObject);</span><br><span class="line">        <span class="keyword">if</span> (AttachEntry != <span class="literal">NULL</span>)</span><br><span class="line">            ExFreePool(AttachEntry);</span><br><span class="line">        <span class="comment">// 解绑和删除过滤设备</span></span><br><span class="line">        IoDetachDevice(DevExt-&gt;AttachedToDevice);</span><br><span class="line">        IoDeleteDevice(DeviceObject);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 跳过当前设备，继续下发</span></span><br><span class="line">    IoSkipCurrentIrpStackLocation(Irp);</span><br><span class="line">    <span class="keyword">return</span> IoCallDriver(DevExt-&gt;AttachedToDevice, Irp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="键盘设备接入的监控"><a href="#键盘设备接入的监控" class="headerlink" title="键盘设备接入的监控"></a>键盘设备接入的监控</h4><p>如何知道有键盘设备接入了呢，可以通过 <code>IoRegisterPlugPlayNotification</code> 函数，来注册一个PNP设备通知</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoRegisterPlugPlayNotification</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     IO_NOTIFICATION_EVENT_CATEGORY        EventCategory,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     ULONG                                 EventCategoryFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ PVOID                                 EventCategoryData,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     PDRIVER_OBJECT                        DriverObject,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     PDRIVER_NOTIFICATION_CALLBACK_ROUTINE CallbackRoutine,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ PVOID                                 Context,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_    PVOID                                 *NotificationEntry</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>通过指定参数 <code>EventCategory</code> 的类型，可以监控PNP设备的某些特定行为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EventCategoryDeviceInterfaceChange</span><br><span class="line"><span class="comment">// PnP events in this category include the arrival (enabling) of a new instance of a</span></span><br><span class="line"><span class="comment">// device interface class (GUID_DEVICE_INTERFACE_ARRIVAL), or the removal (disabling)</span></span><br><span class="line"><span class="comment">// of an existing device interface instance (GUID_DEVICE_INTERFACE_REMOVAL).</span></span><br><span class="line"></span><br><span class="line">EventCategoryHardwareProfileChange</span><br><span class="line"><span class="comment">// PnP events in this category include query-change (GUID_HWPROFILE_QUERY_CHANGE),</span></span><br><span class="line"><span class="comment">// change-complete (GUID_HWPROFILE_CHANGE_COMPLETE), and change-cancel</span></span><br><span class="line"><span class="comment">// (GUID_HWPROFILE_CHANGE_CANCELLED) of a hardware profile.</span></span><br><span class="line"></span><br><span class="line">EventCategoryTargetDeviceChange</span><br><span class="line"><span class="comment">// PnP events in this category include events related to removing a device: the</span></span><br><span class="line"><span class="comment">// device&#x27;s drivers received a query-remove IRP (GUID_TARGET_DEVICE_QUERY_REMOVE),</span></span><br><span class="line"><span class="comment">// the drivers completed a remove IRP (GUID_TARGET_DEVICE_REMOVE_COMPLETE), or the</span></span><br><span class="line"><span class="comment">// drivers received a cancel-remove IRP (GUID_TARGET_DEVICE_REMOVE_CANCELLED). This</span></span><br><span class="line"><span class="comment">// category is also used for custom notification events.</span></span><br></pre></td></tr></table></figure>

<p>我们这里关注的是 <code>EventCategoryDeviceInterfaceChange</code> 类型，可以监控到 <code>设备的接入</code> 动作，<br>相关的GUID信息都在 <code>wdmguid.h</code> 中定义，这里因为只用其中几个信息，就单独拿出来重新定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// GUID_DEVICE_INTERFACE_ARRIVAL</span></span><br><span class="line">GUID GUID_INTERFACE_ARRIVAL = &#123;</span><br><span class="line">    <span class="number">0xcb3a4004</span>, <span class="number">0x46f0</span>, <span class="number">0x11d0</span>, <span class="number">0xb0</span>, <span class="number">0x8f</span>, <span class="number">0x00</span>, <span class="number">0x60</span>, <span class="number">0x97</span>, <span class="number">0x13</span>, <span class="number">0x05</span>, <span class="number">0x3f</span> &#125;;</span><br><span class="line"><span class="comment">// GUID_DEVINTERFACE_KEYBOARD</span></span><br><span class="line">GUID GUID_INTERFACE_KEYBOARD = &#123;</span><br><span class="line">    <span class="number">0x884b96c3</span>, <span class="number">0x56ef</span>, <span class="number">0x11d1</span>, <span class="number">0xbc</span>, <span class="number">0x8c</span>, <span class="number">0x00</span>, <span class="number">0xa0</span>, <span class="number">0xc9</span>, <span class="number">0x14</span>, <span class="number">0x05</span>, <span class="number">0xdd</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>我们要在 <code>DriverEntry</code> 中保存 <code>DriverObject</code> 到全局变量中，因为在 <code>附加设备</code> 时要用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 保存当前驱动对象</span></span><br><span class="line">CurrentDriver = DriverObject;</span><br><span class="line"><span class="comment">// 注册PNP设备通知</span></span><br><span class="line">Status = IoRegisterPlugPlayNotification(</span><br><span class="line">    EventCategoryDeviceInterfaceChange,</span><br><span class="line">    PNPNOTIFY_DEVICE_INTERFACE_INCLUDE_EXISTING_INTERFACES,</span><br><span class="line">    &amp;GUID_INTERFACE_KEYBOARD,</span><br><span class="line">    DriverObject,</span><br><span class="line">    PnpNotifyCallback,</span><br><span class="line">    <span class="literal">NULL</span>,</span><br><span class="line">    &amp;NotificationEntry);</span><br></pre></td></tr></table></figure>

<p>PNP通知的回调函数代码，主要是检测是不是有 <code>键盘设备接入</code> 的动作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">PnpNotifyCallback</span><span class="params">(IN PVOID Structure, IN PVOID Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PGUID pEvent = <span class="literal">NULL</span>;</span><br><span class="line">    UNREFERENCED_PARAMETER(Context);</span><br><span class="line">    <span class="keyword">if</span> (Structure == <span class="literal">NULL</span>) <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    pEvent = &amp;(((PDEVICE_INTERFACE_CHANGE_NOTIFICATION)Structure)-&gt;Event);</span><br><span class="line">    <span class="comment">// 比较内存空间，返回相等的字节数</span></span><br><span class="line">    <span class="keyword">if</span> (RtlEqualMemory(pEvent, &amp;GUID_INTERFACE_ARRIVAL, <span class="keyword">sizeof</span>(GUID)))</span><br><span class="line">    &#123;</span><br><span class="line">        EnumKeyboardDevice(); <span class="comment">// 遍历所有键盘设备</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如下为遍历 <code>kbdclass.sys</code> 驱动中所有键盘设备，并进行附加的操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">EnumKeyboardDevice</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PATTACH_ENTRY AttachEntry = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PDRIVER_OBJECT KBDDriverObject = <span class="literal">NULL</span>;</span><br><span class="line">    PDEVICE_OBJECT KBDDeviceObject = <span class="literal">NULL</span>;</span><br><span class="line">    UNICODE_STRING KBDDriverName = RTL_CONSTANT_STRING(KBD_DRIVER_NAME);</span><br><span class="line">    <span class="comment">// 获取键盘驱动对象以及设备对象</span></span><br><span class="line">    Status = ObReferenceObjectByName(&amp;KBDDriverName, OBJ_CASE_INSENSITIVE,</span><br><span class="line">        <span class="literal">NULL</span>, <span class="number">0</span>, *IoDriverObjectType, KernelMode, <span class="literal">NULL</span>, &amp;KBDDriverObject);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    KBDDeviceObject = KBDDriverObject-&gt;DeviceObject;</span><br><span class="line">    <span class="comment">// 遍历键盘设备对象</span></span><br><span class="line">    <span class="keyword">while</span> (KBDDeviceObject != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        AttachEntry = FindPhysicalEntry(KBDDeviceObject);</span><br><span class="line">        <span class="keyword">if</span> (AttachEntry == <span class="literal">NULL</span>)</span><br><span class="line">            Status = AttachKeyboardDevice(KBDDeviceObject);</span><br><span class="line">        KBDDeviceObject = KBDDeviceObject-&gt;NextDevice;</span><br><span class="line">    &#125;</span><br><span class="line">    ObDereferenceObject(KBDDriverObject);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">AttachKeyboardDevice</span><span class="params">(IN PDEVICE_OBJECT PhysicalDevice)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KIRQL OldIrql = <span class="number">0</span>;</span><br><span class="line">    PATTACH_ENTRY AttachEntry = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PDEVICE_OBJECT FilterDevice = <span class="literal">NULL</span>;</span><br><span class="line">    PDEVICE_EXTENSION DevExt = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 检查参数</span></span><br><span class="line">    <span class="keyword">if</span> (PhysicalDevice == <span class="literal">NULL</span>) <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="comment">// 创建过滤设备对象</span></span><br><span class="line">    Status = IoCreateDevice(CurrentDriver, <span class="keyword">sizeof</span>(DEVICE_EXTENSION), <span class="literal">NULL</span>,</span><br><span class="line">        PhysicalDevice-&gt;DeviceType, PhysicalDevice-&gt;Characteristics, FALSE, &amp;FilterDevice);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 申请链表节点空间</span></span><br><span class="line">    AttachEntry = (PATTACH_ENTRY)EXALLOCATE(<span class="keyword">sizeof</span>(ATTACH_ENTRY));</span><br><span class="line">    <span class="keyword">if</span> (AttachEntry == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        IoDeleteDevice(FilterDevice);</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line">    RtlZeroMemory(AttachEntry, <span class="keyword">sizeof</span>(ATTACH_ENTRY));</span><br><span class="line">    AttachEntry-&gt;FilterDevice = FilterDevice;</span><br><span class="line">    AttachEntry-&gt;PhysicalDevice = PhysicalDevice;</span><br><span class="line">    <span class="comment">// 设置过滤设备标志</span></span><br><span class="line">    FilterDevice-&gt;Flags |= PhysicalDevice-&gt;Flags;</span><br><span class="line">    <span class="comment">// 得到设备扩展结构，以便下面保存过滤设备信息</span></span><br><span class="line">    DevExt = (PDEVICE_EXTENSION)FilterDevice-&gt;DeviceExtension;</span><br><span class="line">    <span class="comment">// 将过滤设备对象附加在目标设备对象之上</span></span><br><span class="line">    DevExt-&gt;AttachedToDevice = IoAttachDeviceToDeviceStack(</span><br><span class="line">        FilterDevice, PhysicalDevice);</span><br><span class="line">    <span class="keyword">if</span> (DeviceExtension-&gt;AttachedToDevice == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePool(AttachEntry);</span><br><span class="line">        IoDeleteDevice(FilterDevice);</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 清除过滤设备初始化标记</span></span><br><span class="line">    FilterDevice-&gt;Flags &amp;= ~DO_DEVICE_INITIALIZING;</span><br><span class="line">    <span class="comment">// 添加到链表中</span></span><br><span class="line">    KeAcquireSpinLock(&amp;AttachLock, &amp;OldIrql);</span><br><span class="line">    InsertTailList(&amp;AttachList, &amp;AttachEntry-&gt;Entry);</span><br><span class="line">    KeReleaseSpinLock(&amp;AttachLock, OldIrql);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里需要注意的是，如果是在 <code>DriverObject-&gt;DriverExtension-&gt;AddDevice</code> 对应的函数中，进行<br>过滤设备的新建和附加，驱动自己会帮我们去除 <code>过滤设备初始化</code> 的标记，而这里需要我们自己手动去除。</p>
]]></content>
      <categories>
        <category>按键过滤</category>
      </categories>
      <tags>
        <tag>按键过滤</tag>
      </tags>
  </entry>
  <entry>
    <title>在内核驱动中模拟键盘按键(2)</title>
    <url>/2019/07/25/%E6%8C%89%E9%94%AE%E8%BF%87%E6%BB%A4/%E5%9C%A8%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E4%B8%AD%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E6%8C%89%E9%94%AE-2/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在驱动中模拟键盘按键的方法，包含 <code>写端口</code> <code>调用KeyboardClassServiceCallback函数</code> <code>虚拟键盘</code> 等。<br>其中 <code>写端口</code> 实现起来最简单，但是只能针对PS/2键盘。而 <code>KeyboardClassServiceCallback</code> 函数未导出，<br>需要我们不同系统去搜索不同的特征码，兼容性不佳。最后一个 <code>虚拟键盘</code> 稳定性最好，但是复杂度特别高。</p>
<h4 id="写端口"><a href="#写端口" class="headerlink" title="写端口"></a>写端口</h4><p>在DOS时代，当我们按下或者放开一个键时，就会产生一个键盘中断（在允许键盘中断的情况下），这样程序<br>会跳转到BIOS中的键盘中断处理程序去执行。</p>
<p>打开windows设备管理器，可以查看到键盘控制器由两个端口控制。其中 <code>0x60</code> 是数据端口，可以读出键盘<br>数据，而 <code>0x64</code> 是控制端口，用来发出控制信号。也就是说，从 <code>0x60</code> 号端口可以读此键盘的按键信息。当<br>从这个端口读取一个字节，该字节的低7位就是按键的扫描码，而高1位则表示是按下键还是释放键。当按下<br>时，最高位为0，称为通码，当释放时，最高位为1，称为断码。</p>
<p>所以我们可以向这个端口写入数据，来模拟按键。如下为示例代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I8042_DATA_PORT ((PUCHAR)0x60)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I8042_CTRL_PORT ((PUCHAR)0x64)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> OBUFFER_FULL 0x01</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOLEAN <span class="title">WaitKeyboardWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INT i = <span class="number">0</span>;</span><br><span class="line">    UCHAR c = <span class="number">0</span>;</span><br><span class="line">    LARGE_INTEGER Interval = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    Interval.QuadPart = <span class="number">-50</span> * <span class="number">1000</span> * <span class="number">10L</span>; <span class="comment">// 50毫秒</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        KeDelayExecutionThread(KernelMode, FALSE, &amp;Interval);</span><br><span class="line">        c = READ_PORT_UCHAR(I8042_CTRL_PORT);</span><br><span class="line">        <span class="keyword">if</span> ((c &amp; OBUFFER_FULL) == OBUFFER_FULL) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i ? TRUE : FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendKeyScanCode</span><span class="params">(IN UCHAR Code)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 等待缓冲区为空</span></span><br><span class="line">    WaitKeyboardWrite();</span><br><span class="line">    <span class="comment">// 写入按键输入指令</span></span><br><span class="line">    WRITE_PORT_UCHAR(I8042_CTRL_PORT, <span class="number">0xD2</span>);</span><br><span class="line">    <span class="comment">// 等待缓冲区为空</span></span><br><span class="line">    WaitKeyboardWrite();</span><br><span class="line">    <span class="comment">// 写入按键扫描码</span></span><br><span class="line">    WRITE_PORT_UCHAR(I8042_DATA_PORT, Code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>在驱动 <code>kbdclass.sys</code> 中，有个函数 <code>KeyboardClassServiceCallback</code> ，作用是往 <code>读取按键的IRP</code> 中<br>添加按键信息，并完成这个 <code>IRP</code>，这个函数的声明如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">KeyboardClassServiceCallback</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    PDEVICE_OBJECT       DeviceObject,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    PKEYBOARD_INPUT_DATA InputDataStart,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    PKEYBOARD_INPUT_DATA InputDataEnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ PULONG               InputDataConsumed</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>DeviceObject</code> 为任意键盘设备，一般情况下我们使用 <code>L&quot;\\Device\\KeyboardClass0&quot;</code> 这个设备，<br><code>InputDataStart</code> 和 <code>InputDataEnd</code> 表示输入的按键信息的 <code>起始</code> 和 <code>结束</code> 地址，而 <code>InputDataConsumed</code><br>表示按键信息的数量。按键信息结构体如下所示 </p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">KEYBOARD_INPUT_DATA</span> &#123;</span></span><br><span class="line">  USHORT UnitId;</span><br><span class="line">  USHORT MakeCode;</span><br><span class="line">  USHORT Flags;</span><br><span class="line">  USHORT Reserved;</span><br><span class="line">  ULONG  ExtraInformation;</span><br><span class="line">&#125; KEYBOARD_INPUT_DATA, *PKEYBOARD_INPUT_DATA;</span><br></pre></td></tr></table></figure>

<p>我们只关注 <code>MakeCode</code> 和 <code>Flags</code> 两个参数，其中 <code>MakeCode</code> 是按键的扫描码，而 <code>Flags</code> 表示按键的动作，<br><code>KEY_MAKE</code> 和 <code>KEY_E0</code> 表示 <code>普通键</code> 和 <code>扩展键</code> 的 <code>按下</code>，<code>KEY_BREAK</code> 和 <code>KEY_E1</code> 表示相应的 <code>弹起</code> 动作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Keyboard Scan Codes (Numerical Order)</span><br><span class="line">---------------+---------------+---------------+---------------+---------------</span><br><span class="line">HEX DEC keys   |HEX DEC keys   |HEX DEC keys   |HEX DEC keys   |HEX DEC keys</span><br><span class="line">---------------+---------------+---------------+---------------+---------------</span><br><span class="line">               |10  16  Q      |20  32  D      |30  48  B      |40  64  F6</span><br><span class="line">01   1  ESC    |11  17  W      |21  33  F      |31  49  N      |41  65  F7</span><br><span class="line">02   2  1      |12  18  E      |22  34  G      |32  50  M      |42  66  F8</span><br><span class="line">03   3  2      |13  19  R      |23  35  H      |33  51  ,      |43  67  F9</span><br><span class="line">04   4  3      |14  20  T      |24  36  J      |34  52  .      |44  68  F10</span><br><span class="line">05   5  4      |15  21  Y      |25  37  K      |35  53  &#x2F;      |45  69  Num</span><br><span class="line">06   6  5      |16  22  U      |26  38  L      |36  54  R Shift|46  70  Scroll</span><br><span class="line">07   7  6      |17  23  I      |27  39  ;      |37  55  PrtSc  |47  71  Home</span><br><span class="line">08   8  7      |18  24  O      |28  40  &#39;      |38  56  Alt    |48  72  Up</span><br><span class="line">09   9  8      |19  25  P      |29  41  &#96;      |39  57  Space  |49  73  PgUp</span><br><span class="line">0A  10  9      |1A  26  [      |2A  42  L Shift|3A  58  Caps   |4A  74  -</span><br><span class="line">0B  11  0      |1B  27  ]      |2B  43  \      |3B  59  F1     |4B  75  Left</span><br><span class="line">0C  12  -      |1C  28         |2C  44  Z      |3C  60  F2     |4C  76  Center</span><br><span class="line">0D  13  &#x3D;      |1D  29  CTRL   |2D  45  X      |3D  61  F3     |4D  77  Right</span><br><span class="line">0E  14  bs     |1E  30  A      |2E  46  C      |3E  62  F4     |4E  78  +</span><br><span class="line">0F  15  Tab    |1F  31  S      |2F  47  V      |3F  63  F5     |4F  79  End</span><br><span class="line">---------------+---------------+---------------+---------------+---------------</span><br><span class="line">50  80  Down   |               |               |               |</span><br><span class="line">51  81  PgDn   |               |               |               |</span><br><span class="line">52  82  Ins    |               |               |               |</span><br><span class="line">53  83  Del    |               |               |               |</span><br><span class="line">---------------+---------------+---------------+---------------+---------------</span><br></pre></td></tr></table></figure>

<h4 id="内存搜索"><a href="#内存搜索" class="headerlink" title="内存搜索"></a>内存搜索</h4><p>回调函数 <code>KeyboardClassServiceCallback</code> 并没有被导出，我们要想使用它，就只能通过特征码搜索，<br>首先需要找到 <code>kbdclass.sys</code> 驱动的基址，我们可以使用一个已导出但未文档的函数来获取</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> POBJECT_TYPE* IoDriverObjectType;</span><br><span class="line"></span><br><span class="line"><span class="function">NTKERNELAPI NTSTATUS <span class="title">ObReferenceObjectByName</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PUNICODE_STRING ObjectName,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ULONG Attributes,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PACCESS_STATE AccessState,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN ACCESS_MASK DesiredAccess,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN POBJECT_TYPE ObjectType,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN KPROCESSOR_MODE AccessMode,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT PVOID ParseContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PVOID* Object)</span></span>;</span><br></pre></td></tr></table></figure>

<p>获取 <code>键盘驱动</code> 和 <code>键盘设备</code> 的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PDRIVER_OBJECT KeyboardDriver = <span class="literal">NULL</span>; <span class="comment">// 键盘驱动对象</span></span><br><span class="line">PDEVICE_OBJECT KeyboardDevice = <span class="literal">NULL</span>; <span class="comment">// 键盘设备对象</span></span><br><span class="line">PFILE_OBJECT KeyboardFile = <span class="literal">NULL</span>; <span class="comment">// 键盘文件对象</span></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">GetKeyboardDriverDevice</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    UNICODE_STRING KbdDriverName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Driver\\kbdclass&quot;</span>);</span><br><span class="line">    UNICODE_STRING KbdDeviceName = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Device\\KeyboardClass0&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取键盘设备对象</span></span><br><span class="line">    Status = IoGetDeviceObjectPointer(</span><br><span class="line">        &amp;KbdDeviceName, FILE_ALL_ACCESS, &amp;KeyboardFile, &amp;KeyboardDevice);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">return</span> Status;</span><br><span class="line">    <span class="comment">// 获取键盘驱动对象</span></span><br><span class="line">    Status = ObReferenceObjectByName(&amp;KbdDriverName, OBJ_CASE_INSENSITIVE,</span><br><span class="line">        <span class="literal">NULL</span>, GENERIC_ALL, *IoDriverObjectType, KernelMode, <span class="literal">NULL</span>, &amp;KeyboardDriver);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意IoGetDeviceObjectPointer只能解引用文件对象</span></span><br><span class="line">        ObDereferenceObject(&amp;KeyboardFile);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索回调函数的代码，其中特征码是通过 <code>WinDbg</code> 加载操作系统符号查找到的</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// KeyboardClassServiceCallback</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*KCSC)</span><span class="params">(PDEVICE_OBJECT, PKEYBOARD_INPUT_DATA, PKEYBOARD_INPUT_DATA, PULONG)</span></span>;</span><br><span class="line">KCSC pKeyboardClassServiceCallback = <span class="literal">NULL</span>; <span class="comment">// 回调函数指针</span></span><br><span class="line"></span><br><span class="line"><span class="function">NTSTATUS <span class="title">SearchKeyboardClassServiceCallback</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG Index = <span class="number">0</span>;</span><br><span class="line">    PUCHAR BaseAddr = KeyboardDriver-&gt;DriverStart;</span><br><span class="line">    ULONG DrvSize = KeyboardDriver-&gt;DriverSize;</span><br><span class="line">    <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt; DrvSize; Index++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (*(PULONG)(BaseAddr + Index) != <span class="number">0x8b55ff8b</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (*(PULONG)(BaseAddr + Index + <span class="number">4</span>) != <span class="number">0x8b5151ec</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (*(PULONG)(BaseAddr + Index + <span class="number">8</span>) != <span class="number">0x65830845</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (*(PULONG)(BaseAddr + Index + <span class="number">12</span>) != <span class="number">0x8b530008</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (*(PULONG)(BaseAddr + Index + <span class="number">16</span>) != <span class="number">0x5d2b105d</span>) <span class="keyword">continue</span>;</span><br><span class="line">        pKCSC = (KCSC)(BaseAddr + Index);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pKCSC != <span class="literal">NULL</span>) <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在WinXPSp3系统中，查找特征码步骤如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0: kd&gt; x kbdclass!KeyboardClassServiceCallback</span><br><span class="line">f78b6192          kbdclass!KeyboardClassServiceCallback (&lt;no parameter info&gt;)</span><br><span class="line"></span><br><span class="line">0: kd&gt; dd f78b6192</span><br><span class="line">f78b6192  8b55ff8b 8b5151ec 65830845 8b530008</span><br><span class="line">f78b61a2  5d2b105d 708b560c 14458b28 57002083</span><br><span class="line">f78b61b2  15ff046a f78b6ea8 ff6c4e8d 8b6ea415</span><br><span class="line"></span><br><span class="line">0: kd&gt; u kbdclass!KeyboardClassServiceCallback l 0xa</span><br><span class="line">kbdclass!KeyboardClassServiceCallback:</span><br><span class="line">f78b6192 8bff            mov     edi,edi</span><br><span class="line">f78b6194 55              push    ebp</span><br><span class="line">f78b6195 8bec            mov     ebp,esp</span><br><span class="line">f78b6197 51              push    ecx</span><br><span class="line">f78b6198 51              push    ecx</span><br><span class="line">f78b6199 8b4508          mov     eax,dword ptr [ebp+8]</span><br><span class="line">f78b619c 83650800        and     dword ptr [ebp+8],0</span><br><span class="line">f78b61a0 53              push    ebx</span><br><span class="line">f78b61a1 8b5d10          mov     ebx,dword ptr [ebp+10h]</span><br><span class="line">f78b61a4 2b5d0c          sub     ebx,dword ptr [ebp+0Ch]</span><br></pre></td></tr></table></figure>

<p>最后 <code>KeyboardClassServiceCallback</code> 函数的用法如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendKeyInputExample</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG InputDataConsumed = <span class="number">0</span>;</span><br><span class="line">    KEYBOARD_INPUT_DATA KbdInData[<span class="number">2</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 发送按下A键</span></span><br><span class="line">    KbdInData[<span class="number">0</span>].MakeCode = <span class="number">0x1E</span>; <span class="comment">// A键</span></span><br><span class="line">    KbdInData[<span class="number">0</span>].Flags = KEY_MAKE; <span class="comment">// 按下</span></span><br><span class="line">    pKeyboardClassServiceCallback(</span><br><span class="line">        KeyboardDevice, &amp;KbdInData[<span class="number">0</span>], &amp;KbdInData[<span class="number">1</span>], &amp;InputDataConsumed);</span><br><span class="line">    <span class="comment">// 发送弹起A键</span></span><br><span class="line">    KbdInData[<span class="number">0</span>].Flags = KEY_BREAK; <span class="comment">// 弹起</span></span><br><span class="line">    pKeyboardClassServiceCallback(</span><br><span class="line">        KeyboardDevice, &amp;KbdInData[<span class="number">0</span>], &amp;KbdInData[<span class="number">1</span>], &amp;InputDataConsumed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>按键过滤</category>
      </categories>
      <tags>
        <tag>按键过滤</tag>
      </tags>
  </entry>
  <entry>
    <title>在应用层模拟键盘按键(1)</title>
    <url>/2019/07/23/%E6%8C%89%E9%94%AE%E8%BF%87%E6%BB%A4/%E5%9C%A8%E5%BA%94%E7%94%A8%E5%B1%82%E6%A8%A1%E6%8B%9F%E9%94%AE%E7%9B%98%E6%8C%89%E9%94%AE-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>在某些情况下，我们需要模拟键盘按键，用程序替代人工按键操作，<br>可以使用的方法包含：使用 <code>SendMessage</code> 或 <code>PostMessage</code> 发送按键消息，使用 <code>keybd_event</code> 函数<br>发送按键动作（该函数被 <code>SendInput</code> 取代），使用 <code>SendInput</code> 函数发送按键动作，等等。</p>
<h4 id="发送按键消息"><a href="#发送按键消息" class="headerlink" title="发送按键消息"></a>发送按键消息</h4><p>使用 <code>WM_KEYDOWN</code> 或者 <code>WM_KEYUP</code> 并不好使，推测可能是 <code>lParam</code> 参数设置错误，<br>使用 <code>WM_CHAR</code> 消息都能够成功，只不过发送消息之前，需要先获取窗口句柄。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HWND hWnd = FindWindow(<span class="literal">NULL</span>, <span class="string">&quot;无标题 - 记事本&quot;</span>);</span><br><span class="line">HWND hEdit = FindWindowEx(hWnd, <span class="literal">NULL</span>, <span class="string">&quot;EDIT&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">SendMessage(hEdit, WM_CHAR, <span class="number">0x41</span>, <span class="number">0</span>); <span class="comment">// 输入A</span></span><br><span class="line">SendMessage(hEdit, WM_KEYDOWN, VK_SPACE, <span class="number">0</span>); <span class="comment">// 按下空格</span></span><br><span class="line">SendMessage(hEdit, WM_KEYUP, VK_SPACE, <span class="number">0</span>); <span class="comment">// 弹起空格</span></span><br><span class="line">SendMessage(hEdit, WM_CHAR, <span class="number">0x41</span>, <span class="number">0</span>); <span class="comment">// 输入A</span></span><br></pre></td></tr></table></figure>

<h4 id="调用按键事件函数"><a href="#调用按键事件函数" class="headerlink" title="调用按键事件函数"></a>调用按键事件函数</h4><p>该函数格式如下所示，其中参数 <code>bVk</code> 设置输入的虚拟按键，参数 <code>dwFlags</code> 设置按下或弹起动作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID WINAPI <span class="title">keybd_event</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ BYTE      bVk,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ BYTE      bScan,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD     dwFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ ULONG_PTR dwExtraInfo</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟按下Shift+A组合键，可以使用Sleep()增加按键间隔</span></span><br><span class="line">keybd_event(VK_SHIFT, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 按下Shift键</span></span><br><span class="line">keybd_event(<span class="number">0x41</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 按下A键</span></span><br><span class="line">keybd_event(<span class="number">0x41</span>, <span class="number">0</span>, KEYEVENTF_KEYUP, <span class="number">0</span>); <span class="comment">// 松开A键</span></span><br><span class="line">keybd_event(VK_SHIFT, <span class="number">0</span>, KEYEVENTF_KEYUP, <span class="number">0</span>); <span class="comment">// 松开Shift键</span></span><br></pre></td></tr></table></figure>

<h4 id="调用发送输入函数"><a href="#调用发送输入函数" class="headerlink" title="调用发送输入函数"></a>调用发送输入函数</h4><p>该函数格式如下所示，参数 <code>nInputs</code> 描述输入 <code>INPUT</code> 结构体数组的数量，参数 <code>cbSize</code> 表示对应总大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">UINT WINAPI <span class="title">SendInput</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ UINT    nInputs,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPINPUT pInputs,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ <span class="keyword">int</span>     cbSize</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagINPUT</span> &#123;</span></span><br><span class="line">  DWORD type;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    MOUSEINPUT    mi;</span><br><span class="line">    KEYBDINPUT    ki;</span><br><span class="line">    HARDWAREINPUT hi;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; INPUT, *PINPUT;</span><br></pre></td></tr></table></figure>

<p>结构体中的参数 <code>type</code> 可取值 <code>INPUT_MOUSE</code> <code>INPUT_KEYBOARD</code> <code>INPUT_HARDWARE</code> 来对应后续参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagMOUSEINPUT</span> &#123;</span></span><br><span class="line">  LONG      dx;</span><br><span class="line">  LONG      dy;</span><br><span class="line">  DWORD     mouseData;</span><br><span class="line">  DWORD     dwFlags;</span><br><span class="line">  DWORD     time;</span><br><span class="line">  ULONG_PTR dwExtraInfo;</span><br><span class="line">&#125; MOUSEINPUT, *PMOUSEINPUT;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagKEYBDINPUT</span> &#123;</span></span><br><span class="line">  WORD      wVk;</span><br><span class="line">  WORD      wScan;</span><br><span class="line">  DWORD     dwFlags;</span><br><span class="line">  DWORD     time;</span><br><span class="line">  ULONG_PTR dwExtraInfo;</span><br><span class="line">&#125; KEYBDINPUT, *PKEYBDINPUT;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagHARDWAREINPUT</span> &#123;</span></span><br><span class="line">  DWORD uMsg;</span><br><span class="line">  WORD  wParamL;</span><br><span class="line">  WORD  wParamH;</span><br><span class="line">&#125; HARDWAREINPUT, *PHARDWAREINPUT;</span><br></pre></td></tr></table></figure>

<p>我们这里使用 <code>INPUT_KEYBOARD</code> 来发送键盘按键，结构体<code>KEYBDINPUT</code> 与 <code>keybd_event</code> 取值相同</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INPUT input = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">input.type = INPUT_KEYBOARD;</span><br><span class="line">input.ki.wVk = VK_SHIFT;</span><br><span class="line">SendInput(<span class="number">1</span>, &amp;input, <span class="keyword">sizeof</span>(INPUT)); <span class="comment">// 按下Shift</span></span><br><span class="line">input.ki.dwFlags = KEYEVENTF_KEYUP;</span><br><span class="line">SendInput(<span class="number">1</span>, &amp;input, <span class="keyword">sizeof</span>(INPUT)); <span class="comment">// 弹起Shift</span></span><br></pre></td></tr></table></figure>

<p>经实验发现每次发送1个信息时能够成功，但是改为同时发送2个信息就不成功，不太清楚原因。</p>
]]></content>
      <categories>
        <category>按键过滤</category>
      </categories>
      <tags>
        <tag>按键过滤</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层使用键盘钩子过滤按键(1)</title>
    <url>/2019/07/11/%E6%8C%89%E9%94%AE%E8%BF%87%E6%BB%A4/%E5%BA%94%E7%94%A8%E5%B1%82%E4%BD%BF%E7%94%A8%E9%94%AE%E7%9B%98%E9%92%A9%E5%AD%90%E8%BF%87%E6%BB%A4%E6%8C%89%E9%94%AE-1/</url>
    <content><![CDATA[<h4 id="应用层低级键盘钩子"><a href="#应用层低级键盘钩子" class="headerlink" title="应用层低级键盘钩子"></a>应用层低级键盘钩子</h4><p>在应用层可以使用 <code>SetWindowsHookEx</code> 挂载 <code>低级键盘钩子</code> ，来实现屏蔽键盘按键的功能</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HHOOK WINAPI <span class="title">SetWindowsHookEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ <span class="keyword">int</span>       idHook,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HOOKPROC  lpfn,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HINSTANCE hMod,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ DWORD     dwThreadId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中参数 <code>idhook</code> 设置为 <code>WH_KEYBOARD_LL</code> 时，表明挂载 <code>低级键盘钩子</code> ，参数 <code>dwThreadId</code> 为想要HOOK<br>的线程ID，设置为0时，表示HOOK所有的线程。<code>低级键盘钩子</code> 的回调函数为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LRESULT CALLBACK <span class="title">LowLevelKeyboardProc</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ <span class="keyword">int</span>    nCode,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ WPARAM wParam,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPARAM lParam</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>参数 <code>nCode</code> 的值为 <code>HC_ACTION</code> 时表示 <code>wParam</code> 和 <code>lParam</code> 有效，参数 <code>wParam</code> 为键盘相关消息，出现<br>的值为 <code>WM_KEYDOWN</code> <code>WM_KEYUP</code> <code>WM_SYSKEYDOWN</code> <code>WM_SYSKEYUP</code> 几种，表明按键的行为，参数 <code>lParam</code> 为<br>具体按键信息，是一个 <code>KBDLLHOOKSTRUCT</code> 类型的结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tagKBDLLHOOKSTRUCT</span> &#123;</span></span><br><span class="line">  DWORD     vkCode;</span><br><span class="line">  DWORD     scanCode;</span><br><span class="line">  DWORD     flags;</span><br><span class="line">  DWORD     time;</span><br><span class="line">  ULONG_PTR dwExtraInfo;</span><br><span class="line">&#125; KBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT, *LPKBDLLHOOKSTRUCT;</span><br></pre></td></tr></table></figure>

<p>参数 <code>vkCode</code> 表示虚拟按键码信息，可以在头文件 <code>WinUser.h</code> 中找到定义，这里就不再列出。</p>
<h4 id="注册和卸载低级键盘钩子"><a href="#注册和卸载低级键盘钩子" class="headerlink" title="注册和卸载低级键盘钩子"></a>注册和卸载低级键盘钩子</h4><p>当HOOK所有线程时，实际是作为DLL模块注入到所有的程序中，来进行的HOOK操作。<br>一般情况下，32位的DLL注入到32位程序中，64位的DLL注入到64位程序中，不能互相注入。<br>使用 <code>低级键盘钩子</code> 时，只需要写32位DLL，而64位的程序，系统通过消息处理，间接实现按键过滤。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DLL中的共享数据块，在所有程序中公用同一段数据</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg(<span class="meta-string">&quot;.shared&quot;</span>)</span></span><br><span class="line">HHOOK g_hHook = <span class="literal">NULL</span>; <span class="comment">// 进行HOOK后的句柄</span></span><br><span class="line">BOOL g_bEnable = FALSE; <span class="comment">// 是否启用过滤功能</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> data_seg()</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(linker, <span class="meta-string">&quot;/section:.shared,rws&quot;</span>)</span></span><br><span class="line"><span class="comment">// 低级键盘钩子回调函数</span></span><br><span class="line"><span class="function">LRESULT CALLBACK <span class="title">LowLevelKeyboardProc</span><span class="params">(<span class="keyword">int</span> nCode, WPARAM wParam, LPARAM lParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((g_bEnable) &amp;&amp; (nCode == HC_ACTION))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span> (wParam)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> WM_KEYDOWN:</span><br><span class="line">        <span class="keyword">case</span> WM_SYSKEYDOWN:</span><br><span class="line">        <span class="keyword">case</span> WM_KEYUP:</span><br><span class="line">        <span class="keyword">case</span> WM_SYSKEYUP:</span><br><span class="line">        &#123;</span><br><span class="line">            PKBDLLHOOKSTRUCT pKbd = (PKBDLLHOOKSTRUCT)lParam;</span><br><span class="line">            BOOL bAltPress = (pKbd-&gt;flags &amp; LLKHF_ALTDOWN) != <span class="number">0</span>;</span><br><span class="line">            BOOL bCtrlPress = (GetKeyState(VK_CONTROL) &amp; <span class="number">0x8000</span>) != <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (bAltPress &amp;&amp; (pKbd-&gt;vkCode == VK_F4)) <span class="keyword">return</span> TRUE; <span class="comment">// ALT+F4</span></span><br><span class="line">            <span class="keyword">if</span> (bAltPress &amp;&amp; (pKbd-&gt;vkCode == VK_TAB)) <span class="keyword">return</span> TRUE; <span class="comment">// ALT+TAB</span></span><br><span class="line">            <span class="keyword">if</span> (bAltPress &amp;&amp; (pKbd-&gt;vkCode == VK_ESCAPE)) <span class="keyword">return</span> TRUE; <span class="comment">// ALT+ESC</span></span><br><span class="line">            <span class="keyword">if</span> (bCtrlPress &amp;&amp; (pKbd-&gt;vkCode == VK_ESCAPE)) <span class="keyword">return</span> TRUE; <span class="comment">// CTRL+ESC</span></span><br><span class="line">            <span class="keyword">if</span> (bCtrlPress &amp;&amp; bAltPress &amp;&amp; (pKbd-&gt;vkCode == VK_DELETE)) <span class="keyword">return</span> TRUE; <span class="comment">// CTRL+ALT+DEL</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> CallNextHookEx(g_hHook, nCode, wParam, lParam);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注册低级键盘钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">SetKeyboardHookDll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_hHook = SetWindowsHookEx(WH_KEYBOARD_LL,</span><br><span class="line">        LowLevelKeyboardProc, (HINSTANCE)GetModuleHandle(<span class="string">&quot;KbdHook.dll&quot;</span>), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (g_hHook == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 卸载低级键盘钩子</span></span><br><span class="line"><span class="function">BOOL <span class="title">UnKeyboardHookDll</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UnhookWindowsHookEx(g_hHook);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，调用DLL并执行HOOK的程序，在HOOK以后不能退出，否则导致HOOK的DLL被卸载。<br>或者也可以把HOOK的相关函数直接写到EXE程序中，把EXE自身作为DLL模块注入到所有线程中。</p>
]]></content>
      <categories>
        <category>按键过滤</category>
      </categories>
      <tags>
        <tag>按键过滤</tag>
      </tags>
  </entry>
  <entry>
    <title>PE文件格式解析(1)</title>
    <url>/2020/01/06/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>PE（Portable Executable）格式，是微软Win32环境可执行文件（如exe、dll、sys等）的标准格式。<br>PE格式继承自COFF（Common Object File Format）文件格式。</p>
<h4 id="具体结构"><a href="#具体结构" class="headerlink" title="具体结构"></a>具体结构</h4><p>具体的PE格式结构体在 <code>winnt.h</code> 头文件中有定义，格式分布如下图所示</p>
<p><img src="02.png" alt="PE格式"></p>
<h5 id="DOS头（DOS-HEADER）"><a href="#DOS头（DOS-HEADER）" class="headerlink" title="DOS头（DOS_HEADER）"></a>DOS头（DOS_HEADER）</h5><p>在PE文件最开始的位置，包含有DOS执行体的信息，当该程序在不支持 PE文件格式的操作系统中，它将<br>显示一个错误提示，大多数情况下它是由汇编器/编译器自动生成，即：简单调用中断21h服务来显示<br>字符串”This program cannot run in DOS mode”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DOS_HEADER</span> &#123;</span></span><br><span class="line">    WORD e_magic;    <span class="comment">// [0x00] Magic number // 0x5A4D</span></span><br><span class="line">    WORD e_cblp;     <span class="comment">// [0x02] Bytes on last page of file</span></span><br><span class="line">    WORD e_cp;       <span class="comment">// [0x04] Pages in file</span></span><br><span class="line">    WORD e_crlc;     <span class="comment">// [0x06] Relocations</span></span><br><span class="line">    WORD e_cparhdr;  <span class="comment">// [0x08] Size of header in paragraphs</span></span><br><span class="line">    WORD e_minalloc; <span class="comment">// [0x0A] Minimum extra paragraphs needed</span></span><br><span class="line">    WORD e_maxalloc; <span class="comment">// [0x0C] Maximum extra paragraphs needed</span></span><br><span class="line">    WORD e_ss;       <span class="comment">// [0x0E] Initial (relative) SS value</span></span><br><span class="line">    WORD e_sp;       <span class="comment">// [0x10] Initial SP value</span></span><br><span class="line">    WORD e_csum;     <span class="comment">// [0x12] Checksum</span></span><br><span class="line">    WORD e_ip;       <span class="comment">// [0x14] Initial IP value</span></span><br><span class="line">    WORD e_cs;       <span class="comment">// [0x16] Initial (relative) CS value</span></span><br><span class="line">    WORD e_lfarlc;   <span class="comment">// [0x18] File address of relocation table</span></span><br><span class="line">    WORD e_ovno;     <span class="comment">// [0x1A] Overlay number</span></span><br><span class="line">    WORD e_res[<span class="number">4</span>];   <span class="comment">// [0x1C] Reserved words</span></span><br><span class="line">    WORD e_oemid;    <span class="comment">// [0x24] OEM identifier (for e_oeminfo)</span></span><br><span class="line">    WORD e_oeminfo;  <span class="comment">// [0x26] OEM information; e_oemid specific</span></span><br><span class="line">    WORD e_res2[<span class="number">10</span>]; <span class="comment">// [0x28] Reserved words</span></span><br><span class="line">    LONG e_lfanew;   <span class="comment">// [0x3C] File address of new exe header</span></span><br><span class="line">&#125; IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;</span><br></pre></td></tr></table></figure>

<p>在 <code>DOS_HEADER</code> 中关键的信息有两处，其一是 <code>e_magic</code> 信息，必为 <code>0x5A4D</code> 值，其二是 <code>e_lfanew</code> 信息，<br>表示 <code>NT_HEADER</code> 的偏移位置。使用VS编译的EXE程序多数为 <code>0xF8</code> 值。</p>
<p><img src="01.png" alt="标识信息"></p>
<h5 id="PE头（NT-HEADER）"><a href="#PE头（NT-HEADER）" class="headerlink" title="PE头（NT_HEADER）"></a>PE头（NT_HEADER）</h5><p>在 <code>NT_HEADER</code> 中共包含三部分信息，其中 <code>Signature</code> 必为 <code>0x4550</code> 值，<code>FILE_HEADER</code> 在x86和x64系统中<br>大小是一样的，而 <code>OPTIONAL_HEADER</code> 则有一些细微的差别，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 32位程序的NT_HEADERS</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS</span> &#123;</span></span><br><span class="line">    DWORD                   Signature;      <span class="comment">// [0x00] PE标识 // 0x4550</span></span><br><span class="line">    IMAGE_FILE_HEADER       FileHeader;     <span class="comment">// [0x04] 文件基本信息</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER32 OptionalHeader; <span class="comment">// [0x18] 文件扩展信息</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;</span><br><span class="line"><span class="comment">// 64位程序的NT_HEADERS64</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_NT_HEADERS64</span> &#123;</span></span><br><span class="line">    DWORD                   Signature;      <span class="comment">// [0x00] PE标识 // 0x4550</span></span><br><span class="line">    IMAGE_FILE_HEADER       FileHeader;     <span class="comment">// [0x04] 文件基本信息</span></span><br><span class="line">    IMAGE_OPTIONAL_HEADER64 OptionalHeader; <span class="comment">// [0x18] 文件扩展信息</span></span><br><span class="line">&#125; IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;</span><br></pre></td></tr></table></figure>

<p><code>FILE_HEADER</code> 结构体如下，其中 <code>Machine</code> 的值，在x86平台是 <code>0x014C</code>，在x64平台是 <code>0x8664</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_FILE_HEADER</span> &#123;</span></span><br><span class="line">    WORD  Machine;              <span class="comment">// [0x04] 运行平台</span></span><br><span class="line">    WORD  NumberOfSections;     <span class="comment">// [0x06] 区段的数量</span></span><br><span class="line">    DWORD TimeDateStamp;        <span class="comment">// [0x08] 文件创建时间</span></span><br><span class="line">    DWORD PointerToSymbolTable; <span class="comment">// [0x0C] 符号表指针</span></span><br><span class="line">    DWORD NumberOfSymbols;      <span class="comment">// [0x10] 符号的数量</span></span><br><span class="line">    WORD  SizeOfOptionalHeader; <span class="comment">// [0x14] 扩展头大小</span></span><br><span class="line">    WORD  Characteristics;      <span class="comment">// [0x16] 文件属性</span></span><br><span class="line">&#125; IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;</span><br></pre></td></tr></table></figure>

<p>文件属性 <code>Characteristics</code> 的取值，在 <code>winnt.h</code> 中定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_RELOCS_STRIPPED         0x0001  <span class="comment">// 文件不包含重定位信息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_EXECUTABLE_IMAGE        0x0002  <span class="comment">// 文件是可执行的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LINE_NUMS_STRIPPED      0x0004  <span class="comment">// 文件不包含行号信息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LOCAL_SYMS_STRIPPED     0x0008  <span class="comment">// 文件不包含符号信息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_AGGRESIVE_WS_TRIM       0x0010  <span class="comment">// 强制裁剪工作组</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_LARGE_ADDRESS_AWARE     0x0020  <span class="comment">// 应用程序能够处理超过2GB的地址</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_LO       0x0080  <span class="comment">// CPU的低字节是颠倒的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_32BIT_MACHINE           0x0100  <span class="comment">// 文件运行于32位平台</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_DEBUG_STRIPPED          0x0200  <span class="comment">// 不包含.dbg调试信息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_REMOVABLE_RUN_FROM_SWAP 0x0400  <span class="comment">// 从交换区中运行在移动介质中的文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_NET_RUN_FROM_SWAP       0x0800  <span class="comment">// 从交换区中运行在网络中的文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_SYSTEM                  0x1000  <span class="comment">// 系统文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_DLL                     0x2000  <span class="comment">// DLL(动态链接库)文件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_UP_SYSTEM_ONLY          0x4000  <span class="comment">// 只能运行在单处理器(Uniprocessor)中</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_FILE_BYTES_REVERSED_HI       0x8000  <span class="comment">// CPU的低字节是颠倒的</span></span></span><br></pre></td></tr></table></figure>

<h5 id="扩展头（OPTIONAL-HEADER）"><a href="#扩展头（OPTIONAL-HEADER）" class="headerlink" title="扩展头（OPTIONAL_HEADER）"></a>扩展头（OPTIONAL_HEADER）</h5><p>在x86平台下的 <code>OPTIONAL_HEADER32</code> 结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER32</span> &#123;</span></span><br><span class="line">    <span class="comment">// 标准域</span></span><br><span class="line">    WORD  Magic;                              <span class="comment">// [0x18] 标志位 // 32位(0x10B)</span></span><br><span class="line">    BYTE  MajorLinkerVersion;                 <span class="comment">// [0x1A] 链接器主版本号</span></span><br><span class="line">    BYTE  MinorLinkerVersion;                 <span class="comment">// [0x1B] 链接器子版本号</span></span><br><span class="line">    DWORD SizeOfCode;                         <span class="comment">// [0x1C] 所有代码节的总大小</span></span><br><span class="line">    DWORD SizeOfInitializedData;              <span class="comment">// [0x20] 所有已初始化节总大小</span></span><br><span class="line">    DWORD SizeOfUninitializedData;            <span class="comment">// [0x24] 所有未初始化节总大小</span></span><br><span class="line">    DWORD AddressOfEntryPoint;                <span class="comment">// [0x28] 程序执行入口RVA</span></span><br><span class="line">    DWORD BaseOfCode;                         <span class="comment">// [0x2C] 代码节起始RVA</span></span><br><span class="line">    DWORD BaseOfData;                         <span class="comment">// [0x30] 数据节起始RVA</span></span><br><span class="line">    <span class="comment">// NT附加域                           </span></span><br><span class="line">    DWORD ImageBase;                          <span class="comment">// [0x34] 程序默认载入基地址 // 4字节</span></span><br><span class="line">    DWORD SectionAlignment;                   <span class="comment">// [0x38] 内存中的节对齐值</span></span><br><span class="line">    DWORD FileAlignment;                      <span class="comment">// [0x3C] 文件中的节对齐值</span></span><br><span class="line">    WORD  MajorOperatingSystemVersion;        <span class="comment">// [0x40] 系统主版本号</span></span><br><span class="line">    WORD  MinorOperatingSystemVersion;        <span class="comment">// [0x42] 系统子版本号</span></span><br><span class="line">    WORD  MajorImageVersion;                  <span class="comment">// [0x44] 映像主版本号</span></span><br><span class="line">    WORD  MinorImageVersion;                  <span class="comment">// [0x46] 映像子版本号</span></span><br><span class="line">    WORD  MajorSubsystemVersion;              <span class="comment">// [0x48] 子系统主版本号</span></span><br><span class="line">    WORD  MinorSubsystemVersion;              <span class="comment">// [0x4A] 子系统子版本号</span></span><br><span class="line">    DWORD Win32VersionValue;                  <span class="comment">// [0x4C] 保留，通常为0x00</span></span><br><span class="line">    DWORD SizeOfImage;                        <span class="comment">// [0x50] 内存中映像总大小</span></span><br><span class="line">    DWORD SizeOfHeaders;                      <span class="comment">// [0x54] 各个文件头的总大小</span></span><br><span class="line">    DWORD CheckSum;                           <span class="comment">// [0x58] 影像文件校验和</span></span><br><span class="line">    WORD  Subsystem;                          <span class="comment">// [0x5C] 文件子系统</span></span><br><span class="line">    WORD  DllCharacteristics;                 <span class="comment">// [0x5E] DLL标志位</span></span><br><span class="line">    DWORD SizeOfStackReserve;                 <span class="comment">// [0x60] 初始化预留栈大小 // 4字节</span></span><br><span class="line">    DWORD SizeOfStackCommit;                  <span class="comment">// [0x64] 初始化提交栈大小 // 4字节</span></span><br><span class="line">    DWORD SizeOfHeapReserve;                  <span class="comment">// [0x68] 初始化预留堆大小 // 4字节</span></span><br><span class="line">    DWORD SizeOfHeapCommit;                   <span class="comment">// [0x6C] 初始化提交堆大小 // 4字节</span></span><br><span class="line">    DWORD LoaderFlags;                        <span class="comment">// [0x70] 调试相关，默认0x00</span></span><br><span class="line">    DWORD NumberOfRvaAndSizes;                <span class="comment">// [0x74] 数据目录表的数量</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[<span class="number">0x10</span>]; <span class="comment">// [0x78] 数据目录表 // 通常为0x10个</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;</span><br></pre></td></tr></table></figure>

<p>在x64平台下的 <code>OPTIONAL_HEADER64</code> 结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_OPTIONAL_HEADER64</span> &#123;</span></span><br><span class="line">    <span class="comment">// 标准域</span></span><br><span class="line">    WORD      Magic;                          <span class="comment">// [0x18] 标志位 // 64位(0x20B)</span></span><br><span class="line">    BYTE      MajorLinkerVersion;             <span class="comment">// [0x1A] 链接器主版本号</span></span><br><span class="line">    BYTE      MinorLinkerVersion;             <span class="comment">// [0x1B] 链接器子版本号</span></span><br><span class="line">    DWORD     SizeOfCode;                     <span class="comment">// [0x1C] 所有代码节的总大小</span></span><br><span class="line">    DWORD     SizeOfInitializedData;          <span class="comment">// [0x20] 所有已初始化节总大小</span></span><br><span class="line">    DWORD     SizeOfUninitializedData;        <span class="comment">// [0x24] 所有未初始化节总大小</span></span><br><span class="line">    DWORD     AddressOfEntryPoint;            <span class="comment">// [0x28] 程序执行入口RVA</span></span><br><span class="line">    DWORD     BaseOfCode;                     <span class="comment">// [0x2C] 代码节起始RVA</span></span><br><span class="line">    DWORD     BaseOfData;                     <span class="comment">// [0x30] 数据节起始RVA</span></span><br><span class="line">    <span class="comment">// NT附加域                           </span></span><br><span class="line">    ULONGLONG ImageBase;                      <span class="comment">// [0x34] 程序默认载入基地址 // 8字节</span></span><br><span class="line">    DWORD     SectionAlignment;               <span class="comment">// [0x3C] 内存中的节对齐值</span></span><br><span class="line">    DWORD     FileAlignment;                  <span class="comment">// [0x40] 文件中的节对齐值</span></span><br><span class="line">    WORD      MajorOperatingSystemVersion;    <span class="comment">// [0x44] 系统主版本号</span></span><br><span class="line">    WORD      MinorOperatingSystemVersion;    <span class="comment">// [0x46] 系统子版本号</span></span><br><span class="line">    WORD      MajorImageVersion;              <span class="comment">// [0x48] 映像主版本号</span></span><br><span class="line">    WORD      MinorImageVersion;              <span class="comment">// [0x4A] 映像子版本号</span></span><br><span class="line">    WORD      MajorSubsystemVersion;          <span class="comment">// [0x4C] 子系统主版本号</span></span><br><span class="line">    WORD      MinorSubsystemVersion;          <span class="comment">// [0x4E] 子系统子版本号</span></span><br><span class="line">    DWORD     Win32VersionValue;              <span class="comment">// [0x50] 保留，通常为0x00</span></span><br><span class="line">    DWORD     SizeOfImage;                    <span class="comment">// [0x54] 内存中映像总大小</span></span><br><span class="line">    DWORD     SizeOfHeaders;                  <span class="comment">// [0x58] 各个文件头的总大小</span></span><br><span class="line">    DWORD     CheckSum;                       <span class="comment">// [0x5C] 影像文件校验和</span></span><br><span class="line">    WORD      Subsystem;                      <span class="comment">// [0x60] 文件子系统</span></span><br><span class="line">    WORD      DllCharacteristics;             <span class="comment">// [0x62] DLL标志位</span></span><br><span class="line">    ULONGLONG SizeOfStackReserve;             <span class="comment">// [0x64] 初始化预留栈大小 // 8字节</span></span><br><span class="line">    ULONGLONG SizeOfStackCommit;              <span class="comment">// [0x6C] 初始化提交栈大小 // 8字节</span></span><br><span class="line">    ULONGLONG SizeOfHeapReserve;              <span class="comment">// [0x74] 初始化预留堆大小 // 8字节</span></span><br><span class="line">    ULONGLONG SizeOfHeapCommit;               <span class="comment">// [0x7C] 初始化提交堆大小 // 8字节</span></span><br><span class="line">    DWORD     LoaderFlags;                    <span class="comment">// [0x84] 调试相关，默认0x00</span></span><br><span class="line">    DWORD     NumberOfRvaAndSizes;            <span class="comment">// [0x88] 数据目录表的数量</span></span><br><span class="line">    IMAGE_DATA_DIRECTORY DataDirectory[<span class="number">0x10</span>]; <span class="comment">// [0x8C] 数据目录表 // 通常为0x10个</span></span><br><span class="line">&#125; IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;</span><br></pre></td></tr></table></figure>

<p>其中关于 <code>Subsystem</code> 的定义如下，表示该程序期望在什么环境下运行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_UNKNOWN        0 <span class="comment">// Unknown subsystem</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_NATIVE         1 <span class="comment">// Image doesn&#x27;t require a subsystem</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_GUI    2 <span class="comment">// Image runs in the Windows GUI subsystem</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CUI    3 <span class="comment">// Image runs in the Windows character subsystem</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_OS2_CUI        5 <span class="comment">// image runs in the OS/2 character subsystem</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_POSIX_CUI      7 <span class="comment">// image runs in the Posix character subsystem</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_NATIVE_WINDOWS 8 <span class="comment">// image is a native Win9x driver</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SUBSYSTEM_WINDOWS_CE_GUI 9 <span class="comment">// Image runs in the Windows CE subsystem</span></span></span><br></pre></td></tr></table></figure>

<h5 id="数据目录表（DATA-DIRECTORY）"><a href="#数据目录表（DATA-DIRECTORY）" class="headerlink" title="数据目录表（DATA_DIRECTORY）"></a>数据目录表（DATA_DIRECTORY）</h5><p>在 <code>OPTIONAL_HEADER</code> 中存储着 <code>DATA_DIRECTORY</code> 信息，结构体如下，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD VirtualAddress; <span class="comment">// 虚拟地址</span></span><br><span class="line">    DWORD Size;           <span class="comment">// 大小</span></span><br><span class="line">&#125; IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>数据目录表通常是 <code>0x10</code> 个，实际数量由 <code>NumberOfRvaAndSizes</code> 指定，内容如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXPORT          0 <span class="comment">// Export Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IMPORT          1 <span class="comment">// Import Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_RESOURCE        2 <span class="comment">// Resource Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_EXCEPTION       3 <span class="comment">// Exception Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_SECURITY        4 <span class="comment">// Security Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BASERELOC       5 <span class="comment">// Base Relocation Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DEBUG           6 <span class="comment">// Debug Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_ARCHITECTURE    7 <span class="comment">// Architecture Specific Data</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_GLOBALPTR       8 <span class="comment">// RVA of GP</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_TLS             9 <span class="comment">// TLS Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG    10 <span class="comment">// Load Configuration Directory</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT   11 <span class="comment">// Bound Import Directory in headers</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_IAT            12 <span class="comment">// Import Address Table</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT   13 <span class="comment">// Delay Load Import Descriptors</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 <span class="comment">// COM Runtime descriptor</span></span></span><br></pre></td></tr></table></figure>

<h5 id="节头（SECTION-HEADER）"><a href="#节头（SECTION-HEADER）" class="headerlink" title="节头（SECTION_HEADER）"></a>节头（SECTION_HEADER）</h5><p>在数据目录表的后边，就是用来描述每个节信息的 <code>SECTION_HEADER</code>，结构体如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_SECTION_HEADER</span> &#123;</span></span><br><span class="line">    BYTE  Name[<span class="number">0x08</span>];           <span class="comment">// 节名称</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD PhysicalAddress;</span><br><span class="line">        DWORD VirtualSize;</span><br><span class="line">    &#125; Misc;                     <span class="comment">// 节大小</span></span><br><span class="line">    DWORD VirtualAddress;       <span class="comment">// 节RVA地址</span></span><br><span class="line">    DWORD SizeOfRawData;        <span class="comment">// 文件中节对齐大小</span></span><br><span class="line">    DWORD PointerToRawData;     <span class="comment">// 节在文件中的偏移</span></span><br><span class="line">    DWORD PointerToRelocations; <span class="comment">// 重定位的偏移(用于OBJ文件)</span></span><br><span class="line">    DWORD PointerToLinenumbers; <span class="comment">// 行号表的偏移(用于调试)</span></span><br><span class="line">    WORD  NumberOfRelocations;  <span class="comment">// 重定位表的数量(用于OBJ文件)</span></span><br><span class="line">    WORD  NumberOfLinenumbers;  <span class="comment">// 行号表数量(用于调试)</span></span><br><span class="line">    DWORD Characteristics;      <span class="comment">// 节属性</span></span><br><span class="line">&#125; IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;</span><br></pre></td></tr></table></figure>

<p>节的属性 <code>Characteristics</code> 比较常见的定义如下，更多信息见 <code>winnt.h</code> 的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_CNT_CODE               0x00000020  <span class="comment">// 此节包含代码</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_CNT_INITIALIZED_DATA   0x00000040  <span class="comment">// 此节包含已初始化数据</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_CNT_UNINITIALIZED_DATA 0x00000080  <span class="comment">// 此节包含未初始化数据</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_LNK_INFO               0x00000200  <span class="comment">// 此节包含注释或其他类型信息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_LNK_REMOVE             0x00000800  <span class="comment">// 此节不会成为映像的一部分</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_LNK_COMDAT             0x00001000  <span class="comment">// 此节包含COM数据</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_NO_DEFER_SPEC_EXC      0x00004000  <span class="comment">// 在此节的TLB项中重置异常控制位</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_GPREL                  0x00008000  <span class="comment">// 此节可以访问GP相关内容</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_LNK_NRELOC_OVFL        0x01000000  <span class="comment">// 此节包含扩展重定位信息</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_DISCARDABLE        0x02000000  <span class="comment">// 此节可以被丢弃(比如重定位.reloc节)</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_NOT_CACHED         0x04000000  <span class="comment">// 此节不可以缓存</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_NOT_PAGED          0x08000000  <span class="comment">// 此节不可以分页</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_SHARED             0x10000000  <span class="comment">// 此节是共享的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_EXECUTE            0x20000000  <span class="comment">// 此节是可执行的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_READ               0x40000000  <span class="comment">// 此节是可读的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IMAGE_SCN_MEM_WRITE              0x80000000  <span class="comment">// 此节是可写的</span></span></span><br></pre></td></tr></table></figure>

<p>虽然每个节的名称可以随意定义，但是也有一些约定俗成的名称，如下</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>.text</td>
<td>代码段，Borland C++编译器代码段为code</td>
</tr>
<tr>
<td>.data</td>
<td>可读写的数据段，存放全局变量或静态变量</td>
</tr>
<tr>
<td>.rdata</td>
<td>只读数据段，存放常量信息</td>
</tr>
<tr>
<td>.idata</td>
<td>导入数据段，存放导入表信息</td>
</tr>
<tr>
<td>.edata</td>
<td>导出数据段，存放导出表信息</td>
</tr>
<tr>
<td>.rsrc</td>
<td>资源段，存放图标、菜单等资源信息</td>
</tr>
<tr>
<td>.bss</td>
<td>未初始化数据段</td>
</tr>
<tr>
<td>.crt</td>
<td>存放用于支持C++运行时库(CRT)所添加的数据</td>
</tr>
<tr>
<td>.tls</td>
<td>存放用于支持通过_declspec(thread)声明的线程局部存储数据</td>
</tr>
<tr>
<td>.reloc</td>
<td>存放重定位信息</td>
</tr>
<tr>
<td>.sdata</td>
<td>存放可被全局指针定位的可读写数据</td>
</tr>
<tr>
<td>.srdata</td>
<td>存放可被全局指针定位的只读数据</td>
</tr>
<tr>
<td>.pdata</td>
<td>存放异常表，结构体为IMAGE_RUNTIME_FUNTCION_ENTRY</td>
</tr>
<tr>
<td>.debug$S</td>
<td>存放OBJ文件中Codeview格式符号</td>
</tr>
<tr>
<td>.debug$T</td>
<td>存放OBJ文件中Codeview格式类型符号</td>
</tr>
<tr>
<td>.debug$P</td>
<td>存放使用预编译头时的一些信息</td>
</tr>
<tr>
<td>.drectve</td>
<td>存放编译时的一些链接命令</td>
</tr>
<tr>
<td>.didat</td>
<td>存放延迟装入的数据</td>
</tr>
</tbody></table>
<h4 id="节数据对齐"><a href="#节数据对齐" class="headerlink" title="节数据对齐"></a>节数据对齐</h4><p>节的对齐共有两种粒度，一种是在内存中对齐，由 <code>SectionAlignment</code> 参数决定，通常为 <code>0x1000</code> 值，<br>另一种是在文件中对齐，由 <code>FileAlignment</code> 参数决定，通常为 <code>0x200</code> 值。操作系统在加载映像时，<br>会依照内存对齐粒度的整数倍来分配空间。</p>
<p>关于内存地址与文件地址之间的转换，我们需要先理解两个概念</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>虚拟内存地址（Virtual Address，VA）</td>
<td>指PE文件被装入内存之后的地址</td>
</tr>
<tr>
<td>相对虚拟地址（Relative Virtual Address，RVA）</td>
<td>指相对于映像基址的内存地址偏移</td>
</tr>
</tbody></table>
<p>计算方式为：<code>虚拟内存地址(VA) = 映像基址(Image Base) + 相对虚拟地址(RVA)</code></p>
<p>以某代码段为例，虽然由于粒度的不同导致内存地址与文件地址有很大偏差，但是整个代码段的内容是不会变得，<br>所以某一段代码的地址相对于该代码段的起始地址是不变的，根据这一特点就可以进行地址换算。</p>
<p>关系式为：<code>文件偏移地址 = 所在节的起始文件偏移 + (虚拟内存地址 - 映像基址 - 所在节的起始虚拟内存偏移)</code></p>
<p>节头中的 <code>VirtualAddress</code> 表示该节的 <code>起始虚拟内存偏移</code>，<code>PointerToRawData</code> 表示该节的 <code>起始文件偏移</code>。</p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PE文件格式解析(2)</title>
    <url>/2020/01/14/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90-2/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在PE文件结构中，数据目录表对应的信息很重要，这里对其中几个常用的进行介绍。</p>
<h4 id="导出表"><a href="#导出表" class="headerlink" title="导出表"></a>导出表</h4><p>导出表是PE文件为其他应用程序提供API的一种信息导出方式，其结构体如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_EXPORT_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD Characteristics;       <span class="comment">// 保留,恒为0x00000000</span></span><br><span class="line">    DWORD TimeDateStamp;         <span class="comment">// 时间戳</span></span><br><span class="line">    WORD  MajorVersion;          <span class="comment">// 主版本号，一般不赋值</span></span><br><span class="line">    WORD  MinorVersion;          <span class="comment">// 子版本号，一般不赋值</span></span><br><span class="line">    DWORD Name;                  <span class="comment">// 模块名称地址</span></span><br><span class="line">    DWORD Base;                  <span class="comment">// 索引基数</span></span><br><span class="line">    DWORD NumberOfFunctions;     <span class="comment">// 导出地址表中的成员个数</span></span><br><span class="line">    DWORD NumberOfNames;         <span class="comment">// 导出名称表中的成员个数</span></span><br><span class="line">    DWORD AddressOfFunctions;    <span class="comment">// 导出地址表(EAT)</span></span><br><span class="line">    DWORD AddressOfNames;        <span class="comment">// 导出名称表(ENT)</span></span><br><span class="line">    DWORD AddressOfNameOrdinals; <span class="comment">// 指向导出序列号数组</span></span><br><span class="line">&#125; IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>从逻辑上讲，导出表由3部分构成，分别是地址表、名称表、序号表。地址表存储的是所有导出内容的<br>地址信息，名称表存储的是所有导出的名称信息，而序号表与名称表一一对应，表明该名称在地址表中<br>的索引位置。其中对应关系如下图所示</p>
<p><img src="01.png" alt="对应关系"></p>
<p>我们自己创建一个DLL程序，并使用 <code>.def</code> 文件来定义导出信息：<br>注意：第一个语句可以使用 <code>LIBRARY</code> 定义DLL的名称，然后可以使用 <code>EXPORTS</code> 来定义导出的函数名，<br>在函数名的后边可以加上 <code>@</code> 来指定序号值，序号范围是 <code>从1到N</code>，如果不想导出函数名，还可以在序号<br>后边加上 <code>NONAME</code> 语句，如下代码所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">LIBRARY MyDll</span><br><span class="line">EXPORTS</span><br><span class="line">  Plus  @<span class="number">3</span></span><br><span class="line">  Sub   @<span class="number">4</span> NONAME</span><br><span class="line">  Div   @<span class="number">6</span> NONAME</span><br><span class="line">  Mul   @<span class="number">7</span></span><br></pre></td></tr></table></figure>

<p>查看实际生成的文件内容如下所示</p>
<p><img src="02.png" alt="实际内容"></p>
<p>其中绿色划线的信息为 <code>Base(3)</code> <code>NumberOfFunctions(5)</code> <code>NumberOfNames(2)</code>，相关信息如下所示</p>
<p><img src="03.png" alt="数据关系"></p>
<p>由于序号表只有 <code>0x0000</code> 和 <code>0x0004</code>，中间的序号就是虚序号。同时由于我们只定义了4个函数，在<br>地址表中就会存在一个内容为 <code>0x00000000</code> 的用来占位的成员。</p>
<p>在加载到内存后，其调用序号还需要加上索引基址 <code>Base</code> 信息，即 <code>Plus</code> 的调用序号是 <code>3 + 0x0000 = 3</code>，<br><code>Mul</code> 的调用序号是 <code>3 + 0x0004 = 7</code>，下图为使用 <code>LordPE</code> 工具查看的信息。</p>
<p>如果我们只通过 <code>名称表</code> 来获取函数地址，就不需要加上这个基址，直接使用对应的偏移就行。</p>
<p><img src="04.png" alt="导出信息"></p>
<h4 id="导入表"><a href="#导入表" class="headerlink" title="导入表"></a>导入表</h4><p>导入表是PE文件从其他第三方程序中导入API供自己使用的机制，其结构体如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_DESCRIPTOR</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD Characteristics;</span><br><span class="line">        DWORD OriginalFirstThunk; <span class="comment">// 名称表(INT)的RVA</span></span><br><span class="line">    &#125;;</span><br><span class="line">    DWORD TimeDateStamp;          <span class="comment">// 时间戳</span></span><br><span class="line">    DWORD ForwarderChain;         <span class="comment">// 转发链，如果不转发则为0</span></span><br><span class="line">    DWORD Name;                   <span class="comment">// 导入映像名地址</span></span><br><span class="line">    DWORD FirstThunk;             <span class="comment">// 地址表(IAT)的RVA</span></span><br><span class="line">&#125; IMAGE_IMPORT_DESCRIPTOR, *PIMAGE_IMPORT_DESCRIPTOR;</span><br></pre></td></tr></table></figure>

<p>其中 <code>OriginalFirstThunk</code> 和 <code>FirstThunk</code> 指向的是一个结构体数组，结尾是整体为0x0的结构体，<br>这个结构体在32位和64位中不同，是一个联合体信息，定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA32</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD ForwarderString; <span class="comment">// 转发字符串的RVA</span></span><br><span class="line">        DWORD Function;        <span class="comment">// 被导入函数的地址</span></span><br><span class="line">        DWORD Ordinal;         <span class="comment">// 被导入函数的序号</span></span><br><span class="line">        DWORD AddressOfData;   <span class="comment">// 被导入函数名称的RVA</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA32, *PIMAGE_THUNK_DATA32; <span class="comment">// 32位</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_THUNK_DATA64</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        ULONGLONG ForwarderString; <span class="comment">// 转发字符串的RVA</span></span><br><span class="line">        ULONGLONG Function;        <span class="comment">// 被导入函数的地址</span></span><br><span class="line">        ULONGLONG Ordinal;         <span class="comment">// 被导入函数的序号</span></span><br><span class="line">        ULONGLONG AddressOfData;   <span class="comment">// 被导入函数名称的RVA</span></span><br><span class="line">    &#125; u1;</span><br><span class="line">&#125; IMAGE_THUNK_DATA64, *PIMAGE_THUNK_DATA64; <span class="comment">// 64位</span></span><br></pre></td></tr></table></figure>

<p><code>ForwarderString</code>：当导入表的 <code>ForwarderChain</code> 不为0时，此值有效，并指向包含有转发函数与导出<br>这个函数的映像文件名的字符串RVA。<br><code>Function</code>：导入表导入函数的实际内存地址，此字段仅在此映像被加载，且此结构为IAT的前提下有效。<br><code>Ordinal</code>：导入表导入函数的导出序号，当 <code>IMAGE_THUNK_DATA</code> 的最高位为1时，此值有效。<br><code>AddressOfData</code>：指向 <code>IMAGE_IMPORT_BY_NAME</code> 结构，当以上3个值都未生效时，此值有效。</p>
<p>这里就产生一个疑问 <code>Function</code>  和 <code>AddressOfData</code> 如何进行区分：在PE文件被系统地加载之前，输入表<br>的 <code>INT</code> 与 <code>IAT</code> 都是使用 <code>AddressOfData</code> 字段指向一个 <code>IMAGE_IMPORT_BY_NAME</code> 结构的，但当我们的PE<br>文件被加载时，操作系统首先会逐个遍历 <code>INT</code> 中的内容，并取出已导入函数的内存地址，然后将这些动态<br>获取的地址逐一填入对应的 <code>IAT</code> 中，此时操作系统使用的就是 <code>Function</code> 这个成员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_IMPORT_BY_NAME</span> &#123;</span></span><br><span class="line">    WORD Hint;    <span class="comment">// 需导入的函数序号</span></span><br><span class="line">    CHAR Name[<span class="number">1</span>]; <span class="comment">// 需导入的函数名称(不定长且以\0结尾)</span></span><br><span class="line">&#125; IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;</span><br></pre></td></tr></table></figure>

<p>如下为导入表内容的关系图</p>
<p><img src="05.png" alt="结构关系"></p>
<p>注意：导入表的序号并不是不可靠的，因为编译器在生成程序时，使用的序号是SDK库文件 <code>.lib</code> 中的，<br>但是实际运行时对应的 <code>.dll</code> 有可能是不同操作系统的。比如系统中的 Kernel32.dll 模块。</p>
<p>为了避免因此发生加载错误，最可靠的处理方法是首先使用本程序导入的序号，在导出此函数的DLL中<br>查找与此序号所对应的函数名，如果目标DLL中与此序号对应的API函数名与本程序中此序号对应的函数名<br>一致，则直接调用，否则使用函数名来搜索比对获取API地址。</p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PE文件格式解析(3)</title>
    <url>/2020/01/15/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/PE%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%9E%90-3/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在PE文件结构中，数据目录表对应的信息很重要，这里对其中几个常用的进行介绍。</p>
<h4 id="资源表"><a href="#资源表" class="headerlink" title="资源表"></a>资源表</h4><p>资源表用来存储程序的各种界面数据，比如菜单、图标、版本信息等，其结构体如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIRECTORY</span> &#123;</span></span><br><span class="line">    DWORD Characteristics;      <span class="comment">// 资源属性标识，通常为0x00000000</span></span><br><span class="line">    DWORD TimeDateStamp;        <span class="comment">// 资源建立的时间</span></span><br><span class="line">    WORD  MajorVersion;         <span class="comment">// 资源主版本，通常为0x0004</span></span><br><span class="line">    WORD  MinorVersion;         <span class="comment">// 资源子版本，通常为0x0000</span></span><br><span class="line">    WORD  NumberOfNamedEntries; <span class="comment">// 资源名称条目个数</span></span><br><span class="line">    WORD  NumberOfIdEntries;    <span class="comment">// 资源ID条目个数</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;</span><br></pre></td></tr></table></figure>

<p>资源在PE文件中是以目录结构的形式存在的，一般情况下这个目录分3层，从根目录开始分别为资源类型、<br>目录资源ID、资源代码页。每层的头部是一个 <code>IMAGE_RESOURCE_DIRECTORY</code> 结构，并且在其后面跟着一个<br><code>IMAGE_RESOURCE_DIRECTORY_ENTRY</code> 结构数组，然后结构数组的每个成员则分别指向下一层目录结构。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIRECTORY_ENTRY</span> &#123;</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD NameOffset : <span class="number">31</span>;        <span class="comment">// 资源名偏移</span></span><br><span class="line">            DWORD NameIsString : <span class="number">1</span>;       <span class="comment">// 资源名为字符串</span></span><br><span class="line">        &#125;;</span><br><span class="line">        DWORD Name;                       <span class="comment">// 资源/语言类型</span></span><br><span class="line">        WORD  Id;                         <span class="comment">// 资源数字ID</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        DWORD OffsetToData;               <span class="comment">// 数据偏移地址</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            DWORD OffsetToDirectory : <span class="number">31</span>; <span class="comment">// 子目录偏移地址</span></span><br><span class="line">            DWORD DataIsDirectory : <span class="number">1</span>;    <span class="comment">// 数据为目录</span></span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;</span><br></pre></td></tr></table></figure>

<p>第一个联合体的信息，是根据当前结构体所处的目录层次来决定的，位于 <code>第1层</code> 目录时 <code>Name</code> 有效，保存的<br>信息是 <code>资源类型</code>。位于 <code>第2层</code> 目录时 <code>Id</code> 或 <code>结构体</code> 有效，取决于此资源的 <code>索引方式</code>，如果用的是 <code>编号索引</code><br>就是 <code>Id</code> 有效，否则 <code>结构体</code> 有效。位于 <code>第3层</code> 目录时 <code>Name</code> 有效，保存的信息是 <code>语言类型</code>。</p>
<p>第二个联合体的信息，理论上是根据具体情况而定的，如果下级是一个 <code>子目录</code> 的话，那么就是 <code>结构体</code> 生效，<br>如果下级是 <code>资源数据</code> 则是字段 <code>OffsetToData</code> 生效。</p>
<p>当 <code>NameIsString</code> 为 <code>1</code> 时，<code>NameOffset</code> 指向一个 <code>IMAGE_RESOURCE_DIR_STRING_U</code> 结构体</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DIR_STRING_U</span> &#123;</span></span><br><span class="line">    WORD  Length;        <span class="comment">// 字符串的字节数</span></span><br><span class="line">    WCHAR NameString[<span class="number">1</span>]; <span class="comment">// 字符串的内容信息</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;</span><br></pre></td></tr></table></figure>

<p>当 <code>Name</code> 位于 <code>第1层</code> 目录时表示的 <code>资源类型</code> 如下表所示</p>
<table>
<thead>
<tr>
<th>类型值</th>
<th>资源类型</th>
<th>类型值</th>
<th>资源类型</th>
</tr>
</thead>
<tbody><tr>
<td>0x00000001</td>
<td>鼠标指针（Cursor）</td>
<td>0x00000008</td>
<td>字体（Font）</td>
</tr>
<tr>
<td>0x00000002</td>
<td>位图（Bitmap）</td>
<td>0x00000009</td>
<td>快捷键（Accelerators）</td>
</tr>
<tr>
<td>0x00000003</td>
<td>图标（Icon）</td>
<td>0x0000000A</td>
<td>非格式化资源（Unformatted）</td>
</tr>
<tr>
<td>0x00000004</td>
<td>菜单（Menu）</td>
<td>0x0000000B</td>
<td>消息列表（Message Table）</td>
</tr>
<tr>
<td>0x00000005</td>
<td>对话框（Dialog）</td>
<td>0x0000000C</td>
<td>鼠标指针组（Group Cursor）</td>
</tr>
<tr>
<td>0x00000006</td>
<td>字符串列表（String Table）</td>
<td>0x0000000E</td>
<td>图标组（Group Icon）</td>
</tr>
<tr>
<td>0x00000007</td>
<td>字体目录（Font Directory）</td>
<td>0x00000010</td>
<td>版本信息（Version Information）</td>
</tr>
</tbody></table>
<p>在经过3层目录的索引后，最后是一个 <code>IMAGE_RESOURCE_DATA_ENTRY</code> 结构体，定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_RESOURCE_DATA_ENTRY</span> &#123;</span></span><br><span class="line">    DWORD OffsetToData; <span class="comment">// 资源数据的RVA</span></span><br><span class="line">    DWORD Size;            <span class="comment">// 资源数据的大小</span></span><br><span class="line">    DWORD CodePage;        <span class="comment">// 代码页</span></span><br><span class="line">    DWORD Reserved;        <span class="comment">// 保留字段，通常为0x00000000</span></span><br><span class="line">&#125; IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;</span><br></pre></td></tr></table></figure>

<p>资源表的3层目录关系，如下图所示</p>
<p><img src="01.png" alt="关系图"></p>
<h4 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h4><p>系统在加载DLL文件时，并不是每次都能加载到预期的 <code>ImageBase</code> 基址上，所以DLL都存在 <code>基址重定位表</code>，<br>用来修正相关的地址信息，另外EXE的 <code>动态基址</code> 技术，也是用 <code>基址重定位表</code> 实现的。</p>
<p>PE文件中的重定位信息是由多个 <code>IMAGE_BASE_RELOCATION</code> 结构体组成的，每个结构体只描述一个 <code>4KB</code> 大小<br>的分页内重定位信息，也就是 <code>0x1000</code> 字节，因此结构体中 <code>VirtualAddress</code> 的值总是为 <code>0x1000</code> 的倍数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IMAGE_BASE_RELOCATION</span> &#123;</span></span><br><span class="line">    DWORD VirtualAddress; <span class="comment">// 需要重定位数据的起始RVA</span></span><br><span class="line">    DWORD SizeOfBlock;    <span class="comment">// 本结构与TypeOffset总大小</span></span><br><span class="line"><span class="comment">//  WORD  TypeOffset[1];  // 原则上不属于本结构</span></span><br><span class="line">&#125; IMAGE_BASE_RELOCATION, *PIMAGE_BASE_RELOCATION;</span><br></pre></td></tr></table></figure>

<p>重定位的本质非常简单，就是比较实际加载地址与 <code>ImageBase</code> 的值，如果相等则不需要做任何操作，如果<br>不相等就需要把重定位表中指定的地址处加上这个差值。</p>
<p><code>TypeOffset</code> 由两部分数据组成，<code>高4位</code> 表示 <code>类型</code>，<code>低12位</code> 表示 <code>偏移</code>。类型定义如下</p>
<table>
<thead>
<tr>
<th>值</th>
<th>信息</th>
<th>宏定义</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>无重定位操作，填0后用于4字节对齐</td>
<td>IMAGE_REL_BASED_ABSOLUTE</td>
</tr>
<tr>
<td>1</td>
<td>重定位偏移指向位置的高2个字节需要被修正</td>
<td>IMAGE_REL_BASED_HIGH</td>
</tr>
<tr>
<td>2</td>
<td>重定位偏移指向位置的高2个字节需要被修正</td>
<td>IMAGE_REL_BASED_LOW</td>
</tr>
<tr>
<td>3</td>
<td>重定位偏移指向的4个字节的地址需要被修正</td>
<td>IMAGE_REL_BASED_HIGHLOW</td>
</tr>
<tr>
<td>4</td>
<td>需要使用两项TypeOffset才能完成索引操作</td>
<td>IMAGE_REL_BASED_HIGHADJ</td>
</tr>
<tr>
<td>5</td>
<td>基址重定位应用于MIPS jump指令</td>
<td>IMAGE_REL_BASED_MIPS_JMPADDR</td>
</tr>
<tr>
<td>6</td>
<td>保留</td>
<td>IMAGE_REL_BASED_RESERVED</td>
</tr>
<tr>
<td>9</td>
<td>基址重定位应用于MIPS16 jump指令</td>
<td>IMAGE_REL_BASED_IA64_IMM64</td>
</tr>
<tr>
<td>10</td>
<td>重定位偏移指向的8个字节（64位）地址需要被修正</td>
<td>IMAGE_REL_BASED_DIR64</td>
</tr>
</tbody></table>
<p>重定位表结构如下图所示</p>
<p><img src="02.png" alt="结构图"></p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>函数的调用约定介绍(1)</title>
    <url>/2019/08/05/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E5%87%BD%E6%95%B0%E7%9A%84%E8%B0%83%E7%94%A8%E7%BA%A6%E5%AE%9A%E4%BB%8B%E7%BB%8D-1/</url>
    <content><![CDATA[<h4 id="调用方式介绍"><a href="#调用方式介绍" class="headerlink" title="调用方式介绍"></a>调用方式介绍</h4><p><code>__cdecl</code> 是 C Declaration 的缩写，表示C语言默认的函数调用方法：所有参数从右到左依次入栈。<br>这些参数在函数返回后由外部调用者清除，称为<code>手动清栈</code>。在外部使用 <code>add esp,x</code> 平衡堆栈，x是<br>参数所占的总字节数。利用此特性可以实现可变参数的函数功能。</p>
<p><code>__stdcall</code> 是 Standard Call 的缩写，是C++的标准调用方式：所有参数从右到左依次入栈。如果用<br>此方法调用类成员函数，最后一个入栈的是 <code>this</code> 指针。这些参数由函数自己内部在返回时清除，称为<br><code>自动清栈</code>。返回时使用 <code>retn x</code> 平衡堆栈，x表示参数所占的总字节数。</p>
<p><code>__fastcall</code> 是通过寄存器来传递参数的，利用 <code>ECX</code> 和 <code>EDX</code> 传送前两个双字 <code>DWORD</code> 或更小的参数。<br>如果还有更多的参数，则从右到左依次入栈。这些由堆栈传送的参数，由函数自己内部在返回时清除，<br>即 <code>自动清栈</code>。返回时使用 <code>retn x</code> 平衡堆栈，x表示使用堆栈传送的参数的总字节数。</p>
<p><code>__thsicall</code> 是仅仅应用于C++类成员函数。<code>this</code> 指针存放于 <code>ECX</code> 寄存器，该寄存器由编译器决定，<br>参数从右到左依次入栈，与 <code>__stdcall</code> 相同，返回时 <code>自动清栈</code>。<code>__thiscall</code> 不是关键词，因此不能<br>被程序员指定。在VC中编译器使用 <code>ECX</code> 传递，在Borland中编译器使用 <code>EAX</code> 传递。</p>
<p><code>nake call</code> 是裸函数调用方式。不对堆栈 <code>EBP</code> <code>ESP</code> 做处理，函数体不附带任何编译器附加的操作。<br>用 <code>__declspec(nake)</code> 定义，调用的方式依据编译器中设定的 <code>默认调用约定方式</code> 决定。</p>
<h4 id="导出的调用名称约定"><a href="#导出的调用名称约定" class="headerlink" title="导出的调用名称约定"></a>导出的调用名称约定</h4><p><code>__cdecl</code> 是在函数名前加上一个下划线前缀，格式为_functionname。</p>
<p><code>__stdcall</code> 是在函数名前加上一个下划线前缀，在后边加上一个@符号和其参数的总字节数。</p>
<p><code>__fastcall</code> 是在函数名前加上一个@符号，在后边也加上一个@符号和其参数的总字节数。</p>
<p><code>__thiscall</code> 是在函数名前加上类名和::符号。</p>
<p><code>nake call</code> 是依据编译器设定的调用约定方式决定。</p>
<h4 id="编译器设定默认调用约定"><a href="#编译器设定默认调用约定" class="headerlink" title="编译器设定默认调用约定"></a>编译器设定默认调用约定</h4><p>在VS中编译器默认为 <code>/Gd</code>，即 <code>__cdecl</code> 方式。<code>__stdcall</code> 对应为 <code>/Gz</code>，<code>__fastcall</code> 对应为 <code>/Gr</code>。</p>
<p><img src="01.png" alt="调用约定设置"></p>
<h4 id="相关示例代码"><a href="#相关示例代码" class="headerlink" title="相关示例代码"></a>相关示例代码</h4><p>我们编写一些示例的代码，来实际看一下内容</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EXPORT __declspec(dllexport)</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span>&#123;</span><br><span class="line">    <span class="function">EXPORT <span class="keyword">void</span> __cdecl <span class="title">FunA</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function">EXPORT <span class="keyword">void</span> __stdcall <span class="title">FunB</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;&#125;</span><br><span class="line">    <span class="function">EXPORT <span class="keyword">void</span> __fastcall <span class="title">FunC</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;&#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">CClassA</span> &#123;</span> <span class="keyword">public</span>: <span class="function"><span class="keyword">void</span> EXPORT __thiscall <span class="title">FunD</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123;&#125; &#125;;</span><br><span class="line">    EXPORT <span class="keyword">void</span> __declspec(naked) FunE(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> __cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CClassA obj;</span><br><span class="line">    FunA(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// __cdecl</span></span><br><span class="line">    FunB(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// __stdcall</span></span><br><span class="line">    FunC(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// __fastcall</span></span><br><span class="line">    obj.FunD(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// __thiscall</span></span><br><span class="line">    FunE(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// naked call</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>示例代码的的反编译后汇编指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">    CClassA obj;</span><br><span class="line">    FunA(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// __cdecl</span></span><br><span class="line"><span class="number">011514F</span>8 <span class="number">6</span>A <span class="number">03</span>                push        <span class="number">3</span>  </span><br><span class="line"><span class="number">011514F</span>A <span class="number">6</span>A <span class="number">02</span>                push        <span class="number">2</span>  </span><br><span class="line"><span class="number">011514F</span>C <span class="number">6</span>A <span class="number">01</span>                push        <span class="number">1</span>  </span><br><span class="line"><span class="number">011514F</span>E E8 <span class="number">42</span> FC FF FF       call        _FunA (<span class="number">01151145</span>h)  </span><br><span class="line"><span class="number">01151503</span> <span class="number">83</span> C4 <span class="number">0</span>C             add         esp,<span class="number">0</span>Ch  </span><br><span class="line">    FunB(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// __stdcall</span></span><br><span class="line"><span class="number">01151506</span> <span class="number">6</span>A <span class="number">03</span>                push        <span class="number">3</span>  </span><br><span class="line"><span class="number">01151508</span> <span class="number">6</span>A <span class="number">02</span>                push        <span class="number">2</span>  </span><br><span class="line"><span class="number">0115150</span>A <span class="number">6</span>A <span class="number">01</span>                push        <span class="number">1</span>  </span><br><span class="line"><span class="number">0115150</span>C E8 <span class="number">02</span> FC FF FF       call        _FunB@<span class="number">12</span> (<span class="number">01151113</span>h)  </span><br><span class="line">    FunC(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// __fastcall</span></span><br><span class="line"><span class="number">01151511</span> <span class="number">6</span>A <span class="number">03</span>                push        <span class="number">3</span>  </span><br><span class="line"><span class="number">01151513</span> BA <span class="number">02</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov         edx,<span class="number">2</span>  </span><br><span class="line"><span class="number">01151518</span> B9 <span class="number">01</span> <span class="number">00</span> <span class="number">00</span> <span class="number">00</span>       mov         ecx,<span class="number">1</span>  </span><br><span class="line"><span class="number">0115151</span>D E8 C9 FB FF FF       call        @FunC@<span class="number">12</span> (<span class="number">011510</span>EBh)  </span><br><span class="line">    obj.FunD(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// __thiscall</span></span><br><span class="line"><span class="number">01151522</span> <span class="number">6</span>A <span class="number">03</span>                push        <span class="number">3</span>  </span><br><span class="line"><span class="number">01151524</span> <span class="number">6</span>A <span class="number">02</span>                push        <span class="number">2</span>  </span><br><span class="line"><span class="number">01151526</span> <span class="number">6</span>A <span class="number">01</span>                push        <span class="number">1</span>  </span><br><span class="line"><span class="number">01151528</span> <span class="number">8</span>D <span class="number">4</span>D F7             lea         ecx,[obj]  </span><br><span class="line"><span class="number">0115152B</span> <span class="function">E8 B1 FB FF FF       call        <span class="title">CClassA::FunD</span> <span class="params">(<span class="number">011510E1</span>h)</span>  </span></span><br><span class="line"><span class="function">    <span class="title">FunE</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span></span>; <span class="comment">// naked call</span></span><br><span class="line"><span class="number">01151530</span> <span class="number">6</span>A <span class="number">03</span>                push        <span class="number">3</span>  </span><br><span class="line"><span class="number">01151532</span> <span class="number">6</span>A <span class="number">02</span>                push        <span class="number">2</span>  </span><br><span class="line"><span class="number">01151534</span> <span class="number">6</span>A <span class="number">01</span>                push        <span class="number">1</span>  </span><br><span class="line"><span class="number">01151536</span> E8 <span class="number">14</span> FC FF FF       call        _FunE (<span class="number">0115114F</span>h)  </span><br><span class="line"><span class="number">0115153B</span> <span class="number">83</span> C4 <span class="number">0</span>C             add         esp,<span class="number">0</span>Ch  </span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言与C语言混合编程(1)</title>
    <url>/2019/12/05/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E4%B8%8EC%E8%AF%AD%E8%A8%80%E6%B7%B7%E5%90%88%E7%BC%96%E7%A8%8B-1/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>有时候某些特殊的功能，需要我们使用汇编语言来实现，但是又没必要整个项目都用汇编语言，<br>所以使用汇编语言与C语言混合编程就成了最佳选择。</p>
<h4 id="代码嵌入"><a href="#代码嵌入" class="headerlink" title="代码嵌入"></a>代码嵌入</h4><p>在32位环境下，我们可以直接在C语言代码中嵌入汇编代码进行编程，这里不再专门说明。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myadd</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = <span class="number">0</span>;</span><br><span class="line">    _asm mov eax, a;</span><br><span class="line">    _asm add eax, b;</span><br><span class="line">    _asm mov c, eax;</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125; <span class="comment">// 在C中直接嵌入ASM</span></span><br></pre></td></tr></table></figure>

<h4 id="合并文件"><a href="#合并文件" class="headerlink" title="合并文件"></a>合并文件</h4><p>由于在64位环境下，无法直接在C语言代码中嵌入汇编代码，所以需要单独编写汇编文件，<br>编译成obj文件再与C语言进行合并。</p>
<p>在VS中，我们使用 <code>ml.exe</code> 和 <code>ml64.exe</code> 来单独编译 <code>.asm</code> 汇编代码文件。</p>
<p>在VS的 <code>解决方案管理器</code> 里，直接在 <code>asm</code> 文件上 <code>右键</code> 选择 <code>属性</code> 项</p>
<p><img src="01.png" alt="asm文件属性"></p>
<p>通常情况下 <code>配置属性</code> 里只有一个 <code>常规</code> 选项，在其中的 <code>项类型</code> 里修改为 <code>自定义生成工具</code></p>
<p><img src="02.png" alt="自定义生成工具"></p>
<p>点击 <code>应用</code> 之后，在 <code>配置属性</code> 里会多出 <code>自定义生成工具</code> 选项，我们在 <code>命令行</code> 和 <code>输出</code> 里添加指令</p>
<p><img src="03.png" alt="指令"></p>
<p>在32位环境下的命令行（asm文件在i386asm目录下）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ml &#x2F;Fo $(IntDir)%(fileName).obj &#x2F;c i386asm\%(fileName).asm</span><br></pre></td></tr></table></figure>

<p>在64位环境下的命令行（asm文件在amd64asm目录下）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ml64 &#x2F;Fo $(IntDir)%(fileName).obj &#x2F;c amd64asm\%(fileName).asm</span><br></pre></td></tr></table></figure>

<p>输出项对应的指令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$(IntDir)%(fileName).obj;%(Outputs)</span><br></pre></td></tr></table></figure>

<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>在32位环境下的asm示例代码，以及对应的函数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> _cdecl <span class="title">mysub</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">int</span> _stdcall <span class="title">myadd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;flat(平坦模式) c(C调用) stdcall(STD调用)</span><br><span class="line">.model flat, c</span><br><span class="line">.code</span><br><span class="line">mysub proc</span><br><span class="line">push ebp</span><br><span class="line">mov ebp, esp</span><br><span class="line">mov eax, [ebp + 8]</span><br><span class="line">sub eax, [ebp + 12]</span><br><span class="line">mov esp, ebp  </span><br><span class="line">pop ebp  </span><br><span class="line">ret</span><br><span class="line">mysub endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">;flat(平坦模式) c(C调用) stdcall(STD调用)</span><br><span class="line">.model flat, stdcall</span><br><span class="line">.code</span><br><span class="line">;stdcall需要标明参数来确定调用名(_myadd@8)</span><br><span class="line">myadd proc, x:dword, y:dword</span><br><span class="line">;编译器自动添加push ebp</span><br><span class="line">;编译器自动添加mov ebp, esp</span><br><span class="line">mov eax, x</span><br><span class="line">add eax, y</span><br><span class="line">;编译器自动添加leave</span><br><span class="line">ret 8</span><br><span class="line">myadd endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>在64位环境下的asm示例代码，以及对应的函数声明</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// x64汇编只有fastcall方式，并且与x86的fastcall不同</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">myadd64</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.code</span><br><span class="line">myadd64 proc</span><br><span class="line">mov rax, rcx</span><br><span class="line">add rax, rdx</span><br><span class="line">ret</span><br><span class="line">myadd64 endp</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<h4 id="DDK环境"><a href="#DDK环境" class="headerlink" title="DDK环境"></a>DDK环境</h4><p>在VS中无论编译应用程序，还是编译驱动程序，统一都是使用上述方法。</p>
<p>在DDK环境中编译驱动时，则是在source文件中增加文件包含：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I386_SOURCES&#x3D;\</span><br><span class="line">    test32.asm ;编译32位驱动文件</span><br><span class="line">AMD64_SOURCES&#x3D;\</span><br><span class="line">    test64.asm ;编译64位驱动文件</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>PE文件中的数字签名信息(1)</title>
    <url>/2019/12/20/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/PE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%BF%A1%E6%81%AF-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>PE文件数字签名使用的是 <code>Authenticode</code> 数字签名格式，它用来验证二进制程序的来源和完整性。<br>基于公开密匙加密标准 <code>PKCS #7</code> 来签名数据，并使用 <code>X.509</code> 证书来关联二进制程序与其发布者。</p>
<p>关于在PE文件中的 <code>Authenticode</code> 格式签名，微软给出了详细的解释，下载链接如下：<br><a href="http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Authenticode_PE.docx">http://download.microsoft.com/download/9/c/5/9c5b2167-8017-4bae-9fde-d599bac8184a/Authenticode_PE.docx</a></p>
<h4 id="签名的位置"><a href="#签名的位置" class="headerlink" title="签名的位置"></a>签名的位置</h4><p>在PE文件数据目录表中，存储着签名信息的偏移地址和大小，如下图所示</p>
<p><img src="01.png" alt="签名位置"></p>
<p>灰色背景的部分，不参与签名的hash计算。粗体的部分，就是签名的相关内容。</p>
<h4 id="签名的格式"><a href="#签名的格式" class="headerlink" title="签名的格式"></a>签名的格式</h4><p>提取出来的签名信息，如下结构体所示，相关信息都在 <code>Wintrust.h</code> 头文件中定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WIN_CERTIFICATE</span> &#123;</span></span><br><span class="line">    DWORD    dwLength; <span class="comment">// 签名证书二进制数据的长度</span></span><br><span class="line">    WORD     wRevision; <span class="comment">// 签名证书的版本号</span></span><br><span class="line">    WORD     wCertificateType; <span class="comment">// 签名证书的类型</span></span><br><span class="line">    BYTE     bCertificate[ANYSIZE_ARRAY]; <span class="comment">// 签名证书二进制数据</span></span><br><span class="line">&#125; WIN_CERTIFICATE, *LPWIN_CERTIFICATE;</span><br></pre></td></tr></table></figure>

<p><code>wRevision</code> 签名证书版本号，内容如下所示</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Name</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>0x0100</td>
<td>WIN_CERT_REVISION_1_0</td>
<td>Version 1 is the legacy version of WIN_CERTIFICATE. <br />It is supported only for verifying legacy Authenticode signatures.</td>
</tr>
<tr>
<td>0x0200</td>
<td>WIN_CERT_REVISION_2_0</td>
<td>Version 2 is the current version of WIN_CERTIFICATE.</td>
</tr>
</tbody></table>
<p><code>wCertificateType</code> 签名证书类型，这里值为 <code>0x0002</code> 表示 <code>Authenticode signatures</code> 类型</p>
<table>
<thead>
<tr>
<th>Value</th>
<th>Name</th>
<th>Notes</th>
</tr>
</thead>
<tbody><tr>
<td>0x0001</td>
<td>WIN_CERT_TYPE_X509</td>
<td>bCertificate contains an X.509 Certificate</td>
</tr>
<tr>
<td>0x0002</td>
<td>WIN_CERT_TYPE_PKCS_SIGNED_DATA</td>
<td>bCertificate contains a PKCS SignedData structure</td>
</tr>
<tr>
<td>0x0003</td>
<td>WIN_CERT_TYPE_RESERVED_1</td>
<td>Reserved</td>
</tr>
<tr>
<td>0x0004</td>
<td>WIN_CERT_TYPE_TS_STACK_SIGNED</td>
<td>Terminal Server Protocol Stack Certificate signing</td>
</tr>
</tbody></table>
<p><code>bCertificate[ANYSIZE_ARRAY]</code> 签名证书的二进制数据，使用的是 <code>ASN.1</code> 语法 <code>BER</code> 编码格式。</p>
<h4 id="签名的验证"><a href="#签名的验证" class="headerlink" title="签名的验证"></a>签名的验证</h4><p>在应用层可以使用 <code>Wintrust.lib</code> 库中的 <code>WinVerifyTrust</code> 函数来验证签名的信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LONG WINAPI <span class="title">WinVerifyTrust</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ HWND   hWnd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ GUID   *pgActionID,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPVOID pWVTData</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>经过测试，在使用 <code>WinVerifyTrust</code> 验证签名时，偶尔会出现响应特别慢的情况。假如我们在驱动中<br>做进程签名拦截，借助于应用层验证签名时，就会造成系统卡顿现象。或者使用 <code>openssl</code> 库来验证签名，<br>可以避免卡顿。</p>
<p>另一种方案就是直接在驱动中验证，自行实现签名的验证代码，可以加快检测速度，但是显然这种方案工作量<br>特别庞大。经过研究发现 <code>commonName</code> 信息在签名二进制数据中是以 <code>UTF8</code> 格式明文存储的，所以可以采取<br>只验证 <code>commonName</code> 信息是否在黑名单中，而不验证整个证书链是否有效的简化方案。</p>
<h4 id="签名的提取"><a href="#签名的提取" class="headerlink" title="签名的提取"></a>签名的提取</h4><p>在驱动中提取签名二进制数据信息，相关结构体的定义如下，我们不关心的成员就不再详细定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DOS_HEADER</span> &#123;</span></span><br><span class="line">    USHORT e_magic;</span><br><span class="line">    USHORT e_res[<span class="number">29</span>];</span><br><span class="line">    UINT32 e_lfanew;</span><br><span class="line">&#125; DOS_HEADER, *PDOS_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">FILE_HEADER</span> &#123;</span></span><br><span class="line">    UINT32 Reserved[<span class="number">5</span>];</span><br><span class="line">&#125; FILE_HEADER, *PFILE_HEADER;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DATA_DIRECTORY</span> &#123;</span></span><br><span class="line">    UINT32 VAddr;</span><br><span class="line">    UINT32 Size;</span><br><span class="line">&#125; DATA_DIRECTORY, *PDATA_DIRECTORY;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OPTIONAL_HEADER32</span> &#123;</span></span><br><span class="line">    USHORT Magic;</span><br><span class="line">    USHORT Reserved1[<span class="number">11</span>];</span><br><span class="line">    UINT32 ImageBase; <span class="comment">// 32</span></span><br><span class="line">    USHORT Reserved2[<span class="number">20</span>];</span><br><span class="line">    UINT32 Reserved3[<span class="number">4</span>]; <span class="comment">// 32</span></span><br><span class="line">    USHORT Reserved4[<span class="number">4</span>];</span><br><span class="line">    DATA_DIRECTORY DataDir[<span class="number">16</span>];</span><br><span class="line">&#125; OPTIONAL_HEADER32, *POPTIONAL_HEADER32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OPTIONAL_HEADER64</span> &#123;</span></span><br><span class="line">    USHORT Magic;</span><br><span class="line">    USHORT Reserved1[<span class="number">11</span>];</span><br><span class="line">    UINT64 ImageBase; <span class="comment">// 64</span></span><br><span class="line">    USHORT Reserved2[<span class="number">20</span>];</span><br><span class="line">    UINT64 Reserved3[<span class="number">4</span>]; <span class="comment">// 64</span></span><br><span class="line">    USHORT Reserved4[<span class="number">4</span>];</span><br><span class="line">    DATA_DIRECTORY DataDir[<span class="number">16</span>];</span><br><span class="line">&#125; OPTIONAL_HEADER64, *POPTIONAL_HEADER64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NT_HEADERS32</span> &#123;</span></span><br><span class="line">    UINT32 Signature;</span><br><span class="line">    FILE_HEADER FileHeader;</span><br><span class="line">    OPTIONAL_HEADER32 OptHeader;</span><br><span class="line">&#125; NT_HEADERS32, *PNT_HEADERS32;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">NT_HEADERS64</span> &#123;</span></span><br><span class="line">    UINT32 Signature;</span><br><span class="line">    FILE_HEADER FileHeader;</span><br><span class="line">    OPTIONAL_HEADER64 OptHeader;</span><br><span class="line">&#125; NT_HEADERS64, *PNT_HEADERS64;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WIN_CERT</span> &#123;</span></span><br><span class="line">    UINT32 Length;</span><br><span class="line">    USHORT Revision;</span><br><span class="line">    USHORT CertType;</span><br><span class="line">&#125; WIN_CERT, *PWIN_CERT;</span><br></pre></td></tr></table></figure>

<p>提取签名信息的函数如下，假定参数的路径为 <code>\\??\\C:\Windows\System32\calc.exe</code> 这种格式</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">CheckSignProcess</span><span class="params">(IN PWCHAR Path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PWIN_CERT WinCert = <span class="literal">NULL</span>;</span><br><span class="line">    PDOS_HEADER DosHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PNT_HEADERS32 NtHeader32 = <span class="literal">NULL</span>;</span><br><span class="line">    PNT_HEADERS64 NtHeader64 = <span class="literal">NULL</span>;</span><br><span class="line">    DATA_DIRECTORY DataDir = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    BOOLEAN bRet = FALSE; <span class="comment">// 默认不在黑名单中</span></span><br><span class="line">    HANDLE hFile = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    IO_STATUS_BLOCK ioStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    OBJECT_ATTRIBUTES objAttrib = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    FILE_POSITION_INFORMATION PosInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 检查参数</span></span><br><span class="line">    <span class="keyword">if</span> (Path == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 初始化文件属性</span></span><br><span class="line">    InitializeObjectAttributes(&amp;objAttrib, &amp;Path,</span><br><span class="line">        OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 打开目标文件</span></span><br><span class="line">    Status = ZwOpenFile(</span><br><span class="line">        &amp;hFile, GENERIC_READ | SYNCHRONIZE, &amp;objAttrib, &amp;ioStatus,</span><br><span class="line">        FILE_SHARE_READ, FILE_SYNCHRONOUS_IO_NONALERT | FILE_NON_DIRECTORY_FILE);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 申请PE头内存空间</span></span><br><span class="line">        DosHeader = (PDOS_HEADER)ExAllocatePoolWithTag(NonPagedPool, 1024, &#x27;MEM&#x27;);</span><br><span class="line">        <span class="keyword">if</span> (DosHeader == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 读取PE头信息到缓冲区</span></span><br><span class="line">        Status = ZwReadFile(hFile, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">            &amp;ioStatus, (PVOID)DosHeader, <span class="number">1024</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 检测DOS头信息</span></span><br><span class="line">        <span class="keyword">if</span> (ioStatus.Information &lt; <span class="keyword">sizeof</span>(DOS_HEADER)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (DosHeader-&gt;e_magic != <span class="number">0x5A4D</span>) <span class="keyword">break</span>; <span class="comment">// IMAGE_DOS_SIGNATURE</span></span><br><span class="line">        NtHeader32 = (PNT_HEADERS32)((PUCHAR)DosHeader + DosHeader-&gt;e_lfanew);</span><br><span class="line">        <span class="comment">// 被改造过的程序重新读NT头</span></span><br><span class="line">        <span class="keyword">if</span> (DosHeader-&gt;e_lfanew &gt; <span class="number">0x108</span>) <span class="comment">// 大于默认偏移</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 设置文件偏移位置</span></span><br><span class="line">            PosInfo.CurrentByteOffset.QuadPart = DosHeader-&gt;e_lfanew;</span><br><span class="line">            Status = ZwSetInformationFile(hFile, &amp;ioStatus, &amp;PosInfo,</span><br><span class="line">                <span class="keyword">sizeof</span>(FILE_POSITION_INFORMATION), FilePositionInformation);</span><br><span class="line">            <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// 读取NT头信息到缓冲区</span></span><br><span class="line">            Status = ZwReadFile(hFile, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">                &amp;ioStatus, (PVOID)DosHeader, <span class="number">1024</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span> (ioStatus.Information &lt; <span class="keyword">sizeof</span>(NT_HEADERS32)) <span class="keyword">break</span>;</span><br><span class="line">            NtHeader32 = (PNT_HEADERS32)DosHeader;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检测NT头信息</span></span><br><span class="line">        <span class="keyword">if</span> (NtHeader32-&gt;Signature != <span class="number">0x4550</span>) <span class="keyword">break</span>; <span class="comment">// IMAGE_NT_SIGNATURE</span></span><br><span class="line">        <span class="keyword">if</span> (NtHeader32-&gt;OptHeader.Magic == <span class="number">0x10B</span>) <span class="comment">// IMAGE_NT_OPTIONAL_HDR32_MAGIC</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// IMAGE_DIRECTORY_ENTRY_SECURITY</span></span><br><span class="line">            DataDir.VAddr = NtHeader32-&gt;OptHeader.DataDir[<span class="number">4</span>].VAddr;</span><br><span class="line">            DataDir.Size = NtHeader32-&gt;OptHeader.DataDir[<span class="number">4</span>].Size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (NtHeader32-&gt;OptHeader.Magic == <span class="number">0x20B</span>) <span class="comment">// IMAGE_NT_OPTIONAL_HDR64_MAGIC</span></span><br><span class="line">        &#123;</span><br><span class="line">            NtHeader64 = (PNT_HEADERS64)NtHeader32;</span><br><span class="line">            <span class="comment">// IMAGE_DIRECTORY_ENTRY_SECURITY</span></span><br><span class="line">            DataDir.VAddr = NtHeader64-&gt;OptHeader.DataDir[<span class="number">4</span>].VAddr;</span><br><span class="line">            DataDir.Size = NtHeader64-&gt;OptHeader.DataDir[<span class="number">4</span>].Size;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 申请签名缓冲区</span></span><br><span class="line">        <span class="keyword">if</span> ((DataDir.VAddr == <span class="number">0</span>) || (DataDir.Size == <span class="number">0</span>)) <span class="keyword">break</span>; <span class="comment">// 无签名</span></span><br><span class="line">        WinCert = (PWIN_CERT)ExAllocatePoolWithTag(NonPagedPool, DataDir.Size, &#x27;MEM&#x27;);</span><br><span class="line">        <span class="keyword">if</span> (WinCert == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 设置文件偏移位置</span></span><br><span class="line">        PosInfo.CurrentByteOffset.QuadPart = DataDir.VAddr;</span><br><span class="line">        Status = ZwSetInformationFile(hFile, &amp;ioStatus, &amp;PosInfo,</span><br><span class="line">            <span class="keyword">sizeof</span>(FILE_POSITION_INFORMATION), FilePositionInformation);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 读取文件签名信息</span></span><br><span class="line">        Status = ZwReadFile(hFile, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>,</span><br><span class="line">            &amp;ioStatus, (PVOID)WinCert, DataDir.Size, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (ioStatus.Information != DataDir.Size) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 检查签名信息是否在黑名单中</span></span><br><span class="line">        <span class="keyword">if</span> (WinCert-&gt;CertType != <span class="number">0x0002</span>) <span class="keyword">break</span>; </span><br><span class="line">        bRet = CheckSign((PUCHAR)(WinCert + <span class="number">1</span>), DataDir.Size - <span class="keyword">sizeof</span>(WIN_CERT));</span><br><span class="line">        <span class="comment">// 这里CheckSign函数在下篇文章中再说明</span></span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 收尾处理</span></span><br><span class="line">    ZwClose(hFile);</span><br><span class="line">    <span class="keyword">if</span> (WinCert != <span class="literal">NULL</span>) ExFreePool(WinCert);</span><br><span class="line">    <span class="keyword">if</span> (DosHeader != <span class="literal">NULL</span>) ExFreePool(DosHeader);</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数字签名</category>
      </categories>
      <tags>
        <tag>数字签名</tag>
      </tags>
  </entry>
  <entry>
    <title>PE文件中的数字签名信息(2)</title>
    <url>/2019/12/23/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/PE%E6%96%87%E4%BB%B6%E4%B8%AD%E7%9A%84%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D%E4%BF%A1%E6%81%AF-2/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在上篇文章中，我们已经提取到了签名二进制数据，使用的是 <code>ASN.1</code> 语法 <code>BER</code> 编码格式，<br>那么如下为关于 <code>ASN.1</code> 和 <code>BER</code> 的简单介绍，以及其对应的解析方法。</p>
<h4 id="ASN-1介绍"><a href="#ASN-1介绍" class="headerlink" title="ASN.1介绍"></a>ASN.1介绍</h4><p><code>ASN.1 </code>是一种 <code>抽象语法标记</code> 语言，本身只定义表示信息的抽象句法，并没有对编码的方法做出限定。<br>其可以使用的编码规则有很多，这里使用的是基本编码规则 <code>BER</code>，即 <code>Basic Encoding Rules</code> 。</p>
<p>在上篇文章给出的微软链接 <code>Authenticode_PE.docx</code> 文档中，有关于签名的具体 <code>ASN.1</code> 结构体定义。<br>另外微软关于 <code>BER</code> 的一些知识也做了说明，相关链接如下：<br><a href="https://docs.microsoft.com/en-us/windows/win32/seccertenroll/distinguished-encoding-rules">https://docs.microsoft.com/en-us/windows/win32/seccertenroll/distinguished-encoding-rules</a></p>
<h4 id="BER编码规则介绍"><a href="#BER编码规则介绍" class="headerlink" title="BER编码规则介绍"></a>BER编码规则介绍</h4><p>BER语法的格式是 <code>TLV</code> 三元组 <code>&lt;Type, Length, Value&gt;</code>，如下图所示</p>
<p><img src="01.png" alt="TLV格式"></p>
<p>该三元组整体可以作为 <code>Value</code> 进行嵌套或者组合，如下图所示</p>
<p><img src="02.png" alt="TLV嵌套和组合"></p>
<p>BER语法是基于八位组大端编码的，高位在左，底位在右。</p>
<h5 id="Tag的格式"><a href="#Tag的格式" class="headerlink" title="Tag的格式"></a>Tag的格式</h5><p>Tag的格式按位数划分，如下图所示</p>
<p><img src="03.png" alt="Tag格式"></p>
<p>第7,6位指明Tag的类型。第5位指明该类型以 <code>primitive</code> 方式编码还是 <code>constructed</code> 方式编码</p>
<table>
<thead>
<tr>
<th>第7,6位</th>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>UNIVERSAL</td>
<td>标准类型，规定的固定类型</td>
</tr>
<tr>
<td>01</td>
<td>APPLICATION</td>
<td>唯一标志应用内的类型，不推荐使用</td>
</tr>
<tr>
<td>10</td>
<td>context-specific</td>
<td>由上下文指定类型，在SEQUENCE、SET和CHOICE类型中使用</td>
</tr>
<tr>
<td>11</td>
<td>PRIVATE</td>
<td>在小范围内唯一标志一个类型，不推荐使用</td>
</tr>
</tbody></table>
<p>其中 <code>UNIVERSAL</code> 类型规定的固定类型如下所示</p>
<table>
<thead>
<tr>
<th>第4-0位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>保留</td>
</tr>
<tr>
<td>1</td>
<td>BOOLEAN</td>
</tr>
<tr>
<td>2</td>
<td>INTEGER</td>
</tr>
<tr>
<td>3</td>
<td>BIT STRING</td>
</tr>
<tr>
<td>4</td>
<td>OCTET STRING</td>
</tr>
<tr>
<td>5</td>
<td>NULL</td>
</tr>
<tr>
<td>6</td>
<td>OBJECT IDENTIFIER</td>
</tr>
<tr>
<td>7</td>
<td>ObjectDescripion</td>
</tr>
<tr>
<td>8</td>
<td>EXTERNAL,INSTANCE OF</td>
</tr>
<tr>
<td>9</td>
<td>REAL</td>
</tr>
<tr>
<td>10</td>
<td>ENUMERATED</td>
</tr>
<tr>
<td>11</td>
<td>EMBEDDED PDV</td>
</tr>
<tr>
<td>12</td>
<td>UFT8String</td>
</tr>
<tr>
<td>13</td>
<td>RELATIVE-OID</td>
</tr>
<tr>
<td>14</td>
<td>保留</td>
</tr>
<tr>
<td>15</td>
<td>保留</td>
</tr>
<tr>
<td>16</td>
<td>SEQUENCE,SEQUENCE OF</td>
</tr>
<tr>
<td>17</td>
<td>SET,SET OF</td>
</tr>
<tr>
<td>18</td>
<td>NumericString</td>
</tr>
<tr>
<td>19</td>
<td>PrintableString</td>
</tr>
<tr>
<td>20</td>
<td>TeletexString,T61String</td>
</tr>
<tr>
<td>21</td>
<td>VideotexString</td>
</tr>
<tr>
<td>22</td>
<td>IA5String</td>
</tr>
<tr>
<td>23</td>
<td>UTCTime</td>
</tr>
<tr>
<td>24</td>
<td>GeneralizedTime</td>
</tr>
<tr>
<td>25</td>
<td>GraphicString</td>
</tr>
<tr>
<td>26</td>
<td>VisibleString,ISO646String</td>
</tr>
<tr>
<td>27</td>
<td>GeneralString</td>
</tr>
<tr>
<td>28</td>
<td>UniversalString</td>
</tr>
<tr>
<td>29</td>
<td>CHARACTER STRING</td>
</tr>
<tr>
<td>30</td>
<td>BMPString</td>
</tr>
<tr>
<td>31</td>
<td>保留</td>
</tr>
</tbody></table>
<p>如果Tag大于0x30，当第1个字节低5位全部为1时，后续的字节最高位为1表示还有，为0表示Tag结束</p>
<p><img src="04.png" alt="Tag大于0x30时"></p>
<h5 id="Length的格式"><a href="#Length的格式" class="headerlink" title="Length的格式"></a>Length的格式</h5><p><code>Length</code> 表示 <code>Content</code> 的字节长度，如果 <code>Content</code> 超过127个字节，还需要增加表示 <code>Length</code> 的长度，<br>方法为在长度数据的前边添加 <code>0x80</code>，比如 <code>0x30 82 01 10</code> 这里的 <code>0x82</code> 表示后边2个字节都是长度数据。</p>
<h4 id="对象标识符"><a href="#对象标识符" class="headerlink" title="对象标识符"></a>对象标识符</h4><p>对象标识符（OBJECT IDENTIFIER, OID）类型，用层次的形式来表示标准规范，标识符树通过一个点分的<br>十进制符号来定义，这个符号以组织、子部分、标准的类型和各自的子标识符开始。</p>
<p>例如：MD5的OID是 <code>1.2.840.113549.2.5</code> 表示为 iso(1),member-body(2),US(840),rsadsi(113549),<br>digestAlgorithm(2),md5(5)。</p>
<p>OID的编码规则：将前两部分定义为x.y，合成为一个字节40*x+y，其余每个部分按照big-endian格式，<br>按照7个bit位进行分割，每个分割出来的片段第8标为1，组成一个字节，最后一个片段第8位标为0。</p>
<p>例如：MD5的计算方式为，原始数据为(42,840,113549,2,5)，按照7位分割后((0x2A),(0x86,0x48),<br>(0x86,0xF7,0x0D),(0x02),(0x05))，最终 <code>TLV</code> 编码为 <code>0x06 08 2A 86 48 86 F7 0D 02 05</code> 。</p>
<p>如下为微软给出的OID信息如何计算的链接：<br><a href="https://docs.microsoft.com/en-us/windows/win32/seccertenroll/about-object-identifier">https://docs.microsoft.com/en-us/windows/win32/seccertenroll/about-object-identifier</a></p>
<h4 id="查找签名的代码"><a href="#查找签名的代码" class="headerlink" title="查找签名的代码"></a>查找签名的代码</h4><p>查找签名的过程，就是循环解析 <code>TLV</code> 三元组信息，找到签名对应的 <code>OID</code> 信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">CheckSign</span><span class="params">(IN PUCHAR Buffer, IN UINT32 Size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT32 i = <span class="number">0</span>;</span><br><span class="line">    UCHAR TagPC = <span class="number">0</span>; <span class="comment">// primitive(0) constructed(1)</span></span><br><span class="line">    UCHAR TagClass = <span class="number">0</span>; <span class="comment">// TAG的类型</span></span><br><span class="line">    UINT32 TagValue = <span class="number">0</span>;</span><br><span class="line">    UINT32 TagLen = <span class="number">0</span>;</span><br><span class="line">    UINT32 LenValue = <span class="number">0</span>;</span><br><span class="line">    UINT32 LenLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; Size)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 解析TAG信息</span></span><br><span class="line">        <span class="keyword">if</span> (!Asn1BerTagDec(Buffer + i, Size - i,</span><br><span class="line">            &amp;TagClass, &amp;TagPC, &amp;TagValue, &amp;TagLen)) <span class="keyword">break</span>;</span><br><span class="line">        i += TagLen;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= Size) <span class="keyword">break</span>; <span class="comment">// 遍历结束</span></span><br><span class="line">        <span class="comment">// 解析LEN信息</span></span><br><span class="line">        <span class="keyword">if</span> (!Asn1BerLenDec(Buffer + i, Size - i, &amp;LenValue, &amp;LenLen)) <span class="keyword">break</span>;</span><br><span class="line">        i += LenLen;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= Size) <span class="keyword">break</span>; <span class="comment">// 遍历结束</span></span><br><span class="line">        <span class="comment">// 检测是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (TagPC != <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 非原子节点</span></span><br><span class="line">        i += LenValue;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= Size) <span class="keyword">break</span>; <span class="comment">// 遍历结束</span></span><br><span class="line">        <span class="keyword">if</span> (TagClass != <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 非通用类型</span></span><br><span class="line">        <span class="keyword">if</span> (TagLen != <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// TAG长度不是1</span></span><br><span class="line">        <span class="keyword">if</span> (TagValue != <span class="number">0x06</span>) <span class="keyword">continue</span>; <span class="comment">// TAG内容不是OBJECT IDENTIFIER</span></span><br><span class="line">        <span class="keyword">if</span> (LenLen != <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// LEN长度不是1</span></span><br><span class="line">        <span class="keyword">if</span> (LenValue != <span class="number">3</span>) <span class="keyword">continue</span>; <span class="comment">// LEN内容不是3</span></span><br><span class="line">        <span class="keyword">if</span> ((i - LenValue + <span class="number">2</span>) &gt;= Size) <span class="keyword">break</span>; <span class="comment">// 55 04 03 commonName(2.5.4.3)</span></span><br><span class="line">        <span class="keyword">if</span> (*(Buffer + i - LenValue) != <span class="number">0x55</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (*(Buffer + i - LenValue + <span class="number">1</span>) != <span class="number">0x04</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span> (*(Buffer + i - LenValue + <span class="number">2</span>) != <span class="number">0x03</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 处理TAG信息</span></span><br><span class="line">        <span class="keyword">if</span> (!Asn1BerTagDec(Buffer + i, Size - i,</span><br><span class="line">            &amp;TagClass, &amp;TagPC, &amp;TagValue, &amp;TagLen)) <span class="keyword">break</span>;</span><br><span class="line">        i += TagLen;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= Size) <span class="keyword">break</span>; <span class="comment">// 遍历结束</span></span><br><span class="line">        <span class="comment">// 处理LEN信息</span></span><br><span class="line">        <span class="keyword">if</span> (!Asn1BerLenDec(Buffer + i, Size - i, &amp;LenValue, &amp;LenLen)) <span class="keyword">break</span>;</span><br><span class="line">        i += LenLen;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= Size) <span class="keyword">break</span>; <span class="comment">// 遍历结束</span></span><br><span class="line">        <span class="comment">// 检测是否匹配</span></span><br><span class="line">        <span class="keyword">if</span> (TagPC != <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 非原子节点</span></span><br><span class="line">        i += LenValue;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= Size) <span class="keyword">break</span>; <span class="comment">// 遍历结束</span></span><br><span class="line">        <span class="keyword">if</span> (TagClass != <span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">// 非通用类型</span></span><br><span class="line">        <span class="keyword">if</span> (TagLen != <span class="number">1</span>) <span class="keyword">continue</span>; <span class="comment">// TAG长度不是1</span></span><br><span class="line">        <span class="keyword">if</span> ((TagValue != <span class="number">0x0C</span>) &amp;&amp; <span class="comment">// UTF8String(0x0C)</span></span><br><span class="line">            (TagValue != <span class="number">0x13</span>)) <span class="keyword">continue</span>; <span class="comment">// PrintableString(0x13)</span></span><br><span class="line">        <span class="comment">// 与黑名单签名信息做对比</span></span><br><span class="line">        <span class="keyword">if</span> (CompareSign(Buffer + i - LenValue, LenValue))</span><br><span class="line">            <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析Tag的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">Asn1BerTagDec</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PUCHAR Buffer, IN UINT32 Size,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PUCHAR Class, <span class="comment">// Tag的分类</span></span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PUCHAR PC, <span class="comment">// primitive(0) constructed(1)</span></span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PUINT32 Value, <span class="comment">// UNIVERSAL的类型</span></span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PUINT32 Len)</span> <span class="comment">// Tag自身的长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT32 i = <span class="number">0</span>;</span><br><span class="line">    *Class = (*Buffer) &amp; <span class="number">0xC0</span>;</span><br><span class="line">    *PC = (*Buffer) &amp; <span class="number">0x20</span>;</span><br><span class="line">    <span class="comment">// 检测数据长度</span></span><br><span class="line">    <span class="keyword">if</span> (((*Buffer) &amp; <span class="number">0x1F</span>) == <span class="number">0x1F</span>) <span class="comment">// 长编码格式</span></span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= Size) <span class="keyword">return</span> FALSE;</span><br><span class="line">        *Value = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> ((Buffer[i] &amp; <span class="number">0x80</span>) == <span class="number">0x80</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *Value += ((Buffer[i] &amp; <span class="number">0x7F</span>) &lt;&lt; <span class="number">7</span>);</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= Size) <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        *Len = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 短编码格式</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> ((*Buffer) == <span class="number">0</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">        *Value = (*Buffer) &amp; <span class="number">0x1F</span>;</span><br><span class="line">        *Len = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解析Length的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">Asn1BerLenDec</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PUCHAR Buffer, IN UINT32 Size,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PUINT32 Value, <span class="comment">// Content的长度</span></span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PUINT32 Len)</span> <span class="comment">// Length自身的长度</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UINT32 i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((*Buffer) &gt; <span class="number">0x7F</span>) <span class="comment">// 长编码格式</span></span><br><span class="line">    &#123;</span><br><span class="line">        i++;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= Size) <span class="keyword">return</span> FALSE;</span><br><span class="line">        *Value = <span class="number">0</span>;</span><br><span class="line">        *Len = (*Buffer) &amp; <span class="number">0x7F</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt;= *Len)</span><br><span class="line">        &#123;</span><br><span class="line">            *Value = ((*Value) &lt;&lt; <span class="number">8</span>) + Buffer[i];</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= Size) <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        *Len += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 短编码格式</span></span><br><span class="line">    &#123;</span><br><span class="line">        *Value = *Buffer;</span><br><span class="line">        *Len = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数字签名</category>
      </categories>
      <tags>
        <tag>数字签名</tag>
      </tags>
  </entry>
  <entry>
    <title>使用XCA工具生成签名证书(1)</title>
    <url>/2019/12/19/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E4%BD%BF%E7%94%A8XCA%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E7%AD%BE%E5%90%8D%E8%AF%81%E4%B9%A6-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>生成签名证书的工具有很多，最为常见的就是使用 <code>openssl</code> 库来生成证书，但是操作起来<br>并不是特别友好，这里我们介绍一个叫 <code>XCA</code> 的软件，可以对各种证书进行图形界面操作。</p>
<h4 id="证书链信息"><a href="#证书链信息" class="headerlink" title="证书链信息"></a>证书链信息</h4><p>通常情况下，证书链最上级是 <code>Root CA</code> 证书，下属的是各种用途的 <code>CA</code> 证书，再往下一层，就是<br>颁发给各公司进行 <code>数字签名</code> 的证书。如果只是自己测试使用，可以直接使用 <code>Root CA</code> 进行签名操作</p>
<h4 id="生成CA证书"><a href="#生成CA证书" class="headerlink" title="生成CA证书"></a>生成CA证书</h4><p>XCA软件可以在此链接下载：<a href="https://www.hohnstaedt.de/xca/index.php/download">https://www.hohnstaedt.de/xca/index.php/download</a><br>运行该软件后，首先需要创建一个存储所有证书的数据库，选择如下所示</p>
<p><img src="01.png" alt="创建数据库"></p>
<p>会提示输入存储路径和文件名，然后再输入数据库的 <code>访问密码</code>，点击OK创建完毕。<br>我们首先创建一个私钥，在 <code>Private Keys</code> 选项卡页面，点击 <code>New Key</code> 按钮</p>
<p><img src="02.png" alt="创建私钥"></p>
<p>在 <code>Name</code> 栏输入名称，类型 <code>Keytype</code> 默认选择 <code>RSA</code>，长度 <code>Keysize</code> 默认选择<code>2048 bit</code>，<br>点击 <code>Create</code> 按钮创建私钥</p>
<p><img src="03.png" alt="私钥信息"></p>
<p>然后准备创建证书，在 <code>Certificates</code> 选项卡窗口，点击 <code>New Certificate</code> 按钮</p>
<p><img src="04.png" alt="创建证书"></p>
<p>在 <code>Source</code> 选项卡的最下边，选择新证书的模板，这里选择 <code>CA</code> 模板，点击 <code>Apply all</code> 按钮</p>
<p><img src="05.png" alt="新证书模板"></p>
<p>在 <code>Subject</code> 选项卡窗口，输入 <code>Distinguished name</code> 的相关信息， 并在最下边选择私钥</p>
<table>
<thead>
<tr>
<th>缩写</th>
<th>字段</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>C</td>
<td>countryName</td>
<td>国家名称，中国就是CN，非必填项</td>
</tr>
<tr>
<td>S</td>
<td>stateOrProvinceName</td>
<td>洲或省名称，非必填项</td>
</tr>
<tr>
<td>L</td>
<td>localityName</td>
<td>地区名称，非必填项</td>
</tr>
<tr>
<td>O</td>
<td>organizationName</td>
<td>组织名称，非必填项</td>
</tr>
<tr>
<td>CN</td>
<td>commonName</td>
<td>公用名，授权的目标，必填项</td>
</tr>
</tbody></table>
<p><img src="06.png" alt="新证书信息"></p>
<p>在 <code>Extensions</code> 选项卡窗口，可以查看扩展信息，在选择模板并应用后，这里会自动完成设置，<br>如果与下图不一致，则说明模板未操作成功，另外可以在 <code>Time range</code> 修改授权的有效期限</p>
<p><img src="07.png" alt="扩展信息"></p>
<p>在 <code>Key usage</code> 选项卡窗口，可以查看该证书的授权范围，左边一栏在选择 <code>CA</code> 模板后默认为<br> <code>Certificate Sign</code> <code>CRL Sign</code> 两项，勾选上左边的 <code>Critical</code> 标识，点击OK按钮完成创建</p>
<p><img src="08.png" alt="证书权限"></p>
<p>如果想使用该证书进行 <code>数字签名</code>，可以在左边选上第1行的 <code>Digital Signature</code> 授权，同时<br>右边选上第3行的 <code>Code Signing</code> 授权，右边的 <code>Critical</code> 标识也要勾选上</p>
<p><img src="09.png" alt="数字签名"></p>
<h4 id="生成SSL证书"><a href="#生成SSL证书" class="headerlink" title="生成SSL证书"></a>生成SSL证书</h4><p>首选需要创建一个私钥，然后创建证书时，选择 <code>HTTPS_server</code> 模板，使用 <code>Root CA</code> 进行签名</p>
<p><img src="10.png" alt="模板选择"></p>
<p>在 <code>Subject</code> 选项卡窗口，选择新建的私钥，并在 <code>commonName</code> 处填写授权的 <code>网址域名</code></p>
<p><img src="11.png" alt="证书信息"></p>
<p>在 <code>Extensions</code> 选项卡窗口，注意在 <code>Subject Alternative Name</code> 处，修改为授权的域名，<br>多个域名使用逗号隔开，例如：<code>DNS:*.shuiniu.com, DNS:*.shuiniu.cn</code></p>
<p><img src="12.png" alt="扩展信息"></p>
<p>在 <code>Key usage</code> 选项卡窗口，按照如下所示进行选择，点击OK按钮完成创建</p>
<p><img src="13.png" alt="授权信息"></p>
<h4 id="添加授权条目"><a href="#添加授权条目" class="headerlink" title="添加授权条目"></a>添加授权条目</h4><p>另外还可以添加自定义的授权条目，比如 <code>Windows应用商店(1.3.6.1.4.1.311.76.3.1)</code> 授权条目，<br>在软件的安装目录下，可以找到 <code>oids.txt</code> 和 <code>eku.txt</code> 两个文件，复制到 <code>settings</code> 子文件夹下，<br>在 <code>oids.txt</code> 最后一行增加 <code>1.3.6.1.4.1.311.76.3.1: windows-store: Windows Store Signer</code><br>内容，在 <code>eku.txt</code> 最后一行增加 <code>windows-store</code> 内容，重新打开软件后，就可以选择该授权条目</p>
<h4 id="证书的导出"><a href="#证书的导出" class="headerlink" title="证书的导出"></a>证书的导出</h4><p>在 <code>Certificates</code> 选项卡界面，选择想要导出的证书，点击 <code>Export</code> 按钮</p>
<p><img src="14.png" alt="导出证书"></p>
<p>输入导出文件的路径，选择 <code>.p12</code> 格式，可以把证书和私钥一起导出，点击OK按钮后，<br>会提示输入该证书的访问密码，再次点击OK之后导出完成。</p>
<p><img src="15.png" alt="选择格式"></p>
<p>证书 <code>.p12</code> 格式与 <code>.pfx</code> 格式一样，通常情况下可以直接修改扩展名使用。</p>
]]></content>
      <categories>
        <category>数字签名</category>
      </categories>
      <tags>
        <tag>数字签名</tag>
      </tags>
  </entry>
  <entry>
    <title>在内核驱动中验证签名算法(1)</title>
    <url>/2020/09/27/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/%E5%9C%A8%E5%86%85%E6%A0%B8%E9%A9%B1%E5%8A%A8%E4%B8%AD%E9%AA%8C%E8%AF%81%E7%AD%BE%E5%90%8D%E7%AE%97%E6%B3%95-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>这里在内核中验证签名含有两层意义，一个是验证PE文件的数字签名，另一个是验证当前正在跟驱动<br>通讯的进程，是否是被允许的进程，这就需要我们自定义一段信息，嵌入到PE文件中作为验证信息</p>
<h4 id="自定义签名"><a href="#自定义签名" class="headerlink" title="自定义签名"></a>自定义签名</h4><p>自定义签名实际操作，就是在应用程序中增加一个数据段，存储对PE文件做的签名校验码和标志等，<br>这些信息使用RSA算法的私钥进行加密，最后在驱动中使用对应公钥进行解密校验。</p>
<p>一般常见的 <code>CryptoAPI</code> 函数并不能在驱动中使用，所以我们使用 <code>bcrypt.h</code> 包含的<code>BCrypt*</code> 系列<br>功能，在应用层使用 <code>bcrypt.lib</code> 库，在驱动层使用 <code>ksecdd.lib</code> 库，调用的API名称都相同。</p>
<h5 id="使用SHA1计算信息的hash值"><a href="#使用SHA1计算信息的hash值" class="headerlink" title="使用SHA1计算信息的hash值"></a>使用SHA1计算信息的hash值</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bcrypt.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHA1_HASH_SIZE 20</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">HashDataSHA1</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PUCHAR InBuffer, IN ULONG InSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PUCHAR OutBuffer, IN ULONG OutSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    UCHAR HashResult[SHA1_HASH_SIZE];</span><br><span class="line">    BCRYPT_ALG_HANDLE AlgHandle;</span><br><span class="line">    BCRYPT_HASH_HANDLE HashHandle;</span><br><span class="line">    <span class="comment">// 可以使用BCryptGetProperty(BCRYPT_HASH_LENGTH)获取算法结果的长度</span></span><br><span class="line">    <span class="keyword">if</span> (!InBuffer || !InSize || !OutBuffer || (OutSize &lt; SHA1_HASH_SIZE)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 使用SHA1算法</span></span><br><span class="line">    Status = BCryptOpenAlgorithmProvider(&amp;AlgHandle, BCRYPT_SHA1_ALGORITHM, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BCRYPT_SUCCESS(Status)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 创建HASH句柄</span></span><br><span class="line">    Status = BCryptCreateHash(AlgHandle, &amp;HashHandle, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BCRYPT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        BCryptCloseAlgorithmProvider(AlgHandle, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 开始HASH数据</span></span><br><span class="line">    Status = BCryptHashData(HashHandle, InBuffer, InSize, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BCRYPT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        BCryptDestroyHash(HashHandle);</span><br><span class="line">        BCryptCloseAlgorithmProvider(AlgHandle, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到HASH结果</span></span><br><span class="line">    Status = BCryptFinishHash(HashHandle, HashResult, SHA1_HASH_SIZE, <span class="number">0</span>);</span><br><span class="line">    BCryptDestroyHash(HashHandle);</span><br><span class="line">    BCryptCloseAlgorithmProvider(AlgHandle, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BCRYPT_SUCCESS(Status)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 复制到输出</span></span><br><span class="line">    memmove(OutBuffer, HashResult, SHA1_HASH_SIZE);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="生成RSA的512位密钥对"><a href="#生成RSA的512位密钥对" class="headerlink" title="生成RSA的512位密钥对"></a>生成RSA的512位密钥对</h5><p>注意RSA公钥和私钥的长度并不相等，出于安全考虑应该使用2048位的，这里只用于例子</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RSA512_SIGN_SIZE 64</span></span><br><span class="line"><span class="function">BOOLEAN <span class="title">MakeKeyRSA512</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PUCHAR PublicBuffer, IN ULONG PublicSize, OUT PULONG PublicReal,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PUCHAR PrivateBuffer, IN ULONG PrivateSize, OUT PULONG PrivateReal)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    BCRYPT_ALG_HANDLE AlgHandle;</span><br><span class="line">    BCRYPT_KEY_HANDLE KeyHandle;</span><br><span class="line">    <span class="comment">// 检查参数的有效性</span></span><br><span class="line">    <span class="keyword">if</span> (!PublicBuffer || (PublicSize &lt; <span class="number">91</span>) || !PublicReal ||</span><br><span class="line">        !PrivateBuffer || (PrivateSize &lt; <span class="number">155</span>) || !PrivateReal) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 使用RSA算法</span></span><br><span class="line">    Status = BCryptOpenAlgorithmProvider(&amp;AlgHandle, BCRYPT_RSA_ALGORITHM, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BCRYPT_SUCCESS(Status)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 创建空的密钥对</span></span><br><span class="line">    Status = BCryptGenerateKeyPair(AlgHandle, &amp;KeyHandle, RSA512_SIGN_SIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BCRYPT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        BCryptCloseAlgorithmProvider(AlgHandle, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成密钥对</span></span><br><span class="line">    Status = BCryptFinalizeKeyPair(KeyHandle, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BCRYPT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        BCryptDestroyKey(KeyHandle);</span><br><span class="line">        BCryptCloseAlgorithmProvider(AlgHandle, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 导出公钥</span></span><br><span class="line">    Status = BCryptExportKey(KeyHandle, <span class="literal">NULL</span>,</span><br><span class="line">        BCRYPT_RSAPUBLIC_BLOB, PublicBuffer, PublicSize, PublicReal, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BCRYPT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        BCryptDestroyKey(KeyHandle);</span><br><span class="line">        BCryptCloseAlgorithmProvider(AlgHandle, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 导出私钥</span></span><br><span class="line">    Status = BCryptExportKey(KeyHandle, <span class="literal">NULL</span>,</span><br><span class="line">        BCRYPT_RSAPRIVATE_BLOB, PrivateBuffer, PrivateSize, PrivateReal, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BCRYPT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        BCryptDestroyKey(KeyHandle);</span><br><span class="line">        BCryptCloseAlgorithmProvider(AlgHandle, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    BCryptDestroyKey(KeyHandle);</span><br><span class="line">    BCryptCloseAlgorithmProvider(AlgHandle, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用私钥给hash签名"><a href="#使用私钥给hash签名" class="headerlink" title="使用私钥给hash签名"></a>使用私钥给hash签名</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">SignHashRSA512</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PUCHAR PrivateBuffer, IN ULONG PrivateSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PUCHAR HashBuffer, IN ULONG HashSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    OUT PUCHAR SignBuffer, IN ULONG SignSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    ULONG ResultSize;</span><br><span class="line">    BCRYPT_ALG_HANDLE AlgHandle;</span><br><span class="line">    BCRYPT_KEY_HANDLE KeyHandle;</span><br><span class="line">    BCRYPT_PKCS1_PADDING_INFO PadInfo;</span><br><span class="line">    <span class="comment">// 检查参数的有效性</span></span><br><span class="line">    <span class="keyword">if</span> (!HashBuffer || !HashSize || (HashSize &gt; (RSA512_SIGN_SIZE - <span class="number">12</span>)) ||</span><br><span class="line">        !SignBuffer || (SignSize &lt; RSA512_SIGN_SIZE)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 使用RSA算法</span></span><br><span class="line">    Status = BCryptOpenAlgorithmProvider(&amp;AlgHandle, BCRYPT_RSA_ALGORITHM, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BCRYPT_SUCCESS(Status)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 导入RSA私钥</span></span><br><span class="line">    Status = BCryptImportKeyPair(AlgHandle, <span class="literal">NULL</span>,</span><br><span class="line">        BCRYPT_RSAPRIVATE_BLOB, &amp;KeyHandle, PrivateBuffer, PrivateSize, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BCRYPT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        BCryptCloseAlgorithmProvider(AlgHandle, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取计算的结果</span></span><br><span class="line">    PadInfo.pszAlgId = BCRYPT_SHA1_ALGORITHM;</span><br><span class="line">    Status = BCryptSignHash(KeyHandle, &amp;PadInfo,</span><br><span class="line">        HashBuffer, HashSize, SignBuffer, SignSize, &amp;ResultSize, BCRYPT_PAD_PKCS1);</span><br><span class="line">    <span class="keyword">if</span> (!BCRYPT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        BCryptDestroyKey(KeyHandle);</span><br><span class="line">        BCryptCloseAlgorithmProvider(AlgHandle, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    BCryptDestroyKey(KeyHandle);</span><br><span class="line">    BCryptCloseAlgorithmProvider(AlgHandle, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用公钥验证hash的签名"><a href="#使用公钥验证hash的签名" class="headerlink" title="使用公钥验证hash的签名"></a>使用公钥验证hash的签名</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">VerifyHashRSA512</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PUCHAR PublicBuffer, IN ULONG PublicSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PUCHAR HashBuffer, IN ULONG HashSize,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN PUCHAR SignBuffer, IN ULONG SignSize)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    BCRYPT_ALG_HANDLE AlgHandle;</span><br><span class="line">    BCRYPT_KEY_HANDLE KeyHandle;</span><br><span class="line">    BCRYPT_PKCS1_PADDING_INFO PadInfo;</span><br><span class="line">    <span class="comment">// 检查参数的有效性</span></span><br><span class="line">    <span class="keyword">if</span> (!HashBuffer || !HashSize || (HashSize &gt; (RSA512_SIGN_SIZE - <span class="number">12</span>)) ||</span><br><span class="line">        !SignBuffer || (SignSize != RSA512_SIGN_SIZE)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 使用RSA算法</span></span><br><span class="line">    Status = BCryptOpenAlgorithmProvider(&amp;AlgHandle, BCRYPT_RSA_ALGORITHM, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BCRYPT_SUCCESS(Status)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 导入RSA公钥</span></span><br><span class="line">    Status = BCryptImportKeyPair(AlgHandle, <span class="literal">NULL</span>,</span><br><span class="line">        BCRYPT_RSAPUBLIC_BLOB, &amp;KeyHandle, PublicBuffer, PublicSize, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!BCRYPT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        BCryptCloseAlgorithmProvider(AlgHandle, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 验证信息是否正确</span></span><br><span class="line">    PadInfo.pszAlgId = BCRYPT_SHA1_ALGORITHM;</span><br><span class="line">    Status = BCryptVerifySignature(KeyHandle, &amp;PadInfo,</span><br><span class="line">        HashBuffer, HashSize, SignBuffer, SignSize, BCRYPT_PAD_PKCS1);</span><br><span class="line">    <span class="keyword">if</span> (!BCRYPT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        BCryptDestroyKey(KeyHandle);</span><br><span class="line">        BCryptCloseAlgorithmProvider(AlgHandle, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    BCryptDestroyKey(KeyHandle);</span><br><span class="line">    BCryptCloseAlgorithmProvider(AlgHandle, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="调用示例main函数"><a href="#调用示例main函数" class="headerlink" title="调用示例main函数"></a>调用示例main函数</h5><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UCHAR PublicKey[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UCHAR PrivateKey[<span class="number">256</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UCHAR DataBuffer[] = <span class="string">&quot;Hello World&quot;</span>;</span><br><span class="line">    UCHAR HashBuffer[SHA1_HASH_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UCHAR SignBuffer[RSA512_SIGN_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    ULONG SignReal = <span class="number">0</span>;</span><br><span class="line">    ULONG PublicReal = <span class="number">0</span>;</span><br><span class="line">    ULONG PrivateReal = <span class="number">0</span>;</span><br><span class="line">    MakeKeyRSA512(PublicKey, <span class="number">256</span>, &amp;PublicReal, PrivateKey, <span class="number">256</span>, &amp;PrivateReal);</span><br><span class="line">    HashDataSHA1(DataBuffer, <span class="keyword">sizeof</span>(DataBuffer), HashBuffer, SHA1_HASH_SIZE);</span><br><span class="line">    SignHashRSA512(PrivateKey, PrivateReal, HashBuffer, SHA1_HASH_SIZE, SignBuffer, RSA512_SIGN_SIZE);</span><br><span class="line">    VerifyHashRSA512(PublicKey, PublicReal, HashBuffer, SHA1_HASH_SIZE, SignBuffer, RSA512_SIGN_SIZE);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数字签名</category>
      </categories>
      <tags>
        <tag>数字签名</tag>
      </tags>
  </entry>
  <entry>
    <title>模式匹配Brute-Force算法(1)</title>
    <url>/2022/10/25/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8DBrute-Force%E7%AE%97%E6%B3%95-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Brute-Force算法又称暴力匹配算法、朴素匹配算法。<br>基本原理就是：从文本串的每个字符开始依次与模式串进行匹配。<br>设文本串长度为n，模式串长度为m，时间复杂度就是O(n*m)。</p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>如下为匹配单字节字符示例，而匹配宽字符时，仅函数声明不同</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">BruteForceSearchA</span><span class="params">(<span class="keyword">char</span>* txt, <span class="keyword">int</span> tn, <span class="keyword">char</span>* pat, <span class="keyword">short</span> pn)</span></span></span><br><span class="line"><span class="function"><span class="comment">//wchar_t* BruteForceSearchW(wchar_t* txt, int tn, wchar_t* pat, short pn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!txt || !pat || (pn &lt;= <span class="number">0</span>) || (pn &gt; tn)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (tn - pn); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">short</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pn; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pat[j] != txt[i + j]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == pn) <span class="keyword">return</span> (txt + i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索字节码示例（带通配符0xCC）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="title">PatternSearchByte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* dat, <span class="keyword">int</span> dn, <span class="keyword">unsigned</span> <span class="keyword">char</span>* pat, <span class="keyword">short</span> pn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dat || !pat || (pn &lt;= <span class="number">0</span>) || (pn &gt; dn)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= (dn - pn); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">short</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pn; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> ((pat[j] != dat[i + j]) &amp;&amp; (pat[j] != <span class="number">0xCC</span>)) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == pn) <span class="keyword">return</span> (dat + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (<span class="number">1</span>) <span class="comment">// EXCEPTION_EXECUTE_HANDLER</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>算法相关</tag>
      </tags>
  </entry>
  <entry>
    <title>模式匹配Sunday算法(1)</title>
    <url>/2022/10/27/%E7%AE%97%E6%B3%95%E7%9B%B8%E5%85%B3/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8DSunday%E7%AE%97%E6%B3%95-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Sunday算法是Boyer-Moore算法的改进，效率有略微的提升：<br>在匹配失败时，处理文本串中参加匹配的最末位字符的下一位字符；<br>如果该字符没有在模式串中出现，则直接跳过，即右移位数=匹配串长度+1；<br>如果该字符在模式串中出现过，则右移位数=模式串中最右端的该字符到末尾的距离+1；<br>平均性能的时间复杂度为O(n)，最差情况的时间复杂度为O(n*m)。</p>
<h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p>如下为匹配单字节字符示例，而匹配宽字符时，除函数声明外还有字符集大小不同</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">SundaySearchA</span><span class="params">(<span class="keyword">char</span>* txt, <span class="keyword">int</span> tn, <span class="keyword">char</span>* pat, <span class="keyword">short</span> pn)</span></span></span><br><span class="line"><span class="function"><span class="comment">//wchar_t* SundaySearchW(wchar_t* txt, int tn, wchar_t* pat, short pn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!txt || !pat || (pn &lt;= <span class="number">0</span>) || (pn &gt; tn)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> shift_size = <span class="number">0x100</span>; <span class="comment">// 单字节字符集大小</span></span><br><span class="line">    <span class="comment">//const int shift_size = 0x10000; // 宽字符集大小</span></span><br><span class="line">    <span class="keyword">int</span>* shift = <span class="keyword">new</span> <span class="keyword">int</span>[shift_size];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shift_size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        shift[i] = pn + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">short</span> i = <span class="number">0</span>; i &lt; pn; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        shift[pat[i]] = pn - i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (tn - pn); i += shift[txt[i + pn]])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">short</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pn; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (pat[j] != txt[i + j]) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == pn)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span>[] shift;</span><br><span class="line">            <span class="keyword">return</span> (txt + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] shift;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索字节码示例（暂不支持通配符）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">char</span>* <span class="title">SundaySearchByte</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* dat, <span class="keyword">int</span> dn, <span class="keyword">unsigned</span> <span class="keyword">char</span>* pat, <span class="keyword">short</span> pn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dat || !pat || (pn &lt;= <span class="number">0</span>) || (pn &gt; dn)) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> shift_size = <span class="number">0x100</span>; <span class="comment">// 单字节集大小</span></span><br><span class="line">    <span class="keyword">int</span>* shift = <span class="keyword">new</span> <span class="keyword">int</span>[shift_size];</span><br><span class="line">    __try</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shift_size; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            shift[i] = pn + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">short</span> i = <span class="number">0</span>; i &lt; pn; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            shift[pat[i]] = pn - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (dn - pn); i += shift[dat[i + pn]])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">short</span> j;</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; pn; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (pat[j] != dat[i + j]) <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == pn)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">delete</span>[] shift;</span><br><span class="line">                <span class="keyword">return</span> (dat + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    __except (<span class="number">1</span>) <span class="comment">// EXCEPTION_EXECUTE_HANDLER</span></span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span>[] shift;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>算法相关</category>
      </categories>
      <tags>
        <tag>算法相关</tag>
      </tags>
  </entry>
  <entry>
    <title>使用IPFilter实现数据包过滤(1)</title>
    <url>/2019/07/18/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E4%BD%BF%E7%94%A8IPFilter%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8C%85%E8%BF%87%E6%BB%A4-1/</url>
    <content><![CDATA[<h4 id="各种方案简介"><a href="#各种方案简介" class="headerlink" title="各种方案简介"></a>各种方案简介</h4><p>在XP系统下，实现网络过滤可以使用 <code>TDI</code> <code>IPHOOK</code> <code>NDIS5</code> 几种方案。<br>其中 <code>TDI</code> 过滤可以获取到IP数据包与进程之间的关系，而 <code>IPHOOK</code> 和 <code>NDIS5</code> 两种无法获知进程名。<br>在 <code>NDIS5</code> 中，因为是最底层，可以抓取到所有类型的数据包，前边两种只能抓取IP数据包。</p>
<p>在VISTA及以上的系统中，实现网络过滤可以使用 <code>WFP</code> <code>NDIS6</code> 几种方案，虽然 <code>TDI</code> 和 <code>NDIS5</code> 仍然<br>有效，但是微软已经不提倡再使用。其中 <code>WFP</code> 过滤对 <code>TDI</code> 进行了封装，可以获取到IP数据包与进程<br>之间的关系。<code>NDIS6</code> 对 <code>NDIS5</code> 进行了封装，可以抓取到所有类型的数据包。</p>
<p>以上几种方案中，以 <code>NDIS</code> 难度和复杂度最高，因为所有的细节操作，都需要自行处理，比如自行组装<br>数据包，自行进行转发数据。所以只要有一个处理不当，就会导致所有用 <code>NDIS</code> 的同类程序受到影响。</p>
<h4 id="IPHOOK框架使用"><a href="#IPHOOK框架使用" class="headerlink" title="IPHOOK框架使用"></a>IPHOOK框架使用</h4><p>这是最简单的框架，所有相关信息在 <code>pfhook.h</code> 头文件中定义，向 <code>&quot;\\Device\\IPFILTERDRIVER&quot;</code> 设备<br>发送 <code>IOCTL_PF_SET_EXTENSION_POINTER</code> 控制码来进行注册，其输入参数为处理过滤数据的回调函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">PF_FORWARD_ACTION</span> <span class="params">(*PacketFilterExtensionPtr)</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN <span class="keyword">unsigned</span> <span class="keyword">char</span> *PacketHeader,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN <span class="keyword">unsigned</span> <span class="keyword">char</span> *Packet, </span></span></span><br><span class="line"><span class="function"><span class="params">    IN <span class="keyword">unsigned</span> <span class="keyword">int</span>  PacketLength, </span></span></span><br><span class="line"><span class="function"><span class="params">    IN <span class="keyword">unsigned</span> <span class="keyword">int</span>  RecvInterfaceIndex, </span></span></span><br><span class="line"><span class="function"><span class="params">    IN <span class="keyword">unsigned</span> <span class="keyword">int</span>  SendInterfaceIndex, </span></span></span><br><span class="line"><span class="function"><span class="params">    IN IPAddr        RecvLinkNextHop, </span></span></span><br><span class="line"><span class="function"><span class="params">    IN IPAddr        SendLinkNextHop)</span></span>; </span><br></pre></td></tr></table></figure>

<p>以下为注册<code>IPHOOK</code>框架的代码，注意由于只能存在一个过滤函数，所以需要先设置过滤函数为 <code>NULL</code> 进行<br>清除操作，然后再注册我们的过滤函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SetFilterFunction</span><span class="params">(PacketFilterExtensionPtr FilterFun)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIRP pIrp = <span class="literal">NULL</span>;</span><br><span class="line">    KEVENT Event = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    IO_STATUS_BLOCK IoStatus = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PFILE_OBJECT FileObject = <span class="literal">NULL</span>;</span><br><span class="line">    PDEVICE_OBJECT DeviceObject = <span class="literal">NULL</span>;</span><br><span class="line">    PF_SET_EXTENSION_HOOK_INFO HookInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    UNICODE_STRING IpFilterDriver = RTL_CONSTANT_STRING(<span class="string">L&quot;\\Device\\IPFILTERDRIVER&quot;</span>);</span><br><span class="line">    <span class="comment">// 获取IP过滤设备对象</span></span><br><span class="line">    Status = IoGetDeviceObjectPointer(</span><br><span class="line">        &amp;IpFilterDriver, FILE_ALL_ACCESS, &amp;FileObject, &amp;DeviceObject);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建IRP请求</span></span><br><span class="line">    HookInfo.ExtensionPointer = FilterFun;</span><br><span class="line">    KeInitializeEvent(&amp;Event, NotificationEvent, FALSE);</span><br><span class="line">    pIrp = IoBuildDeviceIoControlRequest(</span><br><span class="line">        IOCTL_PF_SET_EXTENSION_POINTER, DeviceObject,</span><br><span class="line">        (PVOID)&amp;HookInfo, <span class="keyword">sizeof</span>(PF_SET_EXTENSION_HOOK_INFO),</span><br><span class="line">        <span class="literal">NULL</span>, <span class="number">0</span>, FALSE, &amp;Event, &amp;IoStatus);</span><br><span class="line">    <span class="keyword">if</span> (pIrp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ObDereferenceObject(FileObject);</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送此IRP到IP过滤驱动</span></span><br><span class="line">    Status = IoCallDriver(DeviceObject, pIrp);</span><br><span class="line">    <span class="keyword">if</span> (Status == STATUS_PENDING)</span><br><span class="line">    &#123;</span><br><span class="line">        KeWaitForSingleObject(&amp;Event, Executive, KernelMode, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ObDereferenceObject(FileObject);</span><br><span class="line">    <span class="keyword">return</span> IoStatus.Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下为处理过滤数据回调函数的代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PF_FORWARD_ACTION <span class="title">FilterPackets</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *PacketHeader,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">char</span> *Packet,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  PacketLength,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  RecvInterfaceIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="keyword">unsigned</span> <span class="keyword">int</span>  SendInterfaceIndex,</span></span></span><br><span class="line"><span class="function"><span class="params">    IPAddr        RecvLinkNextHop,</span></span></span><br><span class="line"><span class="function"><span class="params">    IPAddr        SendLinkNextHop)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 相关数据结构体指针</span></span><br><span class="line">    PIP_HEADER pIpHeader = (PIP_HEADER)PacketHeader;</span><br><span class="line">    PTCP_HEADER pTcpHeader = (PTCP_HEADER)Packet;</span><br><span class="line">    PUDP_HEADER pUdpHeader = (PUDP_HEADER)Packet;</span><br><span class="line">    PKGFLT_STATUS fStatus = STATUS_PASS;</span><br><span class="line">    UNREFERENCED_PARAMETER(PacketLength);</span><br><span class="line">    UNREFERENCED_PARAMETER(RecvLinkNextHop);</span><br><span class="line">    UNREFERENCED_PARAMETER(SendLinkNextHop);</span><br><span class="line">    <span class="keyword">if</span> (PacketHeader == <span class="literal">NULL</span>) <span class="keyword">return</span> PF_FORWARD;</span><br><span class="line">    <span class="comment">// 接收无效的时候表示发包</span></span><br><span class="line">    (RecvInterfaceIndex == INVALID_PF_IF_INDEX);</span><br><span class="line">    <span class="comment">// 发送无效的时候表示收包</span></span><br><span class="line">    (SendInterfaceIndex == INVALID_PF_IF_INDEX);</span><br><span class="line">    <span class="comment">// 检测是否拦截数据包</span></span><br><span class="line">    <span class="keyword">if</span> (fStatus == STATUS_DROP) <span class="keyword">return</span> PF_DROP;</span><br><span class="line">    <span class="keyword">return</span> PF_FORWARD;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为全都是已经组装好的数据，不需要额外的再做其他处理，所以稳定性极高。</p>
<h4 id="防火墙策略的设计"><a href="#防火墙策略的设计" class="headerlink" title="防火墙策略的设计"></a>防火墙策略的设计</h4><p>除了数据包信息的处理，我们还需要配置用以拦截数据包的策略。<br>防火墙策略包含 <code>规则</code> <code>协议</code> <code>源IP</code> <code>源端口</code> <code>目的IP</code> <code>目的端口</code> <code>进程名</code> 几项基本配置，<br>更复杂的策略可以进行深层协议识别，比如 <code>DNS</code> <code>HTTP</code> <code>SSL</code> 等，甚至对 <code>数据关键字</code> 进行过滤。</p>
<p>以 <code>IPHOOK</code> 为基础，我们设计的策略如下</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>Rule</td>
<td>规则</td>
<td>0（放行）1（拦截）</td>
</tr>
<tr>
<td>Protocol</td>
<td>协议</td>
<td>0（ANY）1（ICMP）6（TCP）17（UDP）</td>
</tr>
<tr>
<td>SourceIP</td>
<td>源IP段</td>
<td>192.168.3.100-192.168.3.120</td>
</tr>
<tr>
<td>SourcePort</td>
<td>源端口段</td>
<td>30500-30540</td>
</tr>
<tr>
<td>DestIP</td>
<td>目的IP段</td>
<td>192.168.1.55-192.168.1.90</td>
</tr>
<tr>
<td>DestPort</td>
<td>目的端口段</td>
<td>5000-5080</td>
</tr>
</tbody></table>
<p>发给驱动要先进行数据处理，取值为区间的参数，拆分为为 <code>Begin</code> 和 <code>End</code> 两个数据，并转换字符为整数，<br>为了方便进行策略比对，要先用 <code>ntohl</code> 和 <code>ntohs</code> 转换IP和端口的数据为 <code>host</code> 类型，结构体定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">POLICY_INFO</span> &#123;</span></span><br><span class="line">    UCHAR Rule;          <span class="comment">// 规则 0:允许 1:阻止</span></span><br><span class="line">    UCHAR Protocol;      <span class="comment">// 协议 0:任何 1:ICMP 6:TCP 17:UDP</span></span><br><span class="line">    UINT32 SrcIPBegin;   <span class="comment">// 源起始IP</span></span><br><span class="line">    UINT32 SrcIPEnd;     <span class="comment">// 源终止IP</span></span><br><span class="line">    USHORT SrcPortBegin; <span class="comment">// 源起始Port</span></span><br><span class="line">    USHORT SrcPortEnd;   <span class="comment">// 源终止Port</span></span><br><span class="line">    UINT32 DstIPBegin;   <span class="comment">// 目的起始IP</span></span><br><span class="line">    UINT32 DstIPEnd;     <span class="comment">// 目的终止IP</span></span><br><span class="line">    USHORT DstPortBegin; <span class="comment">// 目的起始Port</span></span><br><span class="line">    USHORT DstPortEnd;   <span class="comment">// 目的终止Port</span></span><br><span class="line">&#125; POLICY_INFO, *PPOLICY_INFO;</span><br></pre></td></tr></table></figure>

<p>多个策略之间的协同处理，采用自上而下的方式，依照发送到驱动的先后顺序进行匹配，始终以靠后的策略<br>的匹配结果为结果，比如同时满足两条策略，前边的结果是拦截，后边的结果是放行，最终结果是放行。</p>
]]></content>
      <categories>
        <category>网络相关</category>
      </categories>
      <tags>
        <tag>网络相关</tag>
      </tags>
  </entry>
  <entry>
    <title>使用NDIS5.1实现数据包过滤(3)</title>
    <url>/2019/12/13/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E4%BD%BF%E7%94%A8NDIS5.1%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8C%85%E8%BF%87%E6%BB%A4-3/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在XP中可以使用 <code>NDIS5</code> 做网络过滤，在《WINDOWS内核安全与驱动开发》一书中，<br>对 <code>NDIS5</code> 做了非常详尽的解释，这里就不再做原理性的探讨，只处理具体的应用方法。<br>整体框架采用WDK源码中 <code>src -&gt; network -&gt; ndis -&gt; passthru</code> 工程作为基础。</p>
<h4 id="修改passthru-c文件"><a href="#修改passthru-c文件" class="headerlink" title="修改passthru.c文件"></a>修改passthru.c文件</h4><p>如下 <code>宏定义</code> 为与应用层通讯的 <code>控制设备</code> 的名称，这里修改为其他需要的名称</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINKNAME_STRING     <span class="meta-string">L&quot;\\DosDevices\\Passthru&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTDEVICE_STRING     <span class="meta-string">L&quot;\\Device\\Passthru&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>在 <code>DriverEntry</code> 函数中，如下为 <code>协议名称</code> 的定义，这里也要修改为其他需要的名称</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NdisInitUnicodeString(&amp;Name, <span class="string">L&quot;Passthru&quot;</span>);    <span class="comment">// 协议名称</span></span><br><span class="line">PChars.Name = Name;</span><br></pre></td></tr></table></figure>

<p>在 <code>PtDispatch</code> 函数中，如下为 <code>控制码</code> 的处理，这里可以添加自定义的控制码处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (irpStack-&gt;MajorFunction)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> IRP_MJ_CREATE:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRP_MJ_CLEANUP:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRP_MJ_CLOSE:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IRP_MJ_DEVICE_CONTROL:</span><br><span class="line">        <span class="comment">// 这里添加自定义的控制码处理</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改miniport-c文件"><a href="#修改miniport-c文件" class="headerlink" title="修改miniport.c文件"></a>修改miniport.c文件</h4><p>在 <code>MPSend</code> 函数开始的位置，判断完设备状态后，调用我们的数据包解析函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pAdapt-&gt;MPDeviceState &gt; NdisDeviceStateD0)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> NDIS_STATUS_FAILURE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组合数据包并进行分析</span></span><br><span class="line">fStatus = AnalysisPacket(Packet, FALSE);</span><br><span class="line"><span class="keyword">if</span> (fStatus == STATUS_DROP)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> NDIS_STATUS_FAILURE; <span class="comment">// 丢弃包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>MPSendPackets</code> 函数开始的for循环体中，判断完设备状态后，调用我们的数据包解析函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (pAdapt-&gt;MPDeviceState &gt; NdisDeviceStateD0)</span><br><span class="line">&#123;</span><br><span class="line">    NdisMSendComplete(ADAPT_MINIPORT_HANDLE(pAdapt),</span><br><span class="line">        Packet,</span><br><span class="line">        NDIS_STATUS_FAILURE);</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组合数据包并进行分析</span></span><br><span class="line">fStatus = AnalysisPacket(Packet, FALSE);</span><br><span class="line"><span class="keyword">if</span> (fStatus == STATUS_DROP)</span><br><span class="line">&#123;</span><br><span class="line">    NdisMSendComplete(ADAPT_MINIPORT_HANDLE(pAdapt),</span><br><span class="line">        Packet,</span><br><span class="line">        NDIS_STATUS_FAILURE);</span><br><span class="line">    <span class="keyword">continue</span>; <span class="comment">// 丢弃包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>MPTransferData</code> 函数中，调用 <code>NdisTransferData</code> 成功后，调用我们的数据包解析函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NdisTransferData(&amp;Status,</span><br><span class="line">    pAdapt-&gt;BindingHandle,</span><br><span class="line">    MiniportReceiveContext,</span><br><span class="line">    ByteOffset,</span><br><span class="line">    BytesToTransfer,</span><br><span class="line">    Packet,</span><br><span class="line">    BytesTransferred);</span><br><span class="line"><span class="keyword">if</span> (Status == NDIS_STATUS_SUCCESS)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 组合数据包并进行分析</span></span><br><span class="line">    fStatus = AnalysisPacket(Packet, TRUE);</span><br><span class="line">    <span class="keyword">if</span> (fStatus == STATUS_DROP)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = NDIS_STATUS_FAILURE; <span class="comment">// 丢弃包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改protocol-c文件"><a href="#修改protocol-c文件" class="headerlink" title="修改protocol.c文件"></a>修改protocol.c文件</h4><p>在 <code>PtTransferDataComplete</code> 函数的开始，定义变量以后，首先调用我们的数据包解析函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">PADAPT pAdapt = (PADAPT)ProtocolBindingContext;</span><br><span class="line">PKGFLT_STATUS fStatus;</span><br><span class="line"><span class="comment">// 组合数据包并进行分析</span></span><br><span class="line">fStatus = AnalysisPacket(Packet, TRUE);</span><br><span class="line"><span class="keyword">if</span> (fStatus == STATUS_DROP)</span><br><span class="line">&#123;</span><br><span class="line">    Status = NDIS_STATUS_FAILURE; <span class="comment">// 丢弃包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>PtReceive</code> 函数的开始，调用 <code>NdisGetReceivedPacket</code> 成功后，调用我们的数据包解析函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Packet = NdisGetReceivedPacket(pAdapt-&gt;BindingHandle, MacReceiveContext);</span><br><span class="line"><span class="keyword">if</span> (Packet != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 组合数据包并进行分析</span></span><br><span class="line">    fStatus = AnalysisPacket(Packet, TRUE);</span><br><span class="line">    <span class="keyword">if</span> (fStatus == STATUS_DROP)</span><br><span class="line">    &#123;</span><br><span class="line">        Status = NDIS_STATUS_FAILURE; <span class="comment">// 丢弃包</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>PtReceivePacket</code> 函数的开始，判断完设备状态后，调用我们的数据包解析函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> ((!pAdapt-&gt;MiniportHandle) || (pAdapt-&gt;MPDeviceState &gt; NdisDeviceStateD0))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组合数据包并进行分析</span></span><br><span class="line">fStatus = AnalysisPacket(Packet, TRUE);</span><br><span class="line"><span class="keyword">if</span> (fStatus == STATUS_DROP)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 丢弃包</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据包解析函数"><a href="#数据包解析函数" class="headerlink" title="数据包解析函数"></a>数据包解析函数</h4><p>数据包解析函数返回值的定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;</span><br><span class="line">    STATUS_PASS = <span class="number">0</span>,</span><br><span class="line">    STATUS_DROP = <span class="number">1</span></span><br><span class="line">&#125; PKGFLT_STATUS;</span><br></pre></td></tr></table></figure>

<p>如下为数据包解析函数，拿到以太网数据包后，可以根据相关规定进行格式解析</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PKGFLT_STATUS <span class="title">AnalysisPacket</span><span class="params">(PNDIS_PACKET Packet, BOOLEAN bRecv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;</span><br><span class="line">    PNDIS_BUFFER NdisBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    UINT32 TotalLength = <span class="number">0</span>;</span><br><span class="line">    UINT32 PhysicalCount = <span class="number">0</span>;</span><br><span class="line">    UINT32 BufferCount = <span class="number">0</span>;</span><br><span class="line">    PUCHAR PacketContent = <span class="literal">NULL</span>;</span><br><span class="line">    PUCHAR tempbuf = <span class="literal">NULL</span>;</span><br><span class="line">    UINT32 copysize = <span class="number">0</span>;</span><br><span class="line">    UINT32 DataOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查参数</span></span><br><span class="line">    <span class="keyword">if</span> (Packet == <span class="literal">NULL</span>) <span class="keyword">return</span> STATUS_PASS;</span><br><span class="line">    <span class="comment">// 查询第一个NDIS_BUFFER(MDL)</span></span><br><span class="line">    NdisQueryPacket(Packet, <span class="comment">// NDIS_PACKET</span></span><br><span class="line">        &amp;PhysicalCount,     <span class="comment">// 内存中的物理块数</span></span><br><span class="line">        &amp;BufferCount,       <span class="comment">// NDIS_BUFFER(MDL)个数</span></span><br><span class="line">        &amp;NdisBuffer,        <span class="comment">// 首个NDIS_BUFFER(MDL)</span></span><br><span class="line">        &amp;TotalLength);      <span class="comment">// 总共的数据长度</span></span><br><span class="line">    <span class="comment">// 申请组合包的内存</span></span><br><span class="line">    Status = NdisAllocateMemoryWithTag(&amp;PacketContent, TotalLength, &#x27;MEM&#x27;);</span><br><span class="line">    <span class="keyword">if</span> (Status != NDIS_STATUS_SUCCESS)</span><br><span class="line">        <span class="keyword">return</span> STATUS_PASS;</span><br><span class="line">    NdisZeroMemory(PacketContent, TotalLength);</span><br><span class="line">    <span class="comment">// 循环组合包</span></span><br><span class="line">    <span class="keyword">while</span> (NdisBuffer != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 取得NDIS_BUFFER(MDL)的缓存区地址</span></span><br><span class="line">        NdisQueryBufferSafe(NdisBuffer,</span><br><span class="line">            &amp;tempbuf,  <span class="comment">// 缓冲区地址</span></span><br><span class="line">            &amp;copysize, <span class="comment">// 缓冲区大小</span></span><br><span class="line">            NormalPagePriority);</span><br><span class="line">        <span class="comment">// 如果tempbuf为NULL，说明系统资源不足</span></span><br><span class="line">        <span class="keyword">if</span> (tempbuf == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            NdisFreeMemory(PacketContent, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> STATUS_PASS;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 组合包信息</span></span><br><span class="line">        NdisMoveMemory(PacketContent + DataOffset, tempbuf, copysize);</span><br><span class="line">        DataOffset += copysize;</span><br><span class="line">        <span class="comment">// 获得下一个NDIS_BUFFER</span></span><br><span class="line">        NdisGetNextBuffer(NdisBuffer, &amp;NdisBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到此PacketContent即为以太网数据包</span></span><br><span class="line">    <span class="comment">// 我们可以对数据包进行解析和处理</span></span><br><span class="line">    NdisFreeMemory(PacketContent, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> STATUS_PASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改INF文件"><a href="#修改INF文件" class="headerlink" title="修改INF文件"></a>修改INF文件</h4><p>在 <code>netsf_m.inf</code> 文件中，修改如下项</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">;修改ms_passthrump小端口设备名称</span></span><br><span class="line"><span class="section">[ControlFlags]</span></span><br><span class="line"><span class="attr">ExcludeFromSelect</span> = ms_passthrump</span><br><span class="line"><span class="section">[MSFT]</span></span><br><span class="line">%PassthruMP_Desc% = PassthruMP.ndi, ms_passthrump</span><br><span class="line"><span class="section">[MSFT.NTx86]</span></span><br><span class="line">%PassthruMP_Desc% = PassthruMP.ndi, ms_passthrump</span><br><span class="line"><span class="section">[MSFT.NTia64]</span></span><br><span class="line">%PassthruMP_Desc% = PassthruMP.ndi, ms_passthrump</span><br><span class="line"><span class="section">[MSFT.NTamd64]</span></span><br><span class="line">%PassthruMP_Desc% = PassthruMP.ndi, ms_passthrump</span><br></pre></td></tr></table></figure>

<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">;修改PassthruMP服务名称</span></span><br><span class="line"><span class="section">[PassthruMP.ndi.AddReg]</span></span><br><span class="line">HKR, Ndi, Service, 0, PassthruMP</span><br><span class="line"><span class="section">[PassthruMP.ndi.Services]</span></span><br><span class="line"><span class="attr">AddService</span> = PassthruMP, <span class="number">0</span>x2, PassthruMP.AddService</span><br></pre></td></tr></table></figure>

<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">;修改passthru.sys驱动文件名</span></span><br><span class="line"><span class="section">[PassthruMP.AddService]</span></span><br><span class="line"><span class="attr">ServiceType</span>    = <span class="number">1</span> <span class="comment">;SERVICE_KERNEL_DRIVER</span></span><br><span class="line"><span class="attr">StartType</span>      = <span class="number">3</span> <span class="comment">;SERVICE_DEMAND_START</span></span><br><span class="line"><span class="attr">ErrorControl</span>   = <span class="number">1</span> <span class="comment">;SERVICE_ERROR_NORMAL</span></span><br><span class="line"><span class="attr">ServiceBinary</span>  = %<span class="number">12</span>%\passthru.sys</span><br><span class="line"><span class="attr">AddReg</span>         = PassthruMP.AddService.AddReg</span><br></pre></td></tr></table></figure>

<p>在 <code>netsf.inf</code> 文件中，修改如下项</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">;修改ms_passthru协议设备名称</span></span><br><span class="line"><span class="section">[MSFT]</span></span><br><span class="line">%Passthru_Desc% = Passthru.ndi, ms_passthru</span><br><span class="line"><span class="section">[MSFT.NTx86]</span></span><br><span class="line">%Passthru_Desc% = Passthru.ndi, ms_passthru</span><br><span class="line"><span class="section">[MSFT.NTia64]</span></span><br><span class="line">%Passthru_Desc% = Passthru.ndi, ms_passthru</span><br><span class="line"><span class="section">[MSFT.NTamd64]</span></span><br><span class="line">%Passthru_Desc% = Passthru.ndi, ms_passthru</span><br></pre></td></tr></table></figure>

<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">;修改Passthru服务名称</span></span><br><span class="line"><span class="section">[Passthru.ndi.Services]</span></span><br><span class="line"><span class="attr">AddService</span> = Passthru, , Passthru.AddService</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">;修改passthru.sys驱动文件名</span></span><br><span class="line"><span class="section">[Passthru.AddService]</span></span><br><span class="line"><span class="attr">DisplayName</span>    = %PassthruService_Desc%</span><br><span class="line"><span class="attr">ServiceType</span>    = <span class="number">1</span> <span class="comment">;SERVICE_KERNEL_DRIVER</span></span><br><span class="line"><span class="attr">StartType</span>      = <span class="number">3</span> <span class="comment">;SERVICE_DEMAND_START</span></span><br><span class="line"><span class="attr">ErrorControl</span>   = <span class="number">1</span> <span class="comment">;SERVICE_ERROR_NORMAL</span></span><br><span class="line"><span class="attr">ServiceBinary</span>  = %<span class="number">12</span>%\passthru.sys</span><br><span class="line"><span class="attr">AddReg</span>         = Passthru.AddService.AddReg</span><br><span class="line"><span class="section">[Passthru.Files.Sys]</span></span><br><span class="line">passthru.sys, , , 2</span><br></pre></td></tr></table></figure>

<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">;修改ms_passthrump小端口设备名称，修改Passthru服务名称</span></span><br><span class="line"><span class="section">[Passthru.ndi.AddReg]</span></span><br><span class="line">HKR, Ndi, HelpText, , %Passthru_HELP%</span><br><span class="line">HKR, Ndi,            FilterClass,         , failover</span><br><span class="line">HKR, Ndi,            FilterDeviceInfId,   , ms_passthrump</span><br><span class="line">HKR, Ndi,            Service,             , Passthru</span><br><span class="line">HKR, Ndi\Interfaces, UpperRange,          , noupper</span><br><span class="line">HKR, Ndi\Interfaces, LowerRange,          , nolower</span><br><span class="line">HKR, Ndi\Interfaces, FilterMediaTypes,    , &quot;ethernet, tokenring, fddi, wan&quot;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络相关</category>
      </categories>
      <tags>
        <tag>网络相关</tag>
      </tags>
  </entry>
  <entry>
    <title>使用NDIS6.0实现数据包过滤(4)</title>
    <url>/2019/12/18/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E4%BD%BF%E7%94%A8NDIS6.0%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8C%85%E8%BF%87%E6%BB%A4-4/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在WIN7中可以使用 <code>NDIS6</code> 做网络过滤，在 <code>NDIS6</code> 中提供了一种 <code>LightWeight Filter</code> 的框架，<br>我们这里使用WDK源码中 <code>src -&gt; network -&gt; ndis -&gt; filter</code> 工程作为基础。</p>
<h4 id="修改device-c文件"><a href="#修改device-c文件" class="headerlink" title="修改device.c文件"></a>修改device.c文件</h4><p>这个文件主要是处理与应用层通讯的功能，我们可以在 <code>FilterDeviceIoControl</code> 函数中处理<br>自定义的控制码功能，使用时需要把原有的控制码处理程序删除。</p>
<h4 id="修改filter-h文件"><a href="#修改filter-h文件" class="headerlink" title="修改filter.h文件"></a>修改filter.h文件</h4><p>在文件的开头我们可以找到如下一系列宏定义，我们使用的是 <code>NDISLWF</code> 框架（source中定义），<br>所以只需要修改 <code>NDISLWF</code> 定义的内容，设备名称、服务名称、唯一标识都需要修改</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> NDISLWF</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILTER_FRIENDLY_NAME        <span class="meta-string">L&quot;NDIS Sample LightWeight Filter&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILTER_UNIQUE_NAME          <span class="meta-string">L&quot;&#123;5cbf81bd-5055-47cd-9055-a76b2b4e3697&#125;&quot;</span> <span class="comment">//&lt;-修改</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FILTER_SERVICE_NAME         <span class="meta-string">L&quot;NDISLWF&quot;</span> <span class="comment">//&lt;-修改</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINKNAME_STRING             <span class="meta-string">L&quot;\\DosDevices\\NDISLWF&quot;</span> <span class="comment">//&lt;-修改</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NTDEVICE_STRING             <span class="meta-string">L&quot;\\Device\\NDISLWF&quot;</span> <span class="comment">//&lt;-修改</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<h4 id="修改filter-c文件"><a href="#修改filter-c文件" class="headerlink" title="修改filter.c文件"></a>修改filter.c文件</h4><p>在 <code>FilterSendNetBufferLists</code> 函数中，处理发送数据包的功能。原函数的代码主要处理<br>调试和跟踪发送的数据包信息，如果我们不处理这些功能，就可以把相关代码全部删除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FilterSendNetBufferLists</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN  NDIS_HANDLE         FilterModuleContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN  PNET_BUFFER_LIST    NetBufferLists,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN  NDIS_PORT_NUMBER    PortNumber,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN  ULONG               SendFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PMS_FILTER          pFilter = (PMS_FILTER)FilterModuleContext;</span><br><span class="line">    PNET_BUFFER_LIST    CurrNbl = <span class="literal">NULL</span>;</span><br><span class="line">    BOOLEAN             DispatchLevel = FALSE;</span><br><span class="line">    BOOLEAN             bFalse = FALSE;</span><br><span class="line">    PKGFLT_STATUS       fStatus = STATUS_PASS;</span><br><span class="line">    DEBUGP(DL_TRACE, (<span class="string">&quot;===&gt;SendNetBufferList: NBL = %p.\n&quot;</span>, NetBufferLists));</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        DispatchLevel = NDIS_TEST_SEND_AT_DISPATCH_LEVEL(SendFlags);</span><br><span class="line">        <span class="comment">// 调试的相关处理，如果不需要可以删除</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DBG</span></span><br><span class="line">        <span class="comment">// we should never get packets to send if we are not in running state</span></span><br><span class="line">        FILTER_ACQUIRE_LOCK(&amp;pFilter-&gt;Lock, DispatchLevel);</span><br><span class="line">        <span class="comment">// If the filter is not in running state, fail the send</span></span><br><span class="line">        <span class="keyword">if</span> (pFilter-&gt;State != FilterRunning)</span><br><span class="line">        &#123;</span><br><span class="line">            FILTER_RELEASE_LOCK(&amp;pFilter-&gt;Lock, DispatchLevel);</span><br><span class="line">            CurrNbl = NetBufferLists;</span><br><span class="line">            <span class="keyword">while</span> (CurrNbl)</span><br><span class="line">            &#123;</span><br><span class="line">                NET_BUFFER_LIST_STATUS(CurrNbl) = NDIS_STATUS_PAUSED;</span><br><span class="line">                CurrNbl = NET_BUFFER_LIST_NEXT_NBL(CurrNbl);</span><br><span class="line">            &#125;</span><br><span class="line">            NdisFSendNetBufferListsComplete(pFilter-&gt;FilterHandle,</span><br><span class="line">                NetBufferLists,</span><br><span class="line">                DispatchLevel ? NDIS_SEND_COMPLETE_FLAGS_DISPATCH_LEVEL : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        FILTER_RELEASE_LOCK(&amp;pFilter-&gt;Lock, DispatchLevel);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">        <span class="comment">// 循环检测所有的包，决定是否拦截</span></span><br><span class="line">        CurrNbl = NetBufferLists;</span><br><span class="line">        <span class="keyword">while</span> (CurrNbl != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fStatus = AnalysisPacket(pFilter, CurrNbl, FALSE);</span><br><span class="line">            <span class="keyword">if</span> (fStatus == STATUS_DROP) <span class="keyword">break</span>;</span><br><span class="line">            CurrNbl = NET_BUFFER_LIST_NEXT_NBL(CurrNbl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fStatus == STATUS_DROP)</span><br><span class="line">        &#123;</span><br><span class="line">            CurrNbl = NetBufferLists;</span><br><span class="line">            <span class="keyword">while</span> (CurrNbl != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                NET_BUFFER_LIST_STATUS(CurrNbl) = NDIS_STATUS_FAILURE;</span><br><span class="line">                CurrNbl = NET_BUFFER_LIST_NEXT_NBL(CurrNbl);</span><br><span class="line">            &#125;</span><br><span class="line">            NdisFSendNetBufferListsComplete(pFilter-&gt;FilterHandle,</span><br><span class="line">                NetBufferLists,</span><br><span class="line">                DispatchLevel ? NDIS_SEND_COMPLETE_FLAGS_DISPATCH_LEVEL : <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">        <span class="comment">// 跟踪的相关处理，如果不需要可以删除</span></span><br><span class="line">        <span class="keyword">if</span> (pFilter-&gt;TrackSends)</span><br><span class="line">        &#123;</span><br><span class="line">            FILTER_ACQUIRE_LOCK(&amp;pFilter-&gt;Lock, DispatchLevel);</span><br><span class="line">            CurrNbl = NetBufferLists;</span><br><span class="line">            <span class="keyword">while</span> (CurrNbl)</span><br><span class="line">            &#123;</span><br><span class="line">                pFilter-&gt;OutstandingSends++;</span><br><span class="line">                FILTER_LOG_SEND_REF(<span class="number">1</span>, pFilter, CurrNbl, pFilter-&gt;OutstandingSends);</span><br><span class="line">                CurrNbl = NET_BUFFER_LIST_NEXT_NBL(CurrNbl);</span><br><span class="line">            &#125;</span><br><span class="line">            FILTER_RELEASE_LOCK(&amp;pFilter-&gt;Lock, DispatchLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数据包发送的正常调度函数</span></span><br><span class="line">        <span class="comment">// If necessary, queue the NetBufferList in a local structure for later processing</span></span><br><span class="line">        NdisFSendNetBufferLists(pFilter-&gt;FilterHandle, NetBufferLists, PortNumber, SendFlags);</span><br><span class="line">    &#125; <span class="keyword">while</span> (bFalse);</span><br><span class="line">    DEBUGP(DL_TRACE, (<span class="string">&quot;&lt;===SendNetBufferList. \n&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 <code>FilterReceiveNetBufferLists</code> 函数中，处理接收数据包的功能。与发送原函数的类似，<br>代码主要处理调试和跟踪接收的数据包信息，同样也可以把相关代码全部删除</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FilterReceiveNetBufferLists</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN  NDIS_HANDLE         FilterModuleContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN  PNET_BUFFER_LIST    NetBufferLists,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN  NDIS_PORT_NUMBER    PortNumber,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN  ULONG               NumberOfNetBufferLists,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN  ULONG               ReceiveFlags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    PMS_FILTER          pFilter = (PMS_FILTER)FilterModuleContext;</span><br><span class="line">    BOOLEAN             DispatchLevel;</span><br><span class="line">    ULONG               Ref = <span class="number">0</span>;</span><br><span class="line">    BOOLEAN             bFalse = FALSE;</span><br><span class="line">    PKGFLT_STATUS       fStatus = STATUS_PASS;</span><br><span class="line">    PNET_BUFFER_LIST    CurrNbl = <span class="literal">NULL</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DBG</span></span><br><span class="line">    ULONG               ReturnFlags;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    DEBUGP(DL_TRACE, (<span class="string">&quot;===&gt;ReceiveNetBufferList: NetBufferLists = %p.\n&quot;</span>, NetBufferLists));</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        DispatchLevel = NDIS_TEST_RECEIVE_AT_DISPATCH_LEVEL(ReceiveFlags);</span><br><span class="line">        <span class="comment">// 调试的相关处理，如果不需要可以删除</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DBG</span></span><br><span class="line">        FILTER_ACQUIRE_LOCK(&amp;pFilter-&gt;Lock, DispatchLevel);</span><br><span class="line">        <span class="keyword">if</span> (pFilter-&gt;State != FilterRunning)</span><br><span class="line">        &#123;</span><br><span class="line">            FILTER_RELEASE_LOCK(&amp;pFilter-&gt;Lock, DispatchLevel);</span><br><span class="line">            <span class="keyword">if</span> (NDIS_TEST_RECEIVE_CAN_PEND(ReceiveFlags))</span><br><span class="line">            &#123;</span><br><span class="line">                ReturnFlags = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (NDIS_TEST_RECEIVE_AT_DISPATCH_LEVEL(ReceiveFlags))</span><br><span class="line">                &#123;</span><br><span class="line">                    NDIS_SET_RETURN_FLAG(ReturnFlags, NDIS_RETURN_FLAGS_DISPATCH_LEVEL);</span><br><span class="line">                &#125;</span><br><span class="line">                NdisFReturnNetBufferLists(pFilter-&gt;FilterHandle, NetBufferLists, ReturnFlags);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        FILTER_RELEASE_LOCK(&amp;pFilter-&gt;Lock, DispatchLevel);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">        <span class="comment">// 循环检测所有的包</span></span><br><span class="line">        CurrNbl = NetBufferLists;</span><br><span class="line">        <span class="keyword">while</span> (CurrNbl != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            fStatus = AnalysisPacket(pFilter, CurrNbl, TRUE);</span><br><span class="line">            <span class="keyword">if</span> (fStatus == STATUS_DROP) <span class="keyword">break</span>;</span><br><span class="line">            CurrNbl = NET_BUFFER_LIST_NEXT_NBL(CurrNbl);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (fStatus == STATUS_DROP)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (NDIS_TEST_RECEIVE_CAN_PEND(ReceiveFlags))</span><br><span class="line">            &#123;</span><br><span class="line">                NdisFReturnNetBufferLists(pFilter-&gt;FilterHandle,</span><br><span class="line">                    NetBufferLists,</span><br><span class="line">                    DispatchLevel ? NDIS_RETURN_FLAGS_DISPATCH_LEVEL : <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//////////////////////////////////////////////////////////////////////////</span></span><br><span class="line">        <span class="comment">// 跟踪的相关处理，如果不需要可以删除</span></span><br><span class="line">        ASSERT(NumberOfNetBufferLists &gt;= <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// If necessary, queue the NetBufferList in a local structure for later processing.</span></span><br><span class="line">        <span class="comment">// We may need to travel the list, some of them may not need post processing</span></span><br><span class="line">        <span class="keyword">if</span> (pFilter-&gt;TrackReceives)</span><br><span class="line">        &#123;</span><br><span class="line">            FILTER_ACQUIRE_LOCK(&amp;pFilter-&gt;Lock, DispatchLevel);</span><br><span class="line">            pFilter-&gt;OutstandingRcvs += NumberOfNetBufferLists;</span><br><span class="line">            Ref = pFilter-&gt;OutstandingRcvs;</span><br><span class="line">            FILTER_LOG_RCV_REF(<span class="number">1</span>, pFilter, NetBufferLists, Ref);</span><br><span class="line">            FILTER_RELEASE_LOCK(&amp;pFilter-&gt;Lock, DispatchLevel);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数据包接收的正常调度函数</span></span><br><span class="line">        NdisFIndicateReceiveNetBufferLists(</span><br><span class="line">            pFilter-&gt;FilterHandle,</span><br><span class="line">            NetBufferLists,</span><br><span class="line">            PortNumber,</span><br><span class="line">            NumberOfNetBufferLists,</span><br><span class="line">            ReceiveFlags);</span><br><span class="line">        <span class="keyword">if</span> (NDIS_TEST_RECEIVE_CANNOT_PEND(ReceiveFlags) &amp;&amp; pFilter-&gt;TrackReceives)</span><br><span class="line">        &#123;</span><br><span class="line">            FILTER_ACQUIRE_LOCK(&amp;pFilter-&gt;Lock, DispatchLevel);</span><br><span class="line">            pFilter-&gt;OutstandingRcvs -= NumberOfNetBufferLists;</span><br><span class="line">            Ref = pFilter-&gt;OutstandingRcvs;</span><br><span class="line">            FILTER_LOG_RCV_REF(<span class="number">2</span>, pFilter, NetBufferLists, Ref);</span><br><span class="line">            FILTER_RELEASE_LOCK(&amp;pFilter-&gt;Lock, DispatchLevel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (bFalse);</span><br><span class="line">    DEBUGP(DL_TRACE, (<span class="string">&quot;&lt;===ReceiveNetBufferList: Flags = %8x.\n&quot;</span>, ReceiveFlags));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="数据包解析函数"><a href="#数据包解析函数" class="headerlink" title="数据包解析函数"></a>数据包解析函数</h4><p>与在 <code>NDIS5</code> 中定义的函数相似，但是数据包存储的格式有所变化</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PKGFLT_STATUS <span class="title">AnalysisPacket</span><span class="params">(PMS_FILTER pFilter, PNET_BUFFER_LIST CurNbl, BOOLEAN bRecv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG TotalLength = <span class="number">0</span>;</span><br><span class="line">    PUCHAR PacketContent = <span class="literal">NULL</span>;</span><br><span class="line">    PETH_HEADER EthHeader = <span class="literal">NULL</span>;</span><br><span class="line">    PONE_PACKET OnePacket = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS NtStatus = STATUS_SUCCESS;</span><br><span class="line">    PKGFLT_STATUS fStatus = STATUS_PASS;</span><br><span class="line">    <span class="comment">// 检查参数</span></span><br><span class="line">    <span class="keyword">if</span> (pFilter == <span class="literal">NULL</span>) <span class="keyword">return</span> STATUS_PASS;</span><br><span class="line">    <span class="keyword">if</span> (CurNbl == <span class="literal">NULL</span>) <span class="keyword">return</span> STATUS_PASS;</span><br><span class="line">    <span class="comment">// 查询数据包的长度</span></span><br><span class="line">    TotalLength = GetOneNblLen(CurNbl);</span><br><span class="line">    <span class="keyword">if</span> (TotalLength == <span class="number">0</span>) <span class="keyword">return</span> STATUS_PASS;</span><br><span class="line">    <span class="comment">// 申请数据包的空间</span></span><br><span class="line">    PacketContent = (PUCHAR)NdisAllocateMemoryWithTagPriority(</span><br><span class="line">        pFilter-&gt;FilterHandle, TotalLength, &#x27;MEM&#x27;, NormalPoolPriority);</span><br><span class="line">    <span class="keyword">if</span> (PacketContent == <span class="literal">NULL</span>) <span class="keyword">return</span> STATUS_PASS;</span><br><span class="line">    NdisZeroMemory(PacketContent, TotalLength);</span><br><span class="line">    <span class="comment">// 获取数据包的内容</span></span><br><span class="line">    NtStatus = GetOneNblData(CurNbl, PacketContent, TotalLength);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(NtStatus))</span><br><span class="line">    &#123;</span><br><span class="line">        NdisFreeMemory(PacketContent, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> STATUS_PASS;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 到此PacketContent即为以太网数据包</span></span><br><span class="line">    <span class="comment">// 我们可以对数据包进行解析和处理</span></span><br><span class="line">    NdisFreeMemory(PacketContent, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> STATUS_PASS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取数据包长度的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">ULONG <span class="title">GetOneNblLen</span><span class="params">(IN PNET_BUFFER_LIST CurNbl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG Length = <span class="number">0</span>;</span><br><span class="line">    PNET_BUFFER NetBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (CurNbl == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    NetBuffer = NET_BUFFER_LIST_FIRST_NB(CurNbl);</span><br><span class="line">    <span class="keyword">while</span> (NetBuffer != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        Length += NET_BUFFER_DATA_LENGTH(NetBuffer);</span><br><span class="line">        NetBuffer = NET_BUFFER_NEXT_NB(NetBuffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获取数据包内容的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">GetOneNblData</span><span class="params">(IN PNET_BUFFER_LIST CurNbl, OUT PUCHAR Buffer, IN ULONG BufLen)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PNET_BUFFER CurNb = <span class="literal">NULL</span>;</span><br><span class="line">    PMDL CurMdl = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG MdlOffset = <span class="number">0</span>;</span><br><span class="line">    PVOID MdlData = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG MdlBufLen = <span class="number">0</span>;</span><br><span class="line">    ULONG CopyLen = <span class="number">0</span>;</span><br><span class="line">    ULONG BufOffset = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 检查参数的有效性</span></span><br><span class="line">    <span class="keyword">if</span> (CurNbl == <span class="literal">NULL</span>) <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="keyword">if</span> (Buffer == <span class="literal">NULL</span>) <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="keyword">if</span> (BufLen == <span class="number">0</span>) <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="comment">// 循环复制数据</span></span><br><span class="line">    CurNb = NET_BUFFER_LIST_FIRST_NB(CurNbl);</span><br><span class="line">    <span class="keyword">while</span> (CurNb != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (BufOffset &gt;= BufLen) <span class="keyword">break</span>;</span><br><span class="line">        CurMdl = NET_BUFFER_CURRENT_MDL(CurNb);</span><br><span class="line">        MdlOffset = NET_BUFFER_CURRENT_MDL_OFFSET(CurNb);</span><br><span class="line">        <span class="keyword">while</span> (CurMdl != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (BufOffset &gt;= BufLen) <span class="keyword">break</span>;</span><br><span class="line">            NdisQueryMdl(CurMdl, &amp;MdlData, &amp;MdlBufLen, NormalPagePriority);</span><br><span class="line">            <span class="comment">// NBL-&gt;DataLength &lt;= MDL1-&gt;ByteCount + ... + MDLx-&gt;ByteCount - NBL-&gt;CurrentMDLOffset</span></span><br><span class="line">            <span class="comment">// 这里 Data length 不等于 Buffer Length</span></span><br><span class="line">            CopyLen = MdlBufLen - MdlOffset;</span><br><span class="line">            <span class="keyword">if</span> (CopyLen &gt; BufLen) CopyLen = BufLen;</span><br><span class="line">            <span class="comment">// 复制数据到总缓冲区内</span></span><br><span class="line">            <span class="keyword">if</span> ((MdlData != <span class="literal">NULL</span>) &amp;&amp; (BufLen &gt; <span class="number">0</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                NdisMoveMemory((Buffer + BufOffset), (PUCHAR)MdlData + MdlOffset, CopyLen);</span><br><span class="line">                BufOffset += CopyLen;</span><br><span class="line">                BufLen -= CopyLen; <span class="comment">// 剩余空间大小</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 一般来说，只有第一个MDL的buffer才有偏移，其余的都没有。</span></span><br><span class="line">            <span class="comment">// 如果offset大于了buflen，那么第一个MDL就没有存在的意义了。</span></span><br><span class="line">            MdlOffset = <span class="number">0</span>;</span><br><span class="line">            NdisGetNextMdl(CurMdl, &amp;CurMdl);</span><br><span class="line">        &#125;</span><br><span class="line">        CurNb = NET_BUFFER_NEXT_NB(CurNb);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="修改INF文件"><a href="#修改INF文件" class="headerlink" title="修改INF文件"></a>修改INF文件</h4><p>在 <code>ndislwf.inf</code> 中，修改如下项</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">;修改MS_NdisLwf设备名称</span></span><br><span class="line"><span class="section">[MSFT.NTx86]</span></span><br><span class="line">%NdisLwf_Desc%=Install, MS_NdisLwf</span><br><span class="line"><span class="section">[MSFT.NTia64]</span></span><br><span class="line">%NdisLwf_Desc%=Install, MS_NdisLwf</span><br><span class="line"><span class="section">[MSFT.NTamd64]</span></span><br><span class="line">%NdisLwf_Desc%=Install, MS_NdisLwf</span><br></pre></td></tr></table></figure>

<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">;修改ndislwf.sys驱动文件名</span></span><br><span class="line"><span class="section">[SourceDisksFiles]</span></span><br><span class="line"><span class="attr">ndislwf.sys</span> = <span class="number">1</span></span><br><span class="line"><span class="section">[ndislwf.copyfiles.sys]</span></span><br><span class="line">ndislwf.sys, , , 2</span><br><span class="line"><span class="section">[NdisLwf_Service_Inst]</span></span><br><span class="line"><span class="attr">DisplayName</span>     = %NdisLwf_Desc%</span><br><span class="line"><span class="attr">ServiceType</span>     = <span class="number">1</span> <span class="comment">;SERVICE_KERNEL_DRIVER</span></span><br><span class="line"><span class="attr">StartType</span>       = <span class="number">1</span> <span class="comment">;SERVICE_SYSTEM_START</span></span><br><span class="line"><span class="attr">ErrorControl</span>    = <span class="number">1</span> <span class="comment">;SERVICE_ERROR_NORMAL</span></span><br><span class="line"><span class="attr">ServiceBinary</span>   = %<span class="number">12</span>%\ndislwf.sys</span><br><span class="line"><span class="attr">LoadOrderGroup</span>  = NDIS</span><br><span class="line"><span class="attr">Description</span>     = %NdisLwf_Desc%</span><br><span class="line"><span class="attr">AddReg</span>          = Common.Params.reg</span><br></pre></td></tr></table></figure>

<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">;修改NdisLwf服务名称</span></span><br><span class="line"><span class="section">[Inst_Ndi]</span></span><br><span class="line">HKR, Ndi, Service, , &quot;NdisLwf&quot;</span><br><span class="line">HKR, Ndi, CoServices, 0x00010000, &quot;NdisLwf&quot;</span><br><span class="line">HKR, Ndi, HelpText, , %NdisLwf_HelpText%</span><br><span class="line">HKR, Ndi, FilterClass, , compression</span><br><span class="line">HKR, Ndi, FilterType, 0x00010001, 0x00000002</span><br><span class="line">HKR, Ndi\Interfaces, UpperRange, , &quot;noupper&quot;</span><br><span class="line">HKR, Ndi\Interfaces, LowerRange, , &quot;nolower&quot;</span><br><span class="line">HKR, Ndi\Interfaces, FilterMediaTypes, , &quot;ethernet&quot;</span><br><span class="line">HKR, Ndi,FilterRunType, 0x00010001, 1</span><br><span class="line"><span class="section">[Install.Remove.Services]</span></span><br><span class="line"><span class="attr">DelService</span> = NdisLwf, <span class="number">0</span>x200</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络相关</category>
      </categories>
      <tags>
        <tag>网络相关</tag>
      </tags>
  </entry>
  <entry>
    <title>使用WFP实现数据包过滤(2)</title>
    <url>/2019/07/22/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E4%BD%BF%E7%94%A8WFP%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%8C%85%E8%BF%87%E6%BB%A4-2/</url>
    <content><![CDATA[<h4 id="WFP框架简介"><a href="#WFP框架简介" class="headerlink" title="WFP框架简介"></a>WFP框架简介</h4><p>在VISTA及以上的系统中，微软提供了对 <code>TDI</code> 封装的 <code>WFP</code> 框架，简化了处理逻辑。<code>WFP</code> 把数据包处理流程<br>划分了许多个层，在我们关注的 <code>layer</code> 上注册 <code>callout</code>  和  <code>filter</code> ，就可以针对相应的操作进行处理</p>
<p>这些层的 <code>GUID</code> 可以在 <code>fwpmk.h</code> 头文件中找到定义，另外微软给出了数据传输时所流经的层：<br>(TCP Packet Flows) <a href="https://docs.microsoft.com/en-us/windows/win32/fwp/tcp-packet-flows">https://docs.microsoft.com/en-us/windows/win32/fwp/tcp-packet-flows</a><br>(UDP Packet Flows) <a href="https://docs.microsoft.com/en-us/windows/win32/fwp/udp-packet-flows">https://docs.microsoft.com/en-us/windows/win32/fwp/udp-packet-flows</a><br>所有非TCP的处理方式全归到UDP中，比如ICMP会依照UDP流程进行处理</p>
<p>根据微软提供的数据传输流程，我们参考WDK例子中的 <code>src\network\trans\ddproxy</code> 项目来进行修改<br>(1) 首先要在ALE层获取建立连接的进程信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 完成连接的层(不含握手阶段)</span></span><br><span class="line">FWPM_LAYER_ALE_FLOW_ESTABLISHED_V4</span><br><span class="line"><span class="comment">// 发起连接或接受连接的层</span></span><br><span class="line">FWPM_LAYER_ALE_AUTH_RECV_ACCEPT_V4</span><br><span class="line">FWPM_LAYER_ALE_AUTH_CONNECT_V4</span><br></pre></td></tr></table></figure>

<p>(2) 获取进程信息后，存储到 <code>FlowContext</code> 并绑定到数据处理层</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// TCP数据层</span></span><br><span class="line">FWPM_LAYER_STREAM_V4</span><br><span class="line"><span class="comment">// UDP数据层</span></span><br><span class="line">FWPM_LAYER_DATAGRAM_DATA_V4</span><br></pre></td></tr></table></figure>

<p>注意：如果绑定 <code>TRANSPORT</code> 层会先于 <code>ESTABLISHED</code> 抓到的UDP第1个包，所以就没有进程信息</p>
<h4 id="相关函数和结构体"><a href="#相关函数和结构体" class="headerlink" title="相关函数和结构体"></a>相关函数和结构体</h4><p>我们以在 <code>WIN7</code> 目标系统运行为例，注册时所使用的相关函数的通用定义为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">FwpmEngineOpen</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ <span class="keyword">const</span> <span class="keyword">wchar_t</span>                   *serverName,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_           UINT32                    authnService,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_       SEC_WINNT_AUTH_IDENTITY_W *authIdentity,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ <span class="keyword">const</span> FWPM_SESSION              *session,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_          HANDLE                    *engineHandle</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 打开WFP过滤引擎</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">FwpsCalloutRegister</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_         <span class="keyword">void</span>         *deviceObject,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      <span class="keyword">const</span> FWPS_CALLOUT *callout,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_opt_       UINT32       *calloutId</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 注册呼出接口函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">FwpmCalloutAdd</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_            HANDLE               engineHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      <span class="keyword">const</span> FWPM_CALLOUT         *callout,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_        PSECURITY_DESCRIPTOR sd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_opt_       UINT32               *id</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 添加呼出接口层</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">FwpmFilterAdd</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_            HANDLE              engineHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      <span class="keyword">const</span> FWPM_FILTER         *filter,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_        SECURITY_DESCRIPTOR sd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_opt_       UINT64              *id</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 添加过滤规则</span></span><br></pre></td></tr></table></figure>

<p>以上几个函数的参数中，还有3个关键的结构体参数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FWPS_CALLOUT0_</span> &#123;</span></span><br><span class="line">  GUID                                calloutKey; <span class="comment">// 注册时提供的Callout唯一ID</span></span><br><span class="line">  UINT32                              flags;</span><br><span class="line">  FWPS_CALLOUT_CLASSIFY_FN0           classifyFn; <span class="comment">// 每当有网络数据要处理时，筛选器引擎都会调用此函数</span></span><br><span class="line">  FWPS_CALLOUT_NOTIFY_FN0             notifyFn;</span><br><span class="line">  FWPS_CALLOUT_FLOW_DELETE_NOTIFY_FN0 flowDeleteFn; <span class="comment">// 每当调用项处理的数据流终止时，筛选器引擎都会调用此函数</span></span><br><span class="line">&#125; FWPS_CALLOUT0; <span class="comment">// 设置回调函数</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FWPM_CALLOUT0_</span> &#123;</span></span><br><span class="line">  GUID               calloutKey; <span class="comment">// 与上边的Callout唯一ID相同</span></span><br><span class="line">  FWPM_DISPLAY_DATA0 displayData; <span class="comment">// 用于描述Callout的字符串</span></span><br><span class="line">  UINT32             flags;</span><br><span class="line">  GUID               *providerKey;</span><br><span class="line">  FWP_BYTE_BLOB      providerData;</span><br><span class="line">  GUID               applicableLayer; <span class="comment">// 当前Callout要应用到哪个层上</span></span><br><span class="line">  UINT32             calloutId;</span><br><span class="line">&#125; FWPM_CALLOUT0; <span class="comment">// 设置想要注册的层</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">FWPM_FILTER0_</span> &#123;</span></span><br><span class="line">  GUID                   filterKey; <span class="comment">// 初始化为0，添加到引擎时，会自动生成</span></span><br><span class="line">  FWPM_DISPLAY_DATA0     displayData; <span class="comment">// 用于描述Filter的字符串</span></span><br><span class="line">  UINT32                 flags;</span><br><span class="line">  GUID                   *providerKey;</span><br><span class="line">  FWP_BYTE_BLOB          providerData;</span><br><span class="line">  GUID                   layerKey; <span class="comment">// 当前Filter要应用到哪个层上</span></span><br><span class="line">  GUID                   subLayerKey; <span class="comment">// 使用通用子层</span></span><br><span class="line">  FWP_VALUE0             weight; <span class="comment">// 权重，设置为FWP_EMPTY，引擎会自动分配</span></span><br><span class="line">  UINT32                 numFilterConditions; <span class="comment">// 过滤条件的数量</span></span><br><span class="line">  FWPM_FILTER_CONDITION0 *filterCondition; <span class="comment">// 过滤条件的内容</span></span><br><span class="line">  FWPM_ACTION0           action; <span class="comment">// 要行使的规则，允许或阻止，或由Callout返回规则</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    UINT64 rawContext;</span><br><span class="line">    GUID   providerContextKey;</span><br><span class="line">  &#125;;</span><br><span class="line">  GUID                   *reserved;</span><br><span class="line">  UINT64                 filterId;</span><br><span class="line">  FWP_VALUE0             effectiveWeight;</span><br><span class="line">&#125; FWPM_FILTER0; <span class="comment">// 设置对应层的过滤规则</span></span><br></pre></td></tr></table></figure>

<h4 id="初始化全局变量"><a href="#初始化全局变量" class="headerlink" title="初始化全局变量"></a>初始化全局变量</h4><p>定义和初始化相关全局变量，使用 <code>VS2015</code> + <code>WDK10.0.15063.0</code> 平台，目标运行在 <code>WIN7</code> 及以上系统</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDIS_WDM 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDIS620 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;guiddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fwpmk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fwpsk.h&gt;</span></span></span><br><span class="line"><span class="comment">// 在附加依赖项中添加</span></span><br><span class="line"><span class="comment">// $(DDK_LIB_PATH)fwpkclnt.lib</span></span><br><span class="line"><span class="comment">// 结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">REGISTER_INFO</span> &#123;</span></span><br><span class="line">    GUID FwpmLayerGuid;</span><br><span class="line">    GUID FwpmSubLayerGuid;</span><br><span class="line">    GUID FwpsCalloutGuid;</span><br><span class="line">    UINT32 FwpsCalloutID;</span><br><span class="line">    UINT32 FwpmCalloutID;</span><br><span class="line">    UINT64 FwpmFilterID;</span><br><span class="line">&#125; REGISTER_INFO, *PREGISTER_INFO;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">FLOWCXT_ENTRY</span> &#123;</span></span><br><span class="line">    LIST_ENTRY Entry;</span><br><span class="line">    UINT64 flowId;</span><br><span class="line">    UINT16 layerId;</span><br><span class="line">    UINT32 calloutId;</span><br><span class="line">    UINT64 Pid;</span><br><span class="line">    WCHAR Path[MAX_PATH];</span><br><span class="line">&#125; FLOWCXT_ENTRY, *PFLOWCXT_ENTRY;</span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">KSPIN_LOCK MyFlowCtxLock = <span class="number">0</span>;</span><br><span class="line">LIST_ENTRY MyFlowCtxList = &#123; <span class="number">0</span> &#125;; <span class="comment">// 卸载时要释放FlowContext</span></span><br><span class="line">PDEVICE_OBJECT MyNetDevice = <span class="literal">NULL</span>;</span><br><span class="line">REGISTER_INFO MyConnect = &#123;</span><br><span class="line">    <span class="comment">// FWPM_LAYER_ALE_AUTH_CONNECT_V4</span></span><br><span class="line">    &#123; <span class="number">0xc38d57d1</span>, <span class="number">0x05a7</span>, <span class="number">0x4c33</span>, <span class="number">0x90</span>, <span class="number">0x4f</span>, <span class="number">0x7f</span>, <span class="number">0xbc</span>, <span class="number">0xee</span>, <span class="number">0xe6</span>, <span class="number">0x0e</span>, <span class="number">0x82</span> &#125;,</span><br><span class="line">    <span class="comment">// FWPM_SUBLAYER_UNIVERSAL</span></span><br><span class="line">    &#123; <span class="number">0xeebecc03</span>, <span class="number">0xced4</span>, <span class="number">0x4380</span>, <span class="number">0x81</span>, <span class="number">0x9a</span>, <span class="number">0x27</span>, <span class="number">0x34</span>, <span class="number">0x39</span>, <span class="number">0x7b</span>, <span class="number">0x2b</span>, <span class="number">0x74</span> &#125;,</span><br><span class="line">    <span class="comment">// 自定义的GUID</span></span><br><span class="line">    &#123; <span class="number">0xd969fc61</span>, <span class="number">0x6fb2</span>, <span class="number">0x4504</span>, <span class="number">0x91</span>, <span class="number">0xce</span>, <span class="number">0xa9</span>, <span class="number">0x7c</span>, <span class="number">0x3c</span>, <span class="number">0x32</span>, <span class="number">0xad</span>, <span class="number">0x36</span> &#125; &#125;;</span><br><span class="line">REGISTER_INFO MyDatagram = &#123;</span><br><span class="line">    <span class="comment">// FWPM_LAYER_DATAGRAM_DATA_V4</span></span><br><span class="line">    &#123; <span class="number">0x3d08bf4e</span>, <span class="number">0x45f6</span>, <span class="number">0x4930</span>, <span class="number">0xa9</span>, <span class="number">0x22</span>, <span class="number">0x41</span>, <span class="number">0x70</span>, <span class="number">0x98</span>, <span class="number">0xe2</span>, <span class="number">0x00</span>, <span class="number">0x27</span> &#125;,</span><br><span class="line">    <span class="comment">// FWPM_SUBLAYER_UNIVERSAL</span></span><br><span class="line">    &#123; <span class="number">0xeebecc03</span>, <span class="number">0xced4</span>, <span class="number">0x4380</span>, <span class="number">0x81</span>, <span class="number">0x9a</span>, <span class="number">0x27</span>, <span class="number">0x34</span>, <span class="number">0x39</span>, <span class="number">0x7b</span>, <span class="number">0x2b</span>, <span class="number">0x74</span> &#125;,</span><br><span class="line">     <span class="comment">// 自定义的GUID</span></span><br><span class="line">    &#123; <span class="number">0xd969fc62</span>, <span class="number">0x6fb2</span>, <span class="number">0x4504</span>, <span class="number">0x91</span>, <span class="number">0xce</span>, <span class="number">0xa9</span>, <span class="number">0x7c</span>, <span class="number">0x3c</span>, <span class="number">0x32</span>, <span class="number">0xad</span>, <span class="number">0x36</span> &#125; &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="注册过滤引擎"><a href="#注册过滤引擎" class="headerlink" title="注册过滤引擎"></a>注册过滤引擎</h4><p>实现一个过滤功能需要：先注册Callout层，再添加Callout层到引擎中，最后再绑定Fillter并添加到引擎中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">AddFilterEngine</span><span class="params">(PREGISTER_INFO RegInfo, BOOLEAN UseFlowCtx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE FwpmEngine = <span class="literal">NULL</span>;</span><br><span class="line">    FWPM_SESSION FwpmSession = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    FWPS_CALLOUT FwpsCallout = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    FWPM_CALLOUT FwpmCallout = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    FWPM_FILTER FwpmFilter = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    <span class="comment">// 打开WFP引擎</span></span><br><span class="line">    Status = FwpmEngineOpen(<span class="literal">NULL</span>, RPC_C_AUTHN_WINNT, <span class="literal">NULL</span>, &amp;FwpmSession, &amp;FwpmEngine);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">return</span> Status;</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注册呼出接口函数</span></span><br><span class="line">        FwpsCallout.calloutKey = RegInfo-&gt;FwpsCalloutGuid;</span><br><span class="line">        FwpsCallout.classifyFn = FwpsCalloutClassifyFn;</span><br><span class="line">        FwpsCallout.notifyFn = FwpsCalloutNotifyFn;</span><br><span class="line">        <span class="keyword">if</span> (UseFlowCtx)</span><br><span class="line">        &#123;</span><br><span class="line">            FwpsCallout.flowDeleteFn = FwpsCalloutFlowDeleteFn;</span><br><span class="line">            FwpsCallout.flags = FWP_CALLOUT_FLAG_CONDITIONAL_ON_FLOW;</span><br><span class="line">        &#125;</span><br><span class="line">        Status = FwpsCalloutRegister(MyNetDevice, &amp;FwpsCallout, &amp;RegInfo-&gt;FwpsCalloutID);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 添加呼出接口层</span></span><br><span class="line">        FwpmCallout.displayData.name = <span class="string">L&quot;FwpmCallout&quot;</span>;</span><br><span class="line">        FwpmCallout.displayData.description = <span class="string">L&quot;FwpmCallout&quot;</span>;</span><br><span class="line">        FwpmCallout.calloutKey = RegInfo-&gt;FwpsCalloutGuid;</span><br><span class="line">        FwpmCallout.applicableLayer = RegInfo-&gt;FwpmLayerGuid;</span><br><span class="line">        Status = FwpmCalloutAdd(FwpmEngine, &amp;FwpmCallout, <span class="literal">NULL</span>, &amp;RegInfo-&gt;FwpmCalloutID);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 添加过滤规则</span></span><br><span class="line">        FwpmFilter.displayData.name = <span class="string">L&quot;FwpmFilter&quot;</span>;</span><br><span class="line">        FwpmFilter.displayData.description = <span class="string">L&quot;FwpmFilter&quot;</span>;</span><br><span class="line">        FwpmFilter.layerKey = RegInfo-&gt;FwpmLayerGuid;</span><br><span class="line">        FwpmFilter.subLayerKey = RegInfo-&gt;FwpmSubLayerGuid;</span><br><span class="line">        FwpmFilter.weight.type = FWP_EMPTY;</span><br><span class="line">        FwpmFilter.action.type = FWP_ACTION_CALLOUT_TERMINATING;</span><br><span class="line">        FwpmFilter.action.calloutKey = RegInfo-&gt;FwpsCalloutGuid;</span><br><span class="line">        Status = FwpmFilterAdd(FwpmEngine, &amp;FwpmFilter, <span class="literal">NULL</span>, &amp;RegInfo-&gt;FwpmFilterID);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) DelFilterEngine(RegInfo);</span><br><span class="line">    FwpmEngineClose(FwpmEngine);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除过滤功能的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DelFilterEngine</span><span class="params">(PREGISTER_INFO RegInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HANDLE FwpmEngine = <span class="literal">NULL</span>;</span><br><span class="line">    FWPM_SESSION FwpmSession = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    Status = FwpmEngineOpen(<span class="literal">NULL</span>, RPC_C_AUTHN_WINNT, <span class="literal">NULL</span>, &amp;FwpmSession, &amp;FwpmEngine);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">return</span> Status;</span><br><span class="line">    <span class="keyword">if</span> (RegInfo-&gt;FwpmFilterID)</span><br><span class="line">    &#123;</span><br><span class="line">        FwpmFilterDeleteById(FwpmEngine, RegInfo-&gt;FwpmFilterID);</span><br><span class="line">        RegInfo-&gt;FwpmFilterID = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (RegInfo-&gt;FwpmCalloutID)</span><br><span class="line">    &#123;</span><br><span class="line">        FwpmCalloutDeleteById(FwpmEngine, RegInfo-&gt;FwpmCalloutID);</span><br><span class="line">        RegInfo-&gt;FwpmCalloutID = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (RegInfo-&gt;FwpsCalloutID)</span><br><span class="line">    &#123;</span><br><span class="line">        FwpsCalloutUnregisterById(RegInfo-&gt;FwpsCalloutID);</span><br><span class="line">        RegInfo-&gt;FwpsCalloutID = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FwpmEngineClose(FwpmEngine);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="相关回调函数"><a href="#相关回调函数" class="headerlink" title="相关回调函数"></a>相关回调函数</h4><p>如下为注册Callout层时提供的相关函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> NTAPI <span class="title">FwpsCalloutFlowDeleteFn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN UINT16 layerId,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN UINT32 calloutId,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN UINT64 flowContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    PFLOWCXT_ENTRY FlowCtxEntry = (PFLOWCXT_ENTRY)flowContext;</span><br><span class="line">    <span class="keyword">if</span> (!FlowCtxEntry) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (!FlowCtxEntry-&gt;Entry.Flink || !FlowCtxEntry-&gt;Entry.Blink) <span class="keyword">return</span>;</span><br><span class="line">    Status = FwpsFlowRemoveContext(FlowCtxEntry-&gt;flowId, layerId, calloutId);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">return</span>;</span><br><span class="line">    RemoveFlowCtxList(FlowCtxEntry);</span><br><span class="line">    ExFreePool(FlowCtxEntry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS NTAPI <span class="title">FwpsCalloutNotifyFn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN FWPS_CALLOUT_NOTIFY_TYPE notifyType,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN <span class="keyword">const</span> GUID *filterKey,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN FWPS_FILTER *filter)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(notifyType);</span><br><span class="line">    UNREFERENCED_PARAMETER(filterKey);</span><br><span class="line">    UNREFERENCED_PARAMETER(filter);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> NTAPI <span class="title">FwpsCalloutClassifyFn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN <span class="keyword">const</span> FWPS_INCOMING_VALUES *inFixedValues,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN <span class="keyword">const</span> FWPS_INCOMING_METADATA_VALUES *inMetaValues,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT <span class="keyword">void</span> *layerData,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OPTIONAL <span class="keyword">const</span> <span class="keyword">void</span> *classifyContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN <span class="keyword">const</span> FWPS_FILTER *filter,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN UINT64 flowContext,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN OUT FWPS_CLASSIFY_OUT *classifyOut)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(classifyContext);</span><br><span class="line">    UNREFERENCED_PARAMETER(filter);</span><br><span class="line">    UNREFERENCED_PARAMETER(flowContext);</span><br><span class="line">    <span class="comment">// 设置允许动作，并清除操作标志位</span></span><br><span class="line">    classifyOut-&gt;actionType = FWP_ACTION_PERMIT;</span><br><span class="line">    <span class="keyword">if</span> (filter-&gt;flags &amp; FWPS_FILTER_FLAG_CLEAR_ACTION_RIGHT)</span><br><span class="line">        classifyOut-&gt;rights &amp;= (~FWPS_RIGHT_ACTION_WRITE);</span><br><span class="line">    <span class="comment">// 判断触发的哪个层</span></span><br><span class="line">    <span class="keyword">switch</span> (inFixedValues-&gt;layerId)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> FWPS_LAYER_DATAGRAM_DATA_V4: <span class="comment">// 24</span></span><br><span class="line">        DbgPrint(<span class="string">&quot;FWPS_LAYER_DATAGRAM_DATA_V4\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 根据flowContext决定是否拦截</span></span><br><span class="line">        <span class="comment">// classifyOut-&gt;actionType = FWP_ACTION_BLOCK;</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> FWPS_LAYER_ALE_AUTH_CONNECT_V4: <span class="comment">// 48</span></span><br><span class="line">        DbgPrint(<span class="string">&quot;FWPS_LAYER_ALE_AUTH_CONNECT_V4\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 申请流上下文并存入链表中</span></span><br><span class="line">        AllocateFlowContext(inMetaValues, FWPS_LAYER_DATAGRAM_DATA_V4, MyDatagram.FwpsCalloutID);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置允许动作，并清除操作标志位</span></span><br><span class="line">    classifyOut-&gt;actionType = FWP_ACTION_PERMIT;</span><br><span class="line">    <span class="keyword">if</span> (filter-&gt;flags &amp; FWPS_FILTER_FLAG_CLEAR_ACTION_RIGHT)</span><br><span class="line">        classifyOut-&gt;rights &amp;= (~FWPS_RIGHT_ACTION_WRITE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="流上下文链表操作"><a href="#流上下文链表操作" class="headerlink" title="流上下文链表操作"></a>流上下文链表操作</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">AllocateFlowContext</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    IN <span class="keyword">const</span> FWPS_INCOMING_METADATA_VALUES *inMetaValues,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN FWPS_BUILTIN_LAYERS FwpsLayerID,</span></span></span><br><span class="line"><span class="function"><span class="params">    IN UINT32 FwpsCalloutID)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PFLOWCXT_ENTRY FlowCtxEntry = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="keyword">if</span> (!inMetaValues) <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="comment">// 检测信息是否有效</span></span><br><span class="line">    <span class="keyword">if</span> (!FWPS_IS_METADATA_FIELD_PRESENT(inMetaValues, FWPS_METADATA_FIELD_FLOW_HANDLE))</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="keyword">if</span> (!FWPS_IS_METADATA_FIELD_PRESENT(inMetaValues, FWPS_METADATA_FIELD_PROCESS_ID))</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="keyword">if</span> (!FWPS_IS_METADATA_FIELD_PRESENT(inMetaValues, FWPS_METADATA_FIELD_PROCESS_PATH))</span><br><span class="line">        <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="comment">// 申请流上下文内容</span></span><br><span class="line">    FlowCtxEntry = ExAllocatePool(NonPagedPoolNx, <span class="keyword">sizeof</span>(FLOWCXT_ENTRY));</span><br><span class="line">    <span class="keyword">if</span> (!FlowCtxEntry) <span class="keyword">return</span> STATUS_UNSUCCESSFUL;</span><br><span class="line">    <span class="comment">// 初始化需要的信息</span></span><br><span class="line">    RtlZeroMemory(FlowCtxEntry, <span class="keyword">sizeof</span>(FLOWCXT_ENTRY));</span><br><span class="line">    FlowCtxEntry-&gt;flowId = inMetaValues-&gt;flowHandle;</span><br><span class="line">    FlowCtxEntry-&gt;layerId = FwpsLayerID;</span><br><span class="line">    FlowCtxEntry-&gt;calloutId = FwpsCalloutID;</span><br><span class="line">    FlowCtxEntry-&gt;Pid = inMetaValues-&gt;processId;</span><br><span class="line">    RtlCopyMemory(FlowCtxEntry-&gt;Path, inMetaValues-&gt;processPath-&gt;data, inMetaValues-&gt;processPath-&gt;size);</span><br><span class="line">    DbgPrint(<span class="string">&quot;flowId:%llu layerId:%u calloutId:%u pid:%llu\n path:%ws\n&quot;</span>,</span><br><span class="line">        FlowCtxEntry-&gt;flowId,FlowCtxEntry-&gt;layerId, FlowCtxEntry-&gt;calloutId, FlowCtxEntry-&gt;Pid, FlowCtxEntry-&gt;Path);</span><br><span class="line">    <span class="comment">// 关联流上下文到目标层中</span></span><br><span class="line">    Status = FwpsFlowAssociateContext(</span><br><span class="line">        inMetaValues-&gt;flowHandle, FlowCtxEntry-&gt;layerId, FlowCtxEntry-&gt;calloutId, (ULONG64)FlowCtxEntry);</span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS(Status))</span><br><span class="line">        InsertFlowCtxList(FlowCtxEntry);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ExFreePool(FlowCtxEntry);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOLEAN <span class="title">RemoveFlowCtxList</span><span class="params">(PFLOWCXT_ENTRY FlowCtxEntry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KIRQL OldIrql = <span class="number">0</span>;</span><br><span class="line">    BOOLEAN Result = FALSE;</span><br><span class="line">    <span class="keyword">if</span> (!FlowCtxEntry) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">if</span> (!FlowCtxEntry-&gt;Entry.Blink) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">if</span> (!FlowCtxEntry-&gt;Entry.Flink) <span class="keyword">return</span> FALSE;</span><br><span class="line">    ExAcquireSpinLock(&amp;MyFlowCtxLock, &amp;OldIrql);</span><br><span class="line">    Result = RemoveEntryList(&amp;FlowCtxEntry-&gt;Entry);</span><br><span class="line">    ExReleaseSpinLock(&amp;MyFlowCtxLock, OldIrql);</span><br><span class="line">    FlowCtxEntry-&gt;Entry.Blink = <span class="literal">NULL</span>;</span><br><span class="line">    FlowCtxEntry-&gt;Entry.Flink = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> Result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DestoryFlowCtxList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KIRQL OldIrql = <span class="number">0</span>;</span><br><span class="line">    PLIST_ENTRY Entry = <span class="literal">NULL</span>;</span><br><span class="line">    PFLOWCXT_ENTRY FlowCtxEntry = <span class="literal">NULL</span>;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    <span class="keyword">while</span> (!IsListEmpty(&amp;MyFlowCtxList))</span><br><span class="line">    &#123;</span><br><span class="line">        ExAcquireSpinLock(&amp;MyFlowCtxLock, &amp;OldIrql);</span><br><span class="line">        Entry = RemoveHeadList(&amp;MyFlowCtxList);</span><br><span class="line">        ExReleaseSpinLock(&amp;MyFlowCtxLock, OldIrql);</span><br><span class="line">        <span class="keyword">if</span> (Entry == &amp;MyFlowCtxList) <span class="keyword">break</span>; <span class="comment">// 链表为空</span></span><br><span class="line">        FlowCtxEntry = CONTAINING_RECORD(Entry, FLOWCXT_ENTRY, Entry);</span><br><span class="line">        FlowCtxEntry-&gt;Entry.Blink = <span class="literal">NULL</span>;</span><br><span class="line">        FlowCtxEntry-&gt;Entry.Flink = <span class="literal">NULL</span>;</span><br><span class="line">        Status = FwpsFlowRemoveContext(</span><br><span class="line">            FlowCtxEntry-&gt;flowId, FlowCtxEntry-&gt;layerId, FlowCtxEntry-&gt;calloutId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="驱动的入口函数"><a href="#驱动的入口函数" class="headerlink" title="驱动的入口函数"></a>驱动的入口函数</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_SUCCESS;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    DbgPrint(<span class="string">&quot;Hello\n&quot;</span>);</span><br><span class="line">    <span class="comment">// 初始化链表</span></span><br><span class="line">    InitializeListHead(&amp;MyFlowCtxList);</span><br><span class="line">    KeInitializeSpinLock(&amp;MyFlowCtxLock);</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    <span class="comment">// 创建网络设备</span></span><br><span class="line">    Status = IoCreateDevice(DriverObject, <span class="number">0</span>, <span class="literal">NULL</span>,</span><br><span class="line">        FILE_DEVICE_NETWORK, FILE_DEVICE_SECURE_OPEN, FALSE, &amp;MyNetDevice);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">return</span> Status;</span><br><span class="line">    <span class="comment">// 注册过滤引擎</span></span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Status = AddFilterEngine(&amp;MyDatagram, TRUE);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        Status = AddFilterEngine(&amp;MyConnect, FALSE);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 检查是否失败</span></span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        DelFilterEngine(&amp;MyDatagram);</span><br><span class="line">        DelFilterEngine(&amp;MyConnect);</span><br><span class="line">        IoDeleteDevice(MyNetDevice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在驱动卸载时，注意要主动释放流上下文</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">DriverUnload</span><span class="params">(IN PDRIVER_OBJECT DriverObject)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DriverObject);</span><br><span class="line">    DelFilterEngine(&amp;MyConnect);</span><br><span class="line">    DestoryFlowCtxList();</span><br><span class="line">    DelFilterEngine(&amp;MyDatagram);</span><br><span class="line">    IoDeleteDevice(MyNetDevice);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络相关</category>
      </categories>
      <tags>
        <tag>网络相关</tag>
      </tags>
  </entry>
  <entry>
    <title>在驱动中实现WSK套接字客户端(1)</title>
    <url>/2020/09/25/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E5%9C%A8%E9%A9%B1%E5%8A%A8%E4%B8%AD%E5%AE%9E%E7%8E%B0WSK%E5%A5%97%E6%8E%A5%E5%AD%97%E5%AE%A2%E6%88%B7%E7%AB%AF-1/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在Vista及以后的系统中，微软提供了一系列内核中使用的socket套接字接口 <code>Winsock Kernel</code> (简称WSK)，<br>以进行内核中的网络开发，整体使用风格与应用层socket基本一致，这里先介绍客户端如何实现</p>
<h4 id="WSK客户端"><a href="#WSK客户端" class="headerlink" title="WSK客户端"></a>WSK客户端</h4><p>在WDK示例工程源码中，只提供了一个简易服务端的实现，所以在写客户端的过程中碰到了各种问题，<br>只能依靠相关API的MSDN说明进行摸索，最后实现了一个简易的客户端例子来给大家作为参考</p>
<h5 id="相关数据定义"><a href="#相关数据定义" class="headerlink" title="相关数据定义"></a>相关数据定义</h5><p>如下为所用到的相关信息的定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ntddk.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wsk.h&gt;</span></span></span><br><span class="line"><span class="comment">// 设备名称</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CTRL_DEVICE_NAME <span class="meta-string">L&quot;\\Device\\WskClient&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CTRL_SYMLINK_NAME <span class="meta-string">L&quot;\\??\\WskClient&quot;</span></span></span><br><span class="line"><span class="comment">// 控制码定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_INIT_SOCKET CTL_CODE(FILE_DEVICE_UNKNOWN, 0xA00, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_EXIT_SOCKET CTL_CODE(FILE_DEVICE_UNKNOWN, 0xA01, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_SEND_DATA   CTL_CODE(FILE_DEVICE_UNKNOWN, 0xA02, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> IOCTL_RECV_DATA   CTL_CODE(FILE_DEVICE_UNKNOWN, 0xA03, METHOD_BUFFERED, FILE_ANY_ACCESS)</span></span><br><span class="line"><span class="comment">// 结构体定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> _SOCKET_STATE &#123;</span><br><span class="line">    None = <span class="number">0</span>,</span><br><span class="line">    Creating,  <span class="comment">// 创建中</span></span><br><span class="line">    Closing,   <span class="comment">// 关闭中</span></span><br><span class="line">    Ready,     <span class="comment">// 就绪状态</span></span><br><span class="line">    Sending,   <span class="comment">// 发送中</span></span><br><span class="line">    Receiving, <span class="comment">// 接收中</span></span><br><span class="line">&#125; SOCKET_STATE, *PSOCKET_STATE;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">SOCKET_CONTEXT</span> &#123;</span></span><br><span class="line">    PWSK_SOCKET  Socket;       <span class="comment">// 套接字</span></span><br><span class="line">    SOCKET_STATE State;        <span class="comment">// 套接字状态</span></span><br><span class="line">    BOOLEAN      IsUnload;     <span class="comment">// 是否在卸载</span></span><br><span class="line">    KEVENT       ExitEvent;    <span class="comment">// 卸载所用事件</span></span><br><span class="line">    SOCKADDR_IN  LocalAddr;    <span class="comment">// 本地IP相关信息</span></span><br><span class="line">    SOCKADDR_IN  RemoteAddr;   <span class="comment">// 远程IP相关信息</span></span><br><span class="line">    PIRP         Irp;          <span class="comment">// 公共资源指针</span></span><br><span class="line">    PMDL         DataMdl;      <span class="comment">// 公共资源指针</span></span><br><span class="line">    PVOID        DataBuffer;   <span class="comment">// 公共资源指针</span></span><br><span class="line">    ULONG        DataLength;   <span class="comment">// 公共资源指针</span></span><br><span class="line">&#125; SOCKET_CONTEXT, *PSOCKET_CONTEXT;</span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">WSK_CLIENT_DISPATCH gClientDispatch = &#123; MAKE_WSK_VERSION(<span class="number">1</span>, <span class="number">0</span>),    <span class="number">0</span>,    <span class="literal">NULL</span> &#125;;</span><br><span class="line">WSK_REGISTRATION gRegistration = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">PSOCKET_CONTEXT gConnectContext = <span class="literal">NULL</span>; <span class="comment">// 套接字上下文</span></span><br><span class="line">PDEVICE_OBJECT gControlDevice = <span class="literal">NULL</span>;   <span class="comment">// 控制设备</span></span><br></pre></td></tr></table></figure>

<h5 id="驱动初始化操作"><a href="#驱动初始化操作" class="headerlink" title="驱动初始化操作"></a>驱动初始化操作</h5><p>注册WSK框架需要用到 <code>WskRegister</code> 这个函数，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">WskRegister</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  PWSK_CLIENT_NPI   WskClientNpi,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_ PWSK_REGISTRATION WskRegistration</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这个注册函数需要用到 <code>WSK_CLIENT_DISPATCH</code> <code>WSK_REGISTRATION</code> <code>WSK_CLIENT_NPI</code> 三个结构体。<br>其中 <code>WSK_CLIENT_DISPATCH</code> 指定版本号和回调函数，这个回调可以在创建结束后提供一些详细的信息，<br>这里指定为空。而 <code>WSK_REGISTRATION</code> 相当于一个句柄，可以用于提供卸载时调用</p>
<p>驱动的入口函数如下所示，我们在这里做一些初始化操作，该例子只支持 <code>单线程</code> + <code>单Socket</code> 操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DriverEntry</span><span class="params">(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ULONG Index;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    UNICODE_STRING DeviceName;</span><br><span class="line">    UNICODE_STRING SymLinkName;</span><br><span class="line">    WSK_CLIENT_NPI WskClientNpi;</span><br><span class="line">    UNREFERENCED_PARAMETER(RegistryPath);</span><br><span class="line">    <span class="comment">// 申请套接字所用的公共资源</span></span><br><span class="line">    gConnectContext = AllocateSocketContext();</span><br><span class="line">    <span class="keyword">if</span> (!gConnectContext)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">    <span class="comment">// 注册套接字框架</span></span><br><span class="line">    WskClientNpi.ClientContext = <span class="literal">NULL</span>;</span><br><span class="line">    WskClientNpi.Dispatch = &amp;gClientDispatch;</span><br><span class="line">    Status = WskRegister(&amp;WskClientNpi, &amp;gRegistration);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        FreeSocketContext(gConnectContext);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置派遣函数</span></span><br><span class="line">    <span class="keyword">for</span> (Index = <span class="number">0</span>; Index &lt;= IRP_MJ_MAXIMUM_FUNCTION; Index++)</span><br><span class="line">        DriverObject-&gt;MajorFunction[Index] = DispatchCommon;</span><br><span class="line">    DriverObject-&gt;MajorFunction[IRP_MJ_DEVICE_CONTROL] = DispatchControl;</span><br><span class="line">    DriverObject-&gt;DriverUnload = DriverUnload;</span><br><span class="line">    <span class="comment">// 创建控制设备</span></span><br><span class="line">    RtlInitUnicodeString(&amp;DeviceName, CTRL_DEVICE_NAME);</span><br><span class="line">    RtlInitUnicodeString(&amp;SymLinkName, CTRL_SYMLINK_NAME);</span><br><span class="line">    Status = IoCreateDevice(</span><br><span class="line">        DriverObject, <span class="number">0</span>, &amp;DeviceName, FILE_DEVICE_UNKNOWN,</span><br><span class="line">        FILE_DEVICE_SECURE_OPEN, FALSE, &amp;gControlDevice);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        WskDeregister(&amp;gRegistration);</span><br><span class="line">        FreeSocketContext(gConnectContext);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定符号链接</span></span><br><span class="line">    Status = IoCreateSymbolicLink(&amp;SymLinkName, &amp;DeviceName);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        IoDeleteDevice(gControlDevice);</span><br><span class="line">        WskDeregister(&amp;gRegistration);</span><br><span class="line">        FreeSocketContext(gConnectContext);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中 <code>AllocateSocketContext</code> 函数用来申请所有的公共资源，使用公共资源是为了简化逻辑</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">PSOCKET_CONTEXT <span class="title">AllocateSocketContext</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PSOCKET_CONTEXT SocketContext = <span class="literal">NULL</span>;</span><br><span class="line">    SocketContext = ExAllocatePool(NonPagedPool, <span class="keyword">sizeof</span>(SOCKET_CONTEXT));</span><br><span class="line">    <span class="keyword">if</span> (!SocketContext) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    RtlZeroMemory(SocketContext, <span class="keyword">sizeof</span>(SOCKET_CONTEXT));</span><br><span class="line">    SocketContext-&gt;Irp = IoAllocateIrp(<span class="number">1</span>, FALSE);</span><br><span class="line">    <span class="keyword">if</span> (SocketContext-&gt;Irp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        FreeSocketContext(SocketContext);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    KeInitializeEvent(&amp;SocketContext-&gt;ExitEvent, NotificationEvent, FALSE);</span><br><span class="line">    SocketContext-&gt;LocalAddr.sin_family = AF_INET;</span><br><span class="line">    <span class="keyword">return</span> SocketContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对应的 <code>FreeSocketContext</code> 是用来释放公共资源</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FreeSocketContext</span><span class="params">(IN PSOCKET_CONTEXT SocketContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (SocketContext-&gt;Irp)</span><br><span class="line">    &#123;</span><br><span class="line">        IoFreeIrp(SocketContext-&gt;Irp);</span><br><span class="line">        SocketContext-&gt;Irp = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FreeSocketBuffer(SocketContext);</span><br><span class="line">    ExFreePool(SocketContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收和发送的缓冲区根据实际内容来进行申请</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">AllocateSocketBuffer</span><span class="params">(IN PSOCKET_CONTEXT SocketContext, IN ULONG Length)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SocketContext-&gt;DataBuffer = ExAllocatePool(NonPagedPoolNx, Length);</span><br><span class="line">    <span class="keyword">if</span> (!SocketContext-&gt;DataBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        FreeSocketBuffer(SocketContext);</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">    &#125;</span><br><span class="line">    SocketContext-&gt;DataMdl = IoAllocateMdl(</span><br><span class="line">        SocketContext-&gt;DataBuffer, Length, FALSE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!SocketContext-&gt;DataMdl)</span><br><span class="line">    &#123;</span><br><span class="line">        FreeSocketBuffer(SocketContext);</span><br><span class="line">        <span class="keyword">return</span> STATUS_INSUFFICIENT_RESOURCES;</span><br><span class="line">    &#125;</span><br><span class="line">    MmBuildMdlForNonPagedPool(SocketContext-&gt;DataMdl);</span><br><span class="line">    <span class="built_in">memset</span>(SocketContext-&gt;DataBuffer, <span class="number">0</span>, Length);</span><br><span class="line">    SocketContext-&gt;DataLength = Length;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>释放接收和发送缓冲区的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID <span class="title">FreeSocketBuffer</span><span class="params">(IN PSOCKET_CONTEXT SocketContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (SocketContext-&gt;DataMdl)</span><br><span class="line">    &#123;</span><br><span class="line">        IoFreeMdl(SocketContext-&gt;DataMdl);</span><br><span class="line">        SocketContext-&gt;DataMdl = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (SocketContext-&gt;DataBuffer)</span><br><span class="line">    &#123;</span><br><span class="line">        ExFreePool(SocketContext-&gt;DataBuffer);</span><br><span class="line">        SocketContext-&gt;DataBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SocketContext-&gt;DataLength = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="派遣函数定义"><a href="#派遣函数定义" class="headerlink" title="派遣函数定义"></a>派遣函数定义</h5><p>因为我们这里只处理 <code>IRP_MJ_DEVICE_CONTROL</code> 操作，其他的统一直接完成返回成功不做处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DispatchCommon</span><span class="params">(PDEVICE_OBJECT DeviceObject, PIRP Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(DeviceObject);</span><br><span class="line">    Irp-&gt;IoStatus.Information = <span class="number">0</span>;</span><br><span class="line">    Irp-&gt;IoStatus.Status = STATUS_SUCCESS;</span><br><span class="line">    IoCompleteRequest(Irp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">DispatchControl</span><span class="params">(PDEVICE_OBJECT DeviceObject, PIRP Irp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status = STATUS_INVALID_DEVICE_REQUEST;</span><br><span class="line">    PIO_STACK_LOCATION IrpSp = <span class="literal">NULL</span>;</span><br><span class="line">    PVOID DataBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    ULONG ControlCode = <span class="number">0</span>;</span><br><span class="line">    ULONG OutputSize = <span class="number">0</span>;</span><br><span class="line">    ULONG InputSize = <span class="number">0</span>;</span><br><span class="line">    ULONG DataSize = <span class="number">0</span>;</span><br><span class="line">    UNREFERENCED_PARAMETER(DeviceObject);</span><br><span class="line">    IrpSp = IoGetCurrentIrpStackLocation(Irp);</span><br><span class="line">    DataBuffer = Irp-&gt;AssociatedIrp.SystemBuffer;</span><br><span class="line">    ControlCode = IrpSp-&gt;Parameters.DeviceIoControl.IoControlCode;</span><br><span class="line">    OutputSize = IrpSp-&gt;Parameters.DeviceIoControl.OutputBufferLength;</span><br><span class="line">    InputSize = IrpSp-&gt;Parameters.DeviceIoControl.InputBufferLength;</span><br><span class="line">    <span class="comment">// 判断控制码</span></span><br><span class="line">    <span class="keyword">switch</span> (ControlCode)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> IOCTL_INIT_SOCKET: <span class="comment">// 发起连接</span></span><br><span class="line">        <span class="keyword">if</span> (!DataBuffer || (InputSize != <span class="keyword">sizeof</span>(SOCKADDR_IN))) <span class="keyword">break</span>;</span><br><span class="line">        Status = IoCtrlInitSocket((PSOCKADDR_IN)DataBuffer);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IOCTL_EXIT_SOCKET: <span class="comment">// 关闭连接</span></span><br><span class="line">        Status = IoCtrlExitSocket();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IOCTL_SEND_DATA: <span class="comment">// 发送数据</span></span><br><span class="line">        <span class="keyword">if</span> (!DataBuffer || !InputSize) <span class="keyword">break</span>;</span><br><span class="line">        Status = IoCtrlSendData(DataBuffer, InputSize, &amp;DataSize);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> IOCTL_RECV_DATA: <span class="comment">// 接收数据</span></span><br><span class="line">        <span class="keyword">if</span> (!DataBuffer || !OutputSize) <span class="keyword">break</span>;</span><br><span class="line">        Status = IoCtrlRecvData(DataBuffer, OutputSize, &amp;DataSize);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Irp-&gt;IoStatus.Information = DataSize;</span><br><span class="line">    Irp-&gt;IoStatus.Status = Status;</span><br><span class="line">    IoCompleteRequest(Irp, IO_NO_INCREMENT);</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="控制操作封装函数"><a href="#控制操作封装函数" class="headerlink" title="控制操作封装函数"></a>控制操作封装函数</h5><p>这里对如上所示的四种操作进行了二次封装，对应函数如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCtrlInitSocket</span><span class="params">(IN PSOCKADDR_IN SrvAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!SrvAddr)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">    <span class="keyword">return</span> OperationCreate(gConnectContext, SrvAddr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCtrlExitSocket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> OperationClose(gConnectContext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCtrlSendData</span><span class="params">(IN PVOID Buffer, IN ULONG Size, OUT PULONG Real)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    <span class="keyword">if</span> (!Buffer || !Size)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">    Status = AllocateSocketBuffer(gConnectContext, Size);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    <span class="built_in">memcpy</span>(gConnectContext-&gt;DataBuffer, Buffer, Size);</span><br><span class="line">    Status = OperationSend(gConnectContext);</span><br><span class="line">    FreeSocketBuffer(gConnectContext);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    <span class="keyword">if</span> (Real)</span><br><span class="line">        *Real = (ULONG)gConnectContext-&gt;Irp-&gt;IoStatus.Information;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">IoCtrlRecvData</span><span class="params">(IN PVOID Buffer, IN ULONG Size, OUT PULONG Real)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    <span class="keyword">if</span> (!Buffer || !Size)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">    Status = AllocateSocketBuffer(gConnectContext, Size);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    Status = OperationReceive(gConnectContext);</span><br><span class="line">    <span class="keyword">if</span> (!NT_SUCCESS(Status))</span><br><span class="line">    &#123;</span><br><span class="line">        FreeSocketBuffer(gConnectContext);</span><br><span class="line">        <span class="keyword">return</span> Status;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memcpy</span>(Buffer, gConnectContext-&gt;DataBuffer,</span><br><span class="line">        (ULONG)gConnectContext-&gt;Irp-&gt;IoStatus.Information);</span><br><span class="line">    <span class="keyword">if</span> (Real)</span><br><span class="line">        *Real = (ULONG)gConnectContext-&gt;Irp-&gt;IoStatus.Information;</span><br><span class="line">    FreeSocketBuffer(gConnectContext);</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="套接字操作函数"><a href="#套接字操作函数" class="headerlink" title="套接字操作函数"></a>套接字操作函数</h5><p>所有的套接字操作都需要设置完成函数，我们这里使用统一的完成函数来处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">SyncIrpCompRoutine</span><span class="params">(PDEVICE_OBJECT Reserved, PIRP Irp, PVOID Context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UNREFERENCED_PARAMETER(Reserved);</span><br><span class="line">    UNREFERENCED_PARAMETER(Irp);</span><br><span class="line">    <span class="comment">// 设置等待的事件为信号态</span></span><br><span class="line">    KeSetEvent((PKEVENT)Context, IO_NO_INCREMENT, FALSE);</span><br><span class="line">    <span class="keyword">return</span> STATUS_MORE_PROCESSING_REQUIRED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在WSK中提供了一个同时创建和连接套接字的API函数 <code>WskSocketConnect</code> 用以简化操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">OperationCreate</span><span class="params">(IN PSOCKET_CONTEXT SocketContext, IN PSOCKADDR_IN SrvAddr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    KEVENT CompEvent;</span><br><span class="line">    WSK_PROVIDER_NPI WskProviderNpi;</span><br><span class="line">    SOCKET_STATE State;</span><br><span class="line">    BOOLEAN IsReleaseNPI = FALSE;</span><br><span class="line">    <span class="comment">// 检查参数和套接字状态</span></span><br><span class="line">    <span class="keyword">if</span> (SrvAddr == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> STATUS_INVALID_PARAMETER;</span><br><span class="line">    <span class="keyword">if</span> (SocketContext-&gt;IsUnload || (SocketContext-&gt;State != None))</span><br><span class="line">        <span class="keyword">return</span> STATUS_REQUEST_NOT_ACCEPTED;</span><br><span class="line">    State = SocketContext-&gt;State;</span><br><span class="line">    SocketContext-&gt;State = Creating;</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取使用套接字功能的组件</span></span><br><span class="line">        Status = WskCaptureProviderNPI(</span><br><span class="line">            &amp;gRegistration, WSK_INFINITE_WAIT, &amp;WskProviderNpi);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(Status)) <span class="keyword">break</span>;</span><br><span class="line">        IsReleaseNPI = TRUE;</span><br><span class="line">        <span class="comment">// 初始化事件并绑定完成函数</span></span><br><span class="line">        KeInitializeEvent(&amp;CompEvent, NotificationEvent, FALSE);</span><br><span class="line">        IoReuseIrp(SocketContext-&gt;Irp, STATUS_UNSUCCESSFUL);</span><br><span class="line">        IoSetCompletionRoutine(</span><br><span class="line">            SocketContext-&gt;Irp, SyncIrpCompRoutine, &amp;CompEvent, TRUE, TRUE, TRUE);</span><br><span class="line">        <span class="comment">// 创建并连接套接字，本地IP和端口可以不指定</span></span><br><span class="line">        SocketContext-&gt;LocalAddr.sin_family = AF_INET;</span><br><span class="line">        WskProviderNpi.Dispatch-&gt;WskSocketConnect(</span><br><span class="line">            WskProviderNpi.Client, SOCK_STREAM, IPPROTO_TCP,</span><br><span class="line">            (PSOCKADDR)&amp;SocketContext-&gt;LocalAddr, (PSOCKADDR)SrvAddr,</span><br><span class="line">            <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, SocketContext-&gt;Irp);</span><br><span class="line">        <span class="comment">// 等待套接字创建完毕</span></span><br><span class="line">        KeWaitForSingleObject(&amp;CompEvent, Executive, KernelMode, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(SocketContext-&gt;Irp-&gt;IoStatus.Status))</span><br><span class="line">        &#123;</span><br><span class="line">            Status = SocketContext-&gt;Irp-&gt;IoStatus.Status;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 保存套接字信息</span></span><br><span class="line">        SocketContext-&gt;Socket = (PWSK_SOCKET)SocketContext-&gt;Irp-&gt;IoStatus.Information;</span><br><span class="line">        Status = STATUS_SUCCESS;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 收尾数据处理</span></span><br><span class="line">    <span class="keyword">if</span> (IsReleaseNPI)</span><br><span class="line">        WskReleaseProviderNPI(&amp;gRegistration);</span><br><span class="line">    <span class="keyword">if</span> (NT_SUCCESS(Status))</span><br><span class="line">        SocketContext-&gt;State = Ready;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        SocketContext-&gt;State = State;</span><br><span class="line">    <span class="comment">// 检查驱动是否要卸载</span></span><br><span class="line">    <span class="keyword">if</span> (SocketContext-&gt;IsUnload)</span><br><span class="line">    &#123;</span><br><span class="line">        OperationClose(SocketContext);</span><br><span class="line">        KeSetEvent(&amp;SocketContext-&gt;ExitEvent, IO_NO_INCREMENT, FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>套接字的关闭流程如下，首先调用 <code>WskDisconnect</code> 断开连接，再调用 <code>WskCloseSocket</code> 关闭套接字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">OperationClose</span><span class="params">(IN PSOCKET_CONTEXT SocketContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KEVENT CompEvent;</span><br><span class="line">    PWSK_PROVIDER_BASIC_DISPATCH Dispatch1;</span><br><span class="line">    PWSK_PROVIDER_CONNECTION_DISPATCH Dispatch2;</span><br><span class="line">    <span class="comment">// 检查套接字的状态</span></span><br><span class="line">    <span class="keyword">if</span> (SocketContext-&gt;State &lt;= Closing)</span><br><span class="line">        <span class="keyword">return</span> STATUS_REQUEST_NOT_ACCEPTED;</span><br><span class="line">    SocketContext-&gt;State = Closing;</span><br><span class="line">    <span class="comment">// 获取使用套接字功能的组件</span></span><br><span class="line">    KeInitializeEvent(&amp;CompEvent, NotificationEvent, FALSE);</span><br><span class="line">    Dispatch2 = (PWSK_PROVIDER_CONNECTION_DISPATCH)SocketContext-&gt;Socket-&gt;Dispatch;</span><br><span class="line">    <span class="comment">// 绑定完成函数</span></span><br><span class="line">    IoReuseIrp(SocketContext-&gt;Irp, STATUS_UNSUCCESSFUL);</span><br><span class="line">    IoSetCompletionRoutine(</span><br><span class="line">        SocketContext-&gt;Irp, SyncIrpCompRoutine, &amp;CompEvent, TRUE, TRUE, TRUE);</span><br><span class="line">    <span class="comment">// 断开套接字连接</span></span><br><span class="line">    Dispatch2-&gt;WskDisconnect(</span><br><span class="line">        SocketContext-&gt;Socket, <span class="literal">NULL</span>, <span class="number">0</span>, SocketContext-&gt;Irp);</span><br><span class="line">    KeWaitForSingleObject(&amp;CompEvent, Executive, KernelMode, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 绑定完成函数</span></span><br><span class="line">    Dispatch1 = (PWSK_PROVIDER_BASIC_DISPATCH)SocketContext-&gt;Socket-&gt;Dispatch;</span><br><span class="line">    KeClearEvent(&amp;CompEvent);</span><br><span class="line">    IoReuseIrp(SocketContext-&gt;Irp, STATUS_UNSUCCESSFUL);</span><br><span class="line">    IoSetCompletionRoutine(</span><br><span class="line">        SocketContext-&gt;Irp, SyncIrpCompRoutine, &amp;CompEvent, TRUE, TRUE, TRUE);</span><br><span class="line">    <span class="comment">// 关闭套接字</span></span><br><span class="line">    Dispatch1-&gt;WskCloseSocket(SocketContext-&gt;Socket, SocketContext-&gt;Irp);</span><br><span class="line">    KeWaitForSingleObject(&amp;CompEvent, Executive, KernelMode, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 检查驱动是否要卸载</span></span><br><span class="line">    <span class="keyword">if</span> (SocketContext-&gt;IsUnload)</span><br><span class="line">        KeSetEvent(&amp;SocketContext-&gt;ExitEvent, IO_NO_INCREMENT, FALSE);</span><br><span class="line">    <span class="comment">// 设置套接字状态</span></span><br><span class="line">    SocketContext-&gt;State = None;</span><br><span class="line">    <span class="keyword">return</span> STATUS_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>发送数据函数如下，使用 <code>WskSend</code> 发送，注意这里是阻塞操作</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">OperationSend</span><span class="params">(IN PSOCKET_CONTEXT SocketContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    WSK_BUF WskBuf;</span><br><span class="line">    KEVENT CompEvent;</span><br><span class="line">    PWSK_PROVIDER_CONNECTION_DISPATCH Dispatch;</span><br><span class="line">    SOCKET_STATE State;</span><br><span class="line">    <span class="comment">// 检查套接字的状态</span></span><br><span class="line">    <span class="keyword">if</span> (SocketContext-&gt;IsUnload || (SocketContext-&gt;State != Ready))</span><br><span class="line">        <span class="keyword">return</span> STATUS_REQUEST_NOT_ACCEPTED;</span><br><span class="line">    State = SocketContext-&gt;State;</span><br><span class="line">    SocketContext-&gt;State = Sending;</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取使用套接字功能的组件</span></span><br><span class="line">        KeInitializeEvent(&amp;CompEvent, NotificationEvent, FALSE);</span><br><span class="line">        Dispatch = (PWSK_PROVIDER_CONNECTION_DISPATCH)SocketContext-&gt;Socket-&gt;Dispatch;</span><br><span class="line">        <span class="comment">// 初始化发送数据</span></span><br><span class="line">        WskBuf.Offset = <span class="number">0</span>;</span><br><span class="line">        WskBuf.Length = SocketContext-&gt;DataLength;</span><br><span class="line">        WskBuf.Mdl = SocketContext-&gt;DataMdl;</span><br><span class="line">        <span class="comment">// 绑定完成函数</span></span><br><span class="line">        IoReuseIrp(SocketContext-&gt;Irp, STATUS_UNSUCCESSFUL);</span><br><span class="line">        IoSetCompletionRoutine(</span><br><span class="line">            SocketContext-&gt;Irp, SyncIrpCompRoutine, &amp;CompEvent, TRUE, TRUE, TRUE);</span><br><span class="line">        <span class="comment">// 发送数据</span></span><br><span class="line">        Dispatch-&gt;WskSend(</span><br><span class="line">            SocketContext-&gt;Socket, &amp;WskBuf, <span class="number">0</span>, SocketContext-&gt;Irp);</span><br><span class="line">        <span class="comment">// 等待发送完成</span></span><br><span class="line">        KeWaitForSingleObject(&amp;CompEvent, Executive, KernelMode, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(SocketContext-&gt;Irp-&gt;IoStatus.Status))</span><br><span class="line">        &#123;</span><br><span class="line">            Status = SocketContext-&gt;Irp-&gt;IoStatus.Status;</span><br><span class="line">            OperationClose(SocketContext);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改套接字状态</span></span><br><span class="line">        Status = STATUS_SUCCESS;</span><br><span class="line">        SocketContext-&gt;State = Ready;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 检查驱动是否要卸载</span></span><br><span class="line">    <span class="keyword">if</span> (SocketContext-&gt;IsUnload)</span><br><span class="line">    &#123;</span><br><span class="line">        OperationClose(SocketContext);</span><br><span class="line">        KeSetEvent(&amp;SocketContext-&gt;ExitEvent, IO_NO_INCREMENT, FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接收数据函数如下，使用 <code>WskReceive</code> 接收，同样也为阻塞函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">NTSTATUS <span class="title">OperationReceive</span><span class="params">(IN PSOCKET_CONTEXT SocketContext)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NTSTATUS Status;</span><br><span class="line">    WSK_BUF WskBuf;</span><br><span class="line">    KEVENT CompEvent;</span><br><span class="line">    PWSK_PROVIDER_CONNECTION_DISPATCH Dispatch;</span><br><span class="line">    SOCKET_STATE State;</span><br><span class="line">    <span class="comment">// 检查套接字的状态</span></span><br><span class="line">    <span class="keyword">if</span> (SocketContext-&gt;IsUnload || (SocketContext-&gt;State != Ready))</span><br><span class="line">        <span class="keyword">return</span> STATUS_REQUEST_NOT_ACCEPTED;</span><br><span class="line">    State = SocketContext-&gt;State;</span><br><span class="line">    SocketContext-&gt;State = Sending;</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取使用套接字功能的组件</span></span><br><span class="line">        KeInitializeEvent(&amp;CompEvent, NotificationEvent, FALSE);</span><br><span class="line">        Dispatch = (PWSK_PROVIDER_CONNECTION_DISPATCH)SocketContext-&gt;Socket-&gt;Dispatch;</span><br><span class="line">        <span class="comment">// 清空接收缓冲区</span></span><br><span class="line">        WskBuf.Offset = <span class="number">0</span>;</span><br><span class="line">        WskBuf.Length = SocketContext-&gt;DataLength;</span><br><span class="line">        WskBuf.Mdl = SocketContext-&gt;DataMdl;</span><br><span class="line">        <span class="built_in">memset</span>(SocketContext-&gt;DataBuffer, <span class="number">0</span>, SocketContext-&gt;BufferLength);</span><br><span class="line">        <span class="comment">// 绑定完成函数</span></span><br><span class="line">        IoReuseIrp(SocketContext-&gt;Irp, STATUS_UNSUCCESSFUL);</span><br><span class="line">        IoSetCompletionRoutine(</span><br><span class="line">            SocketContext-&gt;Irp, SyncIrpCompRoutine, &amp;CompEvent, TRUE, TRUE, TRUE);</span><br><span class="line">        <span class="comment">// 接收数据</span></span><br><span class="line">        Dispatch-&gt;WskReceive(</span><br><span class="line">            SocketContext-&gt;Socket, &amp;WskBuf, <span class="number">0</span>, SocketContext-&gt;Irp);</span><br><span class="line">        <span class="comment">// 等待接收完成</span></span><br><span class="line">        KeWaitForSingleObject(&amp;CompEvent, Executive, KernelMode, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!NT_SUCCESS(SocketContext-&gt;Irp-&gt;IoStatus.Status))</span><br><span class="line">        &#123;</span><br><span class="line">            Status = SocketContext-&gt;Irp-&gt;IoStatus.Status;</span><br><span class="line">            OperationClose(SocketContext);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 修改套接字状态</span></span><br><span class="line">        Status = STATUS_SUCCESS;</span><br><span class="line">        SocketContext-&gt;State = Ready;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 检查驱动是否要卸载</span></span><br><span class="line">    <span class="keyword">if</span> (SocketContext-&gt;IsUnload)</span><br><span class="line">    &#123;</span><br><span class="line">        OperationClose(SocketContext);</span><br><span class="line">        KeSetEvent(&amp;SocketContext-&gt;ExitEvent, IO_NO_INCREMENT, FALSE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上函数的内容，可以看到WSK函数操作方式与应用层套接字基本一致</p>
]]></content>
      <categories>
        <category>网络相关</category>
      </categories>
      <tags>
        <tag>网络相关</tag>
      </tags>
  </entry>
  <entry>
    <title>应用层抓取网络数据包的实现(1)</title>
    <url>/2019/08/13/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E5%BA%94%E7%94%A8%E5%B1%82%E6%8A%93%E5%8F%96%E7%BD%91%E7%BB%9C%E6%95%B0%E6%8D%AE%E5%8C%85%E7%9A%84%E5%AE%9E%E7%8E%B0-1/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>大多情况下，我们都是直接使用抓包工具，来抓取网络数据包分析，比如著名的开源软件wireshark，<br>那如何自己实现抓包功能，然后自动对数据包进行分析呢？wireshark是基于winpcap实现的，另外还有<br>一种简单的方法就是使用原始套接字。</p>
<h4 id="原始套接字"><a href="#原始套接字" class="headerlink" title="原始套接字"></a>原始套接字</h4><p>在创建 <code>socket</code> 时，一般我们都是直接指定 <code>SOCK_STREAM</code> 或 <code>SOCK_DGRAM</code> 类型，但是这两种是不展示IP头<br>信息的，微软还提供了一种 <code>SOCK_RAW</code> 类型，绑定IP信息后可以监听所有流经的数据。</p>
<p>如下为简单的示例代码，在笔记本电脑上测试的时候发现，无线网卡设置监控模式失败，而以太网卡就可以<br>设置成功，推测可能是有的无线网卡驱动，没有提供该模式的功能。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mstcpip.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CapturePacket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化socket模块</span></span><br><span class="line">    WSADATA wsaData = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="comment">// 创建socket</span></span><br><span class="line">    SOCKET Socket = socket(AF_INET, SOCK_RAW, IPPROTO_IP);</span><br><span class="line">    <span class="keyword">if</span> (Socket == INVALID_SOCKET) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 绑定socket</span></span><br><span class="line">    SOCKADDR_IN SockAddr = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    SockAddr.sin_family = AF_INET;</span><br><span class="line">    SockAddr.sin_addr.S_un.S_addr = inet_addr(<span class="string">&quot;10.10.10.10&quot;</span>);</span><br><span class="line">    SockAddr.sin_port = <span class="number">0</span>; <span class="comment">// 端口随意</span></span><br><span class="line">    <span class="keyword">int</span> nRet = bind(Socket, (SOCKADDR*)&amp;SockAddr, <span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line">    <span class="keyword">if</span> (nRet == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        closesocket(Socket);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设为监控IP级别</span></span><br><span class="line">    DWORD dwValue = RCVALL_IPLEVEL, dwRet = <span class="number">0</span>;</span><br><span class="line">    nRet = WSAIoctl(Socket, SIO_RCVALL,</span><br><span class="line">        &amp;dwValue, <span class="keyword">sizeof</span>(DWORD), <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwRet, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (nRet == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        closesocket(Socket);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设为非阻塞状态只是为了限制5秒的时间</span></span><br><span class="line">    dwValue = <span class="number">1</span>;</span><br><span class="line">    nRet = ioctlsocket(Socket, FIONBIO, &amp;dwValue);</span><br><span class="line">    <span class="keyword">if</span> (nRet == SOCKET_ERROR)</span><br><span class="line">    &#123;</span><br><span class="line">        closesocket(Socket);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环抓取数据</span></span><br><span class="line">    <span class="keyword">int</span> nLen = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> szBuffer[<span class="number">512</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    DWORD dwTick = GetTickCount(); <span class="comment">// 获取开机后毫秒数</span></span><br><span class="line">    <span class="keyword">while</span> ((GetTickCount() - dwTick) &lt; <span class="number">5000</span>) <span class="comment">// 5秒</span></span><br><span class="line">    &#123;</span><br><span class="line">        Sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="built_in">memset</span>(szBuffer, <span class="number">0</span>, <span class="number">512</span>); <span class="comment">// 清空缓冲区</span></span><br><span class="line">        nLen = recv(Socket, szBuffer, <span class="number">508</span>, <span class="number">0</span>); <span class="comment">// 接收包</span></span><br><span class="line">        <span class="keyword">if</span> (nLen &lt; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">        <span class="comment">// 分析数据包的程序</span></span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">    closesocket(Socket);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="使用WINPCAP抓包"><a href="#使用WINPCAP抓包" class="headerlink" title="使用WINPCAP抓包"></a>使用WINPCAP抓包</h4><p>winpcap所包含的功能特别多，开发包中也提供了大量示例，这里不再详细的介绍原理，可自行搜索相关<br>文章。如下为根据 <code>pcap_filter</code> 例子所修改的一个简单抓包实现</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iphlpapi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HAVE_REMOTE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pcap.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;ws2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;iphlpapi.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;wpcap.lib&quot;</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 假设只有1个有效的网卡</span></span><br><span class="line"><span class="keyword">char</span> g_szSubMask[<span class="number">20</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="keyword">char</span> g_szAdapter[<span class="number">40</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">GetCardAdapter</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 第一次查询需要的空间</span></span><br><span class="line">    ULONG size = <span class="number">0</span>;</span><br><span class="line">    ULONG ret = GetAdaptersInfo(<span class="literal">NULL</span>, &amp;size);</span><br><span class="line">    <span class="keyword">if</span> (ret != ERROR_BUFFER_OVERFLOW) <span class="keyword">return</span> FALSE;</span><br><span class="line">    PIP_ADAPTER_INFO iai = (PIP_ADAPTER_INFO)<span class="built_in">malloc</span>(size);</span><br><span class="line">    <span class="keyword">if</span> (iai == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="built_in">memset</span>(iai, <span class="number">0</span>, size);</span><br><span class="line">    <span class="comment">// 第二次获取实际的信息</span></span><br><span class="line">    ret = GetAdaptersInfo(iai, &amp;size);</span><br><span class="line">    <span class="keyword">if</span> (ret != ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(iai);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查询所有网卡信息</span></span><br><span class="line">    PIP_ADAPTER_INFO iaitemp = iai;</span><br><span class="line">    <span class="keyword">while</span> (iaitemp != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 网卡IP不为0.0.0.0时</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(iaitemp-&gt;IpAddressList.IpAddress.String, <span class="string">&quot;0.0.0.0&quot;</span>) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            strcpy_s(g_szSubMask, <span class="number">20</span>, iaitemp-&gt;IpAddressList.IpMask.String);</span><br><span class="line">            strcpy_s(g_szAdapter, <span class="number">40</span>, iaitemp-&gt;AdapterName);</span><br><span class="line">            <span class="built_in">free</span>(iai);</span><br><span class="line">            <span class="keyword">return</span> TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 下一个网卡信息</span></span><br><span class="line">        iaitemp = iaitemp-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(iai);</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BOOL <span class="title">CapturePacket</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 获取网卡适配器名称</span></span><br><span class="line">    <span class="keyword">if</span> (!GetCardAdapter()) <span class="keyword">return</span> FALSE;</span><br><span class="line">    bpf_program fcode = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> szDevName[<span class="number">128</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">char</span> errbuf[PCAP_ERRBUF_SIZE] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 例：&quot;rpcap://\\Device\\NPF_&#123;4B30BE7D-20EB-4EE4-87C0-DD180B5696F8&#125;&quot;</span></span><br><span class="line">    sprintf_s(szDevName, <span class="string">&quot;rpcap://\\Device\\NPF_%s&quot;</span>, g_szAdapter);</span><br><span class="line">    <span class="comment">// 绑定网卡，注意此处errbuf不能设置为NULL</span></span><br><span class="line">    <span class="keyword">pcap_t</span> *handle = pcap_open(szDevName, <span class="number">65536</span>, FALSE, <span class="number">1000</span>, <span class="literal">NULL</span>, errbuf);</span><br><span class="line">    <span class="keyword">if</span> (handle == <span class="literal">NULL</span>) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 转换子网掩码</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nMask = inet_addr(g_szSubMask); <span class="comment">// 子网掩码</span></span><br><span class="line">    <span class="keyword">if</span> (nMask == INADDR_ANY) nMask = INADDR_NONE;</span><br><span class="line">    <span class="comment">// 编译过滤器</span></span><br><span class="line">    <span class="keyword">if</span> (pcap_compile(handle, &amp;fcode, <span class="string">&quot;ip and tcp&quot;</span>, <span class="number">1</span>, nMask) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pcap_close(handle);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置过滤器</span></span><br><span class="line">    <span class="keyword">if</span> (pcap_setfilter(handle, &amp;fcode) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        pcap_close(handle);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环抓包</span></span><br><span class="line">    <span class="keyword">int</span> nLen = <span class="number">0</span>;</span><br><span class="line">    pcap_pkthdr *head = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">const</span> u_char *pktdata = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwTick = GetTickCount(); <span class="comment">// 获取开机后毫秒数</span></span><br><span class="line">    <span class="keyword">while</span> ((GetTickCount() - dwTick) &lt; <span class="number">5000</span>) <span class="comment">// 5秒</span></span><br><span class="line">    &#123;</span><br><span class="line">        Sleep(<span class="number">1</span>);</span><br><span class="line">        nLen = pcap_next_ex(handle, &amp;head, &amp;pktdata);</span><br><span class="line">        <span class="keyword">if</span> (nLen &lt; <span class="number">1</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">        <span class="comment">// 分析数据包的程序</span></span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">    pcap_close(handle); <span class="comment">// 关闭句柄</span></span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>网络相关</category>
      </categories>
      <tags>
        <tag>网络相关</tag>
      </tags>
  </entry>
  <entry>
    <title>手动安装NDIS驱动的方法(1)</title>
    <url>/2019/12/13/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85NDIS%E9%A9%B1%E5%8A%A8%E7%9A%84%E6%96%B9%E6%B3%95-1/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>NDIS驱动使用 <code>inf</code> 文件进行安装和卸载，共分为 <code>手动处理</code> 和 <code>程序处理</code> 两种方法。<br>这篇先说明 <code>手动处理</code> 的方法，下一篇再说明 <code>程序处理</code> 的方法。</p>
<h4 id="手动安装"><a href="#手动安装" class="headerlink" title="手动安装"></a>手动安装</h4><p>在XP系统下安装 <code>NDIS5</code> 的驱动时，一共需要 <code>netsf.inf</code> <code>netsf_m.inf</code> <code>passthru.sys</code><br>3个文件，我们这里直接把这3个文件放到 <code>D:\</code> 目录下，以方便寻找文件位置。</p>
<p>首先是关闭XP中 <code>硬件签名认证</code> 警告，在<code>我的电脑</code>上右键选择 <code>属性</code>，切换到 <code>硬件</code> 选项卡中</p>
<p><img src="01.png" alt="系统属性"></p>
<p>点击 <code>驱动程序签名</code> 按钮，选择 <code>忽略</code> 选项并确定，安装完后要记得恢复到 <code>警告</code> 项</p>
<p><img src="02.png" alt="驱动签名"></p>
<p>然后是打开 <code>网络连接</code> 从 <code>本地连接</code> 上右键选择 <code>属性</code>，如下所示点击 <code>安装</code> 按钮</p>
<p><img src="03.png" alt="本地连接属性"></p>
<p>在选择 <code>网络组件类型</code> 窗口中，选择 <code>服务</code> 项并点击确定</p>
<p><img src="04.png" alt="选择网络组件类型"></p>
<p>接下来点击 <code>从磁盘安装</code> 按钮，从新窗口中的 <code>厂商文件复制来源</code> 栏里输入 <code>D:\</code> 路径，<br>最后点击 <code>确定</code> 后，出现如下 <code>选择网络服务</code> 窗口，选中对应驱动，点击 <code>确定</code> 开始安装</p>
<p><img src="05.png" alt="选择网络服务"></p>
<p>以上为在XP中安装 <code>NDIS5</code> 的方法，而在WIN7中安装 <code>NDIS6</code> 与该流程基本相同，<br>只不过 <code>NDIS6</code> 只需要 <code>netlwf.inf</code> <code>ndislwf.sys</code> 2个文件，同时WIN7中无法关闭<br><code>硬件签名认证</code> 警告，如果出现如下警告时，直接选择 <code>始终安装此驱动程序软件</code>。</p>
<p><img src="08.png" alt="安全警告"></p>
<h4 id="手动卸载"><a href="#手动卸载" class="headerlink" title="手动卸载"></a>手动卸载</h4><p>卸载的方法是，在 <code>本地连接属性</code> 界面选择对应的服务组件名，点击 <code>卸载</code> 按钮</p>
<p><img src="06.png" alt="本地连接属性"></p>
<p>在弹出的提示窗口中，选择 <code>是</code> 就会卸载NDIS驱动</p>
<p><img src="07.png" alt="卸载"></p>
<p>注意：我们可以通过修改 <code>inf</code> 文件设置的 <code>Characteristics</code> 属性，来实现安装完毕后，<br>从 <code>本地连接属性</code> 界面无法看到该组件，即配置了 <code>NCF_HIDDEN</code> 项，这种情况就只能用代码卸载了。</p>
<table>
<thead>
<tr>
<th>十六进制值</th>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>0x1</td>
<td>NCF_VIRTUAL</td>
<td>组件是个虚拟适配器</td>
</tr>
<tr>
<td>0x2</td>
<td>NCF_SOFTWARE_ENUMERATED</td>
<td>组件是一个软件模拟的适配器</td>
</tr>
<tr>
<td>0x4</td>
<td>NCF_PHYSICAL</td>
<td>组件是一个物理适配器</td>
</tr>
<tr>
<td>0x8</td>
<td>NCF_HIDDEN</td>
<td>组件不显示用户接口</td>
</tr>
<tr>
<td>0x10</td>
<td>NCF_NO_SERVICE</td>
<td>组件没有相关的服务</td>
</tr>
<tr>
<td>0x20</td>
<td>NCF_NOT_USER_REMOVABLE</td>
<td>组件不能被用户删除</td>
</tr>
<tr>
<td>0x40</td>
<td>NCF_MULTIPORT_INSTANCED_ADAPTER</td>
<td>组件有多个端口，每个都作为单独的设备安装</td>
</tr>
<tr>
<td>0x80</td>
<td>NCF_HAS_UI</td>
<td>组件支持用户接口</td>
</tr>
<tr>
<td>0x400</td>
<td>NCF_FILTER</td>
<td>组件是一个过滤器</td>
</tr>
<tr>
<td>0x4000</td>
<td>NCF_NDIS_PROTOCOL</td>
<td>组件需要由绑定引擎提供卸载事件</td>
</tr>
<tr>
<td>0x40000</td>
<td>NCF_LW_FILTER</td>
<td>组件是一个轻型过滤器</td>
</tr>
</tbody></table>
<p>详细介绍见链接：<br><a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/network/ddinstall-section-in-a-network-inf-file">https://docs.microsoft.com/en-us/windows-hardware/drivers/network/ddinstall-section-in-a-network-inf-file</a></p>
]]></content>
      <categories>
        <category>网络相关</category>
      </categories>
      <tags>
        <tag>网络相关</tag>
      </tags>
  </entry>
  <entry>
    <title>程序安装NDIS5.1的方法(2)</title>
    <url>/2019/12/17/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85NDIS5.1%E7%9A%84%E6%96%B9%E6%B3%95-2/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>测试NDIS驱动时，可以用 <code>手动处理</code> 的方法，但是在打包发布的时候，还得用 <code>程序处理</code> 的方法。<br>代码框架使用WDK源码中 <code>src -&gt; network -&gt; config -&gt; bindview</code> 工程作为基础。</p>
<h4 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h4><p>这里我们主要使用 <code>NetCfgAPI.h</code> 和 <code>NetCfgAPI.cpp</code> 两个文件，另外还需要我们从WDK源码中<br>复制 <code>netcfgn.h</code> <code>netcfgn.idl</code> <code>netcfgx.h</code> <code>netcfgx.idl</code> 这4个文件到工程目录中，并修改<br><code>NetCfgAPI.h</code> 文件中包含的头文件为当前工程目录，即：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netcfgx.h&gt; // 改为 #include &quot;netcfgx.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netcfgn.h&gt; // 改为 #include &quot;netcfgx.h&quot;</span></span></span><br></pre></td></tr></table></figure>

<p>另外我们还需要在工程中配置包含库文件，或者在代码中声明包含库文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;crypt32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;advapi32.lib&quot;</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib, <span class="meta-string">&quot;setupapi.lib&quot;</span>)</span></span><br></pre></td></tr></table></figure>

<h4 id="关闭XP签名验证"><a href="#关闭XP签名验证" class="headerlink" title="关闭XP签名验证"></a>关闭XP签名验证</h4><p>在XP中的 <code>硬件签名检测</code> 的配置信息，在注册表中的位置为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Driver Signing               Policy      BIN   0</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Non-Driver Signing           Policy      BIN   0</span><br><span class="line">HKEY_CURRENT_USER\SOFTWARE\Microsoft\Driver Signing                Policy      DWORD 0</span><br><span class="line">HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Setup PrivateHash BIN   MD5</span><br></pre></td></tr></table></figure>

<p>使用代码关闭 <code>硬件签名检测</code> 需要用到的头文件和结构体为</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wincrypt.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">DRIVER_SIGNING</span> &#123;</span></span><br><span class="line">    BYTE Policy;</span><br><span class="line">    BYTE PrivateHash[<span class="number">16</span>];</span><br><span class="line">&#125; DRIVER_SIGNING, *PDRIVER_SIGNING;</span><br></pre></td></tr></table></figure>

<p>从注册表中读取到 <code>硬件签名检测</code> 配置信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DriverSigningGet</span><span class="params">(OUT DRIVER_SIGNING &amp;Info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HKEY hKey = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwType = <span class="number">0</span>;</span><br><span class="line">    DWORD dwCount = <span class="number">16</span>;</span><br><span class="line">    DRIVER_SIGNING Sign = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="comment">// 读取HASH信息</span></span><br><span class="line">    LONG nRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,</span><br><span class="line">        <span class="string">&quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup&quot;</span>,</span><br><span class="line">        <span class="number">0</span>, KEY_ALL_ACCESS, &amp;hKey);</span><br><span class="line">    <span class="keyword">if</span> (nRet != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    nRet = RegQueryValueEx(</span><br><span class="line">        hKey, <span class="string">&quot;PrivateHash&quot;</span>, <span class="literal">NULL</span>, &amp;dwType, Sign.PrivateHash, &amp;dwCount);</span><br><span class="line">    RegCloseKey(hKey); <span class="comment">// 先关闭句柄</span></span><br><span class="line">    <span class="keyword">if</span> (nRet != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 读取策略信息</span></span><br><span class="line">    nRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,</span><br><span class="line">        <span class="string">&quot;SOFTWARE\\Microsoft\\Driver Signing&quot;</span>, <span class="number">0</span>, KEY_ALL_ACCESS, &amp;hKey);</span><br><span class="line">    <span class="keyword">if</span> (nRet != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    dwCount = <span class="number">1</span>;</span><br><span class="line">    nRet = RegQueryValueEx(</span><br><span class="line">        hKey, <span class="string">&quot;Policy&quot;</span>, <span class="literal">NULL</span>, &amp;dwType, &amp;Sign.Policy, &amp;dwCount);</span><br><span class="line">    RegCloseKey(hKey); <span class="comment">// 先关闭句柄</span></span><br><span class="line">    <span class="keyword">if</span> (nRet != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 复制到输出中</span></span><br><span class="line">    <span class="built_in">memcpy</span>(&amp;Info, &amp;Sign, <span class="keyword">sizeof</span>(DRIVER_SIGNING));</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改配置信息之前，需要先计算对应配置信息的HASH值</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DriverSigningHash</span><span class="params">(IN OUT DRIVER_SIGNING &amp;Info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HKEY hKey = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwType = <span class="number">0</span>;</span><br><span class="line">    DWORD dwSeed = <span class="number">0</span>;</span><br><span class="line">    DWORD dwCount = <span class="keyword">sizeof</span>(DWORD);</span><br><span class="line">    <span class="comment">// 读取HASH需要的序列</span></span><br><span class="line">    LONG nRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,</span><br><span class="line">        <span class="string">&quot;SYSTEM\\WPA\\PnP&quot;</span>, <span class="number">0</span>, KEY_ALL_ACCESS, &amp;hKey);</span><br><span class="line">    <span class="keyword">if</span> (nRet != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    nRet = RegQueryValueEx(</span><br><span class="line">        hKey, <span class="string">&quot;seed&quot;</span>, <span class="literal">NULL</span>, &amp;dwType, (PBYTE)&amp;dwSeed, &amp;dwCount);</span><br><span class="line">    RegCloseKey(hKey); <span class="comment">// 先关闭句柄</span></span><br><span class="line">    <span class="keyword">if</span> (nRet != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 根据策略计算HASH值</span></span><br><span class="line">    HCRYPTHASH hProv = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!CryptAcquireContext(&amp;hProv, <span class="number">0</span>, <span class="number">0</span>, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    HCRYPTHASH hHash = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (!CryptCreateHash(hProv, <span class="number">0x8003</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;hHash))</span><br><span class="line">    &#123;</span><br><span class="line">        CryptReleaseContext(hProv, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD dwData = Info.Policy;</span><br><span class="line">    <span class="keyword">if</span> (!CryptHashData(hHash, (PBYTE)&amp;dwData, <span class="keyword">sizeof</span>(DWORD), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        CryptDestroyHash(hHash);</span><br><span class="line">        CryptReleaseContext(hProv, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!CryptHashData(hHash, (PBYTE)&amp;dwSeed, <span class="keyword">sizeof</span>(DWORD), <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        CryptDestroyHash(hHash);</span><br><span class="line">        CryptReleaseContext(hProv, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    DWORD dwLen = <span class="keyword">sizeof</span>(Info.PrivateHash);</span><br><span class="line">    <span class="keyword">if</span> (!CryptGetHashParam(hHash, HP_HASHVAL, Info.PrivateHash, &amp;dwLen, <span class="number">0</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        CryptDestroyHash(hHash);</span><br><span class="line">        CryptReleaseContext(hProv, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    CryptDestroyHash(hHash);</span><br><span class="line">    CryptReleaseContext(hProv, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>计算完HASH值之后，就可以写入新的配置信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">DriverSigningSet</span><span class="params">(IN DRIVER_SIGNING &amp;Info)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HKEY hKey = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 写入HASH信息</span></span><br><span class="line">    LONG nRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,</span><br><span class="line">        <span class="string">&quot;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup&quot;</span>,</span><br><span class="line">        <span class="number">0</span>, KEY_ALL_ACCESS, &amp;hKey);</span><br><span class="line">    <span class="keyword">if</span> (nRet != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    nRet = RegSetValueEx(hKey, <span class="string">&quot;PrivateHash&quot;</span>,</span><br><span class="line">        <span class="number">0</span>, REG_BINARY, Info.PrivateHash, <span class="keyword">sizeof</span>(Info.PrivateHash));</span><br><span class="line">    RegCloseKey(hKey); <span class="comment">// 先关闭句柄</span></span><br><span class="line">    <span class="keyword">if</span> (nRet != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 写入驱动策略信息</span></span><br><span class="line">    nRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,</span><br><span class="line">        <span class="string">&quot;SOFTWARE\\Microsoft\\Driver Signing&quot;</span>, <span class="number">0</span>, KEY_ALL_ACCESS, &amp;hKey);</span><br><span class="line">    <span class="keyword">if</span> (nRet != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    nRet = RegSetValueEx(</span><br><span class="line">        hKey, <span class="string">&quot;Policy&quot;</span>, <span class="number">0</span>, REG_BINARY, &amp;Info.Policy, <span class="keyword">sizeof</span>(BYTE));</span><br><span class="line">    RegCloseKey(hKey); <span class="comment">// 先关闭句柄</span></span><br><span class="line">    <span class="keyword">if</span> (nRet != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 写入非驱动策略信息</span></span><br><span class="line">    nRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE,</span><br><span class="line">        <span class="string">&quot;SOFTWARE\\Microsoft\\Non-Driver Signing&quot;</span>,</span><br><span class="line">        <span class="number">0</span>, KEY_ALL_ACCESS, &amp;hKey);</span><br><span class="line">    <span class="keyword">if</span> (nRet != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    nRet = RegSetValueEx(</span><br><span class="line">        hKey, <span class="string">&quot;Policy&quot;</span>, <span class="number">0</span>, REG_BINARY, &amp;Info.Policy, <span class="keyword">sizeof</span>(BYTE));</span><br><span class="line">    RegCloseKey(hKey); <span class="comment">// 先关闭句柄</span></span><br><span class="line">    <span class="keyword">if</span> (nRet != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 写入用户策略信息（可能不存在）</span></span><br><span class="line">    nRet = RegOpenKeyEx(HKEY_CURRENT_USER,</span><br><span class="line">        <span class="string">&quot;SOFTWARE\\Microsoft\\Driver Signing&quot;</span>, <span class="number">0</span>, KEY_ALL_ACCESS, &amp;hKey);</span><br><span class="line">    <span class="keyword">if</span> (nRet == ERROR_SUCCESS)</span><br><span class="line">    &#123;</span><br><span class="line">        DWORD dwData = Info.Policy;</span><br><span class="line">        nRet = RegSetValueEx(</span><br><span class="line">            hKey, <span class="string">&quot;Policy&quot;</span>, <span class="number">0</span>, REG_BINARY, (PBYTE)&amp;dwData, <span class="keyword">sizeof</span>(DWORD));</span><br><span class="line">        RegCloseKey(hKey); <span class="comment">// 先关闭句柄</span></span><br><span class="line">        <span class="keyword">if</span> (nRet != ERROR_SUCCESS) <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="安装网络组件"><a href="#安装网络组件" class="headerlink" title="安装网络组件"></a>安装网络组件</h4><p>读取 <code>inf</code> 配置信息的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">CStringW <span class="title">InfGetKeyValue</span><span class="params">(IN HINF hInf, IN PCWSTR pSection, IN PCWSTR pKey, IN DWORD dwIndex)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hInf == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (hInf == INVALID_HANDLE_VALUE) <span class="keyword">return</span> <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (pSection == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    INFCONTEXT infCtx = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (!SetupFindFirstLineW(hInf, pSection, pKey, &amp;infCtx)) <span class="keyword">return</span> <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    DWORD dwSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!SetupGetStringFieldW(&amp;infCtx, dwIndex, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;dwSize)) <span class="keyword">return</span> <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    PWCHAR pValue = (PWCHAR)CoTaskMemAlloc(<span class="keyword">sizeof</span>(WCHAR) * dwSize);</span><br><span class="line">    <span class="keyword">if</span> (pValue == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">memset</span>(pValue, <span class="number">0</span>, <span class="keyword">sizeof</span>(WCHAR) * dwSize);</span><br><span class="line">    <span class="keyword">if</span> (!SetupGetStringFieldW(&amp;infCtx, dwIndex, pValue, dwSize, &amp;dwSize))</span><br><span class="line">    &#123;</span><br><span class="line">        CoTaskMemFree(pValue);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CStringW csValue = pValue;</span><br><span class="line">    CoTaskMemFree(pValue);</span><br><span class="line">    <span class="keyword">return</span> csValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取 <code>设备实例ID</code> 的函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">CStringW <span class="title">InfGetPnpID</span><span class="params">(IN CStringW csInfPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (csInfPath.IsEmpty()) <span class="keyword">return</span> <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    HINF hInf = SetupOpenInfFileW(</span><br><span class="line">        (PCWSTR)csInfPath, <span class="literal">NULL</span>, INF_STYLE_WIN4, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hInf == INVALID_HANDLE_VALUE) <span class="keyword">return</span> <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    CStringW csModel = InfGetKeyValue(hInf, <span class="string">L&quot;Manufacturer&quot;</span>, <span class="literal">NULL</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (csModel.IsEmpty())</span><br><span class="line">    &#123;</span><br><span class="line">        SetupCloseInfFile(hInf);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">L&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    CStringW csPnpID = InfGetKeyValue(hInf, (PCWSTR)csModel, <span class="literal">NULL</span>, <span class="number">2</span>);</span><br><span class="line">    SetupCloseInfFile(hInf);</span><br><span class="line">    <span class="keyword">return</span> csPnpID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于XP下安装 <code>NDIS5</code> 驱动需要2个inf文件，所以我们需要主动复制第2个文件的信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InstallNetService</span><span class="params">(IN CStringW csInfPath, IN CStringW csInf2Path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (csInfPath.IsEmpty()) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="keyword">if</span> (csInf2Path.IsEmpty()) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 备份原硬件签名检测配置</span></span><br><span class="line">    DRIVER_SIGNING Backup = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (!DriverSigningGet(Backup)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 计算忽略硬件签名检测配置的HASH</span></span><br><span class="line">    DRIVER_SIGNING Info = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    <span class="keyword">if</span> (!DriverSigningHash(Info)) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 读取NDIS设备实例ID</span></span><br><span class="line">    CStringW csPnpID = InfGetPnpID(csInfPath);</span><br><span class="line">    <span class="keyword">if</span> (csPnpID.IsEmpty()) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 开始安装网络组件</span></span><br><span class="line">    INetCfg *pnc = <span class="literal">NULL</span>;</span><br><span class="line">    HRESULT hr = HrGetINetCfg(TRUE, <span class="string">L&quot;NdisSetup&quot;</span>, &amp;pnc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hr == S_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 设置忽略硬件签名检测</span></span><br><span class="line">        <span class="keyword">if</span> (!DriverSigningSet(Info))</span><br><span class="line">        &#123;</span><br><span class="line">            HrReleaseINetCfg(pnc, TRUE);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 复制第2个inf文件的信息</span></span><br><span class="line">        <span class="keyword">if</span> (!SetupCopyOEMInfW((PCWSTR)csInf2Path,</span><br><span class="line">            <span class="literal">NULL</span>, SPOST_NONE, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            HrReleaseINetCfg(pnc, TRUE);</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把网络组件安装成服务</span></span><br><span class="line">        hr = HrInstallNetComponent(pnc, (PCWSTR)csPnpID,</span><br><span class="line">            &amp;GUID_DEVCLASS_NETSERVICE, (PCWSTR)csInfPath);</span><br><span class="line">        HrReleaseINetCfg(pnc, TRUE);</span><br><span class="line">        <span class="comment">// 恢复硬件签名检测配置</span></span><br><span class="line">        DriverSigningSet(Backup);</span><br><span class="line">        <span class="comment">// 有时候提示需要重启才生效，也算安装成功</span></span><br><span class="line">        <span class="comment">// if (hr == NETCFG_S_REBOOT) return TRUE;</span></span><br><span class="line">        <span class="keyword">if</span> (SUCCEEDED(hr)) <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>卸载时只需要第1个文件的信息</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">UninstallNetService</span><span class="params">(IN CStringW csInfPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (csInfPath.IsEmpty()) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 读取NDIS设备实例ID</span></span><br><span class="line">    CStringW csPnpID = InfGetPnpID(csInfPath);</span><br><span class="line">    <span class="keyword">if</span> (csPnpID.IsEmpty()) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 开始卸载网络组件</span></span><br><span class="line">    INetCfg *pnc = <span class="literal">NULL</span>;</span><br><span class="line">    HRESULT hr = HrGetINetCfg(TRUE, <span class="string">L&quot;NdisSetup&quot;</span>, &amp;pnc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hr == S_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 根据设备实例ID进行卸载</span></span><br><span class="line">        hr = HrUninstallNetComponent(pnc, (PCWSTR)csPnpID);</span><br><span class="line">        HrReleaseINetCfg(pnc, TRUE);</span><br><span class="line">        <span class="comment">// 有时候提示需要重启才生效，也算卸载成功</span></span><br><span class="line">        <span class="comment">// if (hr == NETCFG_S_REBOOT) return TRUE;</span></span><br><span class="line">        <span class="keyword">if</span> (SUCCEEDED(hr)) <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络相关</category>
      </categories>
      <tags>
        <tag>网络相关</tag>
      </tags>
  </entry>
  <entry>
    <title>程序安装NDIS6.0的方法(3)</title>
    <url>/2019/12/17/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E7%A8%8B%E5%BA%8F%E5%AE%89%E8%A3%85NDIS6.0%E7%9A%84%E6%96%B9%E6%B3%95-3/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在上一篇文章中写的XP中安装 <code>NDIS5</code> 的方法，但是在WIN7中已经无法对 <code>硬件签名检测</code> 进行配置，<br>经过实验，在我们拥有正统签名的情况下，可以把签名导入到 <code>受信任的发布者</code> 中，再安装 <code>NDIS6</code> 时，<br>就不会再提示警告信息，但是如果在证书过期后再安装，就仍然会提示警告信息。</p>
<h4 id="证书提取"><a href="#证书提取" class="headerlink" title="证书提取"></a>证书提取</h4><p>这里以 <code>netlwf.inf</code> <code>ndislwf.sys</code> 两个文件为例，首先给sys驱动文件进行签名，然后使用签完名的<br>sys文件和inf文件生成cat文件，一般情况下签名工具提供生成cat文件的功能，最后把这个cat文件也按照<br>驱动签名的方式进行签名，注意cat文件只能签 <code>SHA1</code> 格式的签名。</p>
<p>我们可以先在cat文件上 <code>右键-&gt;属性-&gt;数字签名</code> 中查看证书，并使用 <code>证书导入向导</code>，把证书导入到某位置。<br>然后在运行中输入 <code>certmgr.msc</code> 打开 <code>证书管理器</code> ，在需要导出的证书上 <code>右键-&gt;所有任务-&gt;导出</code> 来使用<br><code>证书导出向导</code> 进行导出</p>
<p><img src="01.png" alt="证书管理器"></p>
<p>注意导出证书选择 <code>Base64 编码 X.509(.CER)</code> 格式</p>
<p><img src="02.png" alt="证书格式"></p>
<p>导出的证书可以使用记事本打开，格式大致如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE-----</span><br><span class="line">MIIFADCCA+igAwIBAgIMXuJStShYQgfuTm0vMA0GCSqGSIb3DQEBBQUAMFExCzAJ</span><br><span class="line">BgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWduIG52LXNhMScwJQYDVQQDEx5H</span><br><span class="line">……</span><br><span class="line">txuUsUQLbRGsx03zapv&#x2F;+&#x2F;t0tlFKIQrA4eK5L5y9QwCoT4SLrVgNYjEjOPXa8PYh</span><br><span class="line">JCRoxfNoFZb269zfbDeveRSo&#x2F;QAn89SSz18q+0+yShE5gLGb</span><br><span class="line">-----END CERTIFICATE-----</span><br></pre></td></tr></table></figure>

<h4 id="代码导入证书"><a href="#代码导入证书" class="headerlink" title="代码导入证书"></a>代码导入证书</h4><p>读取证书信息的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">CString <span class="title">GetCertInfo</span><span class="params">(IN CString &amp;csCertPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CString csCert;</span><br><span class="line">    PCHAR pBuffer = <span class="literal">NULL</span>;</span><br><span class="line">    HANDLE hFile = INVALID_HANDLE_VALUE;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 打开文件</span></span><br><span class="line">        hFile = CreateFile(csCertPath,</span><br><span class="line">            GENERIC_READ, FILE_SHARE_READ, <span class="literal">NULL</span>,</span><br><span class="line">            OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (hFile == INVALID_HANDLE_VALUE) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 检查文件的大小</span></span><br><span class="line">        DWORD dwSize = GetFileSize(hFile, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (dwSize == INVALID_FILE_SIZE) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 检查是否超出100KB大小</span></span><br><span class="line">        <span class="keyword">if</span> (dwSize &gt; <span class="number">102400</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 申请缓冲区</span></span><br><span class="line">        pBuffer = (PCHAR)<span class="built_in">malloc</span>(dwSize + <span class="keyword">sizeof</span>(<span class="string">&#x27;\0&#x27;</span>));</span><br><span class="line">        <span class="keyword">if</span> (pBuffer == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(pBuffer, <span class="number">0</span>, dwSize + <span class="keyword">sizeof</span>(<span class="string">&#x27;\0&#x27;</span>));</span><br><span class="line">        <span class="comment">// 读取文件内容</span></span><br><span class="line">        DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (!ReadFile(hFile, pBuffer, dwSize, &amp;dwRet, <span class="literal">NULL</span>)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 保存读出的结果</span></span><br><span class="line">        csCert = pBuffer;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pBuffer != <span class="literal">NULL</span>) <span class="built_in">free</span>(pBuffer);</span><br><span class="line">    <span class="keyword">if</span> (hFile != INVALID_HANDLE_VALUE) CloseHandle(hFile);</span><br><span class="line">    <span class="keyword">return</span> csCert;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>导入证书的函数</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">CACertInstall</span><span class="params">(IN CString csCertPath, IN CStringW csInfPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bRet = FALSE;</span><br><span class="line">    DWORD dwCertData = <span class="number">0</span>;</span><br><span class="line">    PBYTE pbCertData = <span class="literal">NULL</span>;</span><br><span class="line">    HCERTSTORE hStore = <span class="literal">NULL</span>;</span><br><span class="line">    PCCERT_CONTEXT pCertCtx = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 读取证书信息</span></span><br><span class="line">        CString csCertInfo = GetCertInfo(csCertPath);</span><br><span class="line">        <span class="keyword">if</span> (csCertInfo.IsEmpty()) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 获取解码数据长度</span></span><br><span class="line">        <span class="keyword">if</span> (!CryptStringToBinary(csCertInfo, csCertInfo.GetLength(),</span><br><span class="line">            CRYPT_STRING_BASE64HEADER, <span class="literal">NULL</span>, &amp;dwCertData, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 申请内存空间</span></span><br><span class="line">        pbCertData = (PBYTE)<span class="built_in">malloc</span>(dwCertData);</span><br><span class="line">        <span class="keyword">if</span> (pbCertData == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">memset</span>(pbCertData, <span class="number">0</span>, dwCertData);</span><br><span class="line">        <span class="comment">// 进行Base64解码</span></span><br><span class="line">        <span class="keyword">if</span> (!CryptStringToBinary(csCertInfo, csCertInfo.GetLength(),</span><br><span class="line">            CRYPT_STRING_BASE64HEADER, pbCertData, &amp;dwCertData, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 转换CERT_CONTEXT结构</span></span><br><span class="line">        pCertCtx = CertCreateCertificateContext(</span><br><span class="line">            PKCS_7_ASN_ENCODING | X509_ASN_ENCODING, pbCertData, dwCertData);</span><br><span class="line">        <span class="keyword">if</span> (pCertCtx == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 打开证书路径（受信任的发布者）</span></span><br><span class="line">        hStore = CertOpenStore(CERT_STORE_PROV_SYSTEM, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">            CERT_STORE_OPEN_EXISTING_FLAG | CERT_SYSTEM_STORE_LOCAL_MACHINE,</span><br><span class="line">            <span class="string">L&quot;TrustedPublisher&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (hStore == <span class="literal">NULL</span>) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 安装证书</span></span><br><span class="line">        <span class="keyword">if</span> (!CertAddCertificateContextToStore(</span><br><span class="line">            hStore, pCertCtx, CERT_STORE_ADD_NEW, <span class="literal">NULL</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 错误值不是已存在</span></span><br><span class="line">            <span class="keyword">if</span> (CRYPT_E_EXISTS != GetLastError()) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 安装NDIS网络组件</span></span><br><span class="line">        <span class="keyword">if</span> (!InstallNetServiceVista(csInfPath)) <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 删除证书</span></span><br><span class="line">        CertDeleteCertificateFromStore(pCertCtx);</span><br><span class="line">        bRet = TRUE;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 关闭句柄</span></span><br><span class="line">    <span class="keyword">if</span> (pbCertData != <span class="literal">NULL</span>) <span class="built_in">free</span>(pbCertData);</span><br><span class="line">    <span class="keyword">if</span> (hStore != <span class="literal">NULL</span>) CertCloseStore(hStore, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pCertCtx != <span class="literal">NULL</span>) CertFreeCertificateContext(pCertCtx);</span><br><span class="line">    <span class="keyword">return</span> bRet;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="安装网络组件"><a href="#安装网络组件" class="headerlink" title="安装网络组件"></a>安装网络组件</h4><p>这里安装 <code>NDIS6</code> 只需要处理一个inf文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">InstallNetServiceVista</span><span class="params">(IN CStringW csInfPath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (csInfPath.IsEmpty()) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 读取设备实例ID</span></span><br><span class="line">    CStringW csPnpID = InfGetPnpID(csInfPath);</span><br><span class="line">    <span class="keyword">if</span> (csPnpID.IsEmpty()) <span class="keyword">return</span> FALSE;</span><br><span class="line">    <span class="comment">// 开始安装网络组件</span></span><br><span class="line">    INetCfg *pnc = <span class="literal">NULL</span>;</span><br><span class="line">    HRESULT hr = HrGetINetCfg(TRUE, <span class="string">L&quot;NdisSetup&quot;</span>, &amp;pnc, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (hr == S_OK)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 把网络组件安装成服务</span></span><br><span class="line">        hr = HrInstallNetComponent(pnc, (PCWSTR)csPnpID,</span><br><span class="line">            &amp;GUID_DEVCLASS_NETSERVICE, (PCWSTR)csInfPath);</span><br><span class="line">        HrReleaseINetCfg(pnc, TRUE);</span><br><span class="line">        <span class="comment">// 有时候提示需要重启才生效，也算安装成功</span></span><br><span class="line">        <span class="comment">// if (hr == NETCFG_S_REBOOT) return TRUE;</span></span><br><span class="line">        <span class="keyword">if</span> (SUCCEEDED(hr)) <span class="keyword">return</span> TRUE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>卸载的代码与上一篇文章相同。</p>
]]></content>
      <categories>
        <category>网络相关</category>
      </categories>
      <tags>
        <tag>网络相关</tag>
      </tags>
  </entry>
  <entry>
    <title>重叠IO模型和完成端口(1)</title>
    <url>/2020/01/16/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E9%87%8D%E5%8F%A0IO%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3-1/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>我们在做数据处理时，通常有 <code>同步(Synchronous)</code> 和 <code>异步(Asynchronous)</code> 两种操作方式。</p>
<p>同步模式：就是调用方发出调用请求后，一直要等待该请求完成返回后才能继续往后执行。<br>异步模式：就是调用方发出调用请求后，不需要等待该请求完成返回，可以直接继续处理其他事情，<br>当被调用的请求执行完毕后，通过某个标志，通知调用者再回来处理返回的结果。</p>
<h4 id="文件操作-OVERLAPPED"><a href="#文件操作-OVERLAPPED" class="headerlink" title="文件操作(OVERLAPPED)"></a>文件操作(OVERLAPPED)</h4><p>通常情况下，我们使用 <code>ReadFile </code>  和 <code>WriteFile</code> 来进行读写操作，其函数定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">ReadFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_        HANDLE       hFile,                <span class="comment">// 需要FILE_FLAG_OVERLAPPED权限</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_       LPVOID       lpBuffer,             <span class="comment">// 存储读取信息的缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_        DWORD        nNumberOfBytesToRead, <span class="comment">// 期望读取信息的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_opt_   LPDWORD      lpNumberOfBytesRead,  <span class="comment">// 实际读取信息的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_opt_ LPOVERLAPPED lpOverlapped          <span class="comment">// 指定重叠I/O操作的结构体</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">WriteFile</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_        HANDLE       hFile,                  <span class="comment">// 需要FILE_FLAG_OVERLAPPED权限</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_        LPCVOID      lpBuffer,               <span class="comment">// 存储写入信息的缓冲区</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_        DWORD        nNumberOfBytesToWrite,  <span class="comment">// 期望写入信息的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_opt_   LPDWORD      lpNumberOfBytesWritten, <span class="comment">// 实际写入信息的字节数</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_opt_ LPOVERLAPPED lpOverlapped            <span class="comment">// 指定重叠I/O操作的结构体</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用 <code>OVERLAPPED</code> 结构体，并搭配事件 <code>EVENT</code> 和等待函数 <code>WaitForMultipleObjects</code> 来实现异步处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">OVERLAPPED</span> &#123;</span></span><br><span class="line">  ULONG_PTR Internal;     <span class="comment">// 系统保留自用，可能是IO_STATUS_BLOCK成员</span></span><br><span class="line">  ULONG_PTR InternalHigh; <span class="comment">// 系统保留自用，可能是IO_STATUS_BLOCK成员</span></span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      DWORD Offset;       <span class="comment">// 访问偏移位置，低4字节</span></span><br><span class="line">      DWORD OffsetHigh;   <span class="comment">// 访问偏移位置，高4字节</span></span><br><span class="line">    &#125;;</span><br><span class="line">    PVOID  Pointer;       <span class="comment">// 系统保留自用</span></span><br><span class="line">  &#125;;</span><br><span class="line">  HANDLE   hEvent;        <span class="comment">// 需要创建手动复位的事件</span></span><br><span class="line">&#125; OVERLAPPED, *LPOVERLAPPED;</span><br></pre></td></tr></table></figure>

<p>示例代码如下，由于上限 <code>MAXIMUM_WAIT_OBJECTS</code> 为 <code>64</code>，表示一个线程最多只能同时等待 <code>64</code> 个事件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相关定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INSTANCES 5</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TASKINST</span> &#123;</span></span><br><span class="line">    OVERLAPPED stOverlap;</span><br><span class="line">    HANDLE hFile;   <span class="comment">// 文件的句柄</span></span><br><span class="line">    DWORD dwSize;   <span class="comment">// 读写数据大小</span></span><br><span class="line">    CHAR szBuf[<span class="number">64</span>]; <span class="comment">// 数据的缓冲区</span></span><br><span class="line">&#125; TASKINST, *PTASKINST;</span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HANDLE g_hEvents[INSTANCES] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">TASKINST g_stTasks[INSTANCES] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line"><span class="comment">// 关闭所有句柄函数</span></span><br><span class="line"><span class="function">VOID <span class="title">CloseAllHandle</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; INSTANCES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (g_hEvents[i] != <span class="literal">NULL</span>)</span><br><span class="line">            CloseHandle(g_hEvents[i]);</span><br><span class="line">        <span class="keyword">if</span> (g_stTasks[i].hFile != <span class="literal">NULL</span>)</span><br><span class="line">            CloseHandle(g_stTasks[i].hFile);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重叠IO处理示例函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">OverlappedTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bRet = <span class="number">0</span>;</span><br><span class="line">    DWORD dwErr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; INSTANCES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 创建手动复位的事件</span></span><br><span class="line">        g_hEvents[i] = CreateEvent(<span class="literal">NULL</span>, TRUE, FALSE, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (g_hEvents[i] == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            CloseAllHandle();</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        g_stTasks[i].stOverlap.hEvent = g_hEvents[i];</span><br><span class="line">        <span class="comment">// 创建文件</span></span><br><span class="line">        sprintf_s(g_stTasks[i].szBuf, <span class="number">64</span>, <span class="string">&quot;abc%d.txt&quot;</span>, i);</span><br><span class="line">        g_stTasks[i].hFile = CreateFileA(g_stTasks[i].szBuf,</span><br><span class="line">            GENERIC_WRITE, FILE_SHARE_WRITE, <span class="literal">NULL</span>, CREATE_ALWAYS,</span><br><span class="line">            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (g_stTasks[i].hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">            g_stTasks[i].hFile = <span class="literal">NULL</span>;</span><br><span class="line">            CloseAllHandle();</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 发起写入任务</span></span><br><span class="line">        g_stTasks[i].dwSize = <span class="built_in">strlen</span>(g_stTasks[i].szBuf);</span><br><span class="line">        bRet = WriteFile(g_stTasks[i].hFile, g_stTasks[i].szBuf,</span><br><span class="line">            g_stTasks[i].dwSize, <span class="literal">NULL</span>, &amp;g_stTasks[i].stOverlap);</span><br><span class="line">        <span class="keyword">if</span> (!bRet)</span><br><span class="line">        &#123;</span><br><span class="line">            dwErr = GetLastError();</span><br><span class="line">            <span class="keyword">if</span> (dwErr != ERROR_IO_PENDING)</span><br><span class="line">            &#123;</span><br><span class="line">                CloseAllHandle();</span><br><span class="line">                <span class="keyword">return</span> FALSE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 等待所有任务处理完毕</span></span><br><span class="line">    DWORD dwRet = WaitForMultipleObjects(</span><br><span class="line">        INSTANCES, g_hEvents, TRUE, INFINITE);</span><br><span class="line">    <span class="keyword">if</span> (dwRet != WAIT_OBJECT_0)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseAllHandle();</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查所有操作是否正常结束</span></span><br><span class="line">    DWORD dwRetSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; INSTANCES; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        bRet = GetOverlappedResult(g_stTasks[i].hFile,</span><br><span class="line">            &amp;g_stTasks[i].stOverlap, &amp;dwRetSize, FALSE);</span><br><span class="line">        <span class="keyword">if</span> ((!bRet) || (dwRetSize != g_stTasks[i].dwSize))</span><br><span class="line">        &#123;</span><br><span class="line">            CloseAllHandle();</span><br><span class="line">            <span class="keyword">return</span> FALSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 关闭所有句柄</span></span><br><span class="line">    CloseAllHandle();</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过以上的代码可以看到，如果采用同步操作，消耗的总时间是 <code>每一次操作的时间总和</code>，而采用异步操作，<br>消耗的总时间是 <code>花费时间最长的那一次操作的时间</code>，提高了I/O操作的利用率。</p>
<h4 id="文件操作-APC"><a href="#文件操作-APC" class="headerlink" title="文件操作(APC)"></a>文件操作(APC)</h4><p>另外，使用 <code>ReadFileEx </code>  和 <code>WriteFileEx</code>  可以避开最多等待 <code>64</code> 个事件的限制，函数定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">ReadFileEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      HANDLE                          hFile,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_opt_ LPVOID                          lpBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      DWORD                           nNumberOfBytesToRead,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_   LPOVERLAPPED                    lpOverlapped,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_      LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">WriteFileEx</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     HANDLE                          hFile,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ LPCVOID                         lpBuffer,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     DWORD                           nNumberOfBytesToWrite,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_  LPOVERLAPPED                    lpOverlapped,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>这两个函数增加了一个 <code>OVERLAPPED_COMPLETION_ROUTINE</code> 完成函数指针，当I/O任务结束时操作系统会调用<br>我们指定的完成函数，这种方式称为 <code>异步过程调用(Asynchronous Procedure Call, APC)</code>。函数中的参数<br><code>lpOverlapped</code> 的成员 <code>hEvent</code> 没有被使用，所以我们可以用来传递一些自定义的信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID CALLBACK <span class="title">FileIOCompletionRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    DWORD        dwErrorCode,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    DWORD        dwNumberOfBytesTransfered,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ LPOVERLAPPED lpOverlapped</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 完成函数</span></span><br></pre></td></tr></table></figure>

<p>注意：Windows 不会贸然中断某个程序，然后调用提供的 <code>Callback</code> 函数，线程必须在所谓的 <code>alertable</code><br>状态之下才行。如果有一个I/O操作完成，而线程不处于 <code>alertable</code> 状态，那么对  <code>I/O完成函数</code> 的调用就会<br>暂时被保留下来。因此，当一个线程终于进入 <code>alertable</code> 状态时，可能已经有大量的 <code>APCs</code>  等待被处理。<br>我们可以使用如下几个函数，使线程进入 <code>alertable</code> 状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SleepEx();</span><br><span class="line">SignalObjectAndWait();</span><br><span class="line">MsgWaitForMultipleObjectsEx();</span><br><span class="line">WaitForMultipleObjectsEx();</span><br><span class="line">WaitForSingleObjectEx();</span><br><span class="line">GetOverlappedResultEx();</span><br></pre></td></tr></table></figure>

<p>如下为示例代码，先发起一些操作请求，然后再使线程进入 <code>alertable</code> 状态来处理所有 <code>APCs</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 相关定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">TASKINST</span> &#123;</span></span><br><span class="line">    OVERLAPPED stOverlap;</span><br><span class="line">    HANDLE hFile;   <span class="comment">// 文件的句柄</span></span><br><span class="line">    DWORD dwSize;   <span class="comment">// 读写数据大小</span></span><br><span class="line">    CHAR szBuf[<span class="number">64</span>]; <span class="comment">// 数据的缓冲区</span></span><br><span class="line">&#125; TASKINST, *PTASKINST;</span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">DWORD g_dwTaskNum = <span class="number">0</span>; <span class="comment">// 发起的数量</span></span><br><span class="line">DWORD g_dwTaskFinish = <span class="number">0</span>; <span class="comment">// 完成的数量</span></span><br><span class="line"><span class="comment">// APC处理的完成函数</span></span><br><span class="line"><span class="function">VOID CALLBACK <span class="title">CompletionRoutine</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    DWORD dwErrorCode, DWORD dwTransfered, LPOVERLAPPED lpOverlapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    g_dwTaskFinish++; <span class="comment">// 完成1个</span></span><br><span class="line">    PTASKINST pTask = (PTASKINST)lpOverlapped;</span><br><span class="line">    <span class="keyword">if</span> (pTask != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        CloseHandle(pTask-&gt;hFile);</span><br><span class="line">        <span class="built_in">free</span>(pTask);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// APC处理的示例函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">APCsTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BOOL bRet = <span class="number">0</span>;</span><br><span class="line">    DWORD dwErr = <span class="number">0</span>;</span><br><span class="line">    PTASKINST pTask = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 申请任务内存空间</span></span><br><span class="line">        pTask = (PTASKINST)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(TASKINST));</span><br><span class="line">        <span class="keyword">if</span> (pTask == <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">memset</span>(pTask, <span class="number">0</span>, <span class="keyword">sizeof</span>(TASKINST));</span><br><span class="line">        sprintf_s(pTask-&gt;szBuf, <span class="number">64</span>, <span class="string">&quot;abc%d.txt&quot;</span>, i);</span><br><span class="line">        <span class="comment">// 创建文件</span></span><br><span class="line">        pTask-&gt;hFile = CreateFileA(pTask-&gt;szBuf,</span><br><span class="line">            GENERIC_WRITE, FILE_SHARE_WRITE, <span class="literal">NULL</span>, CREATE_ALWAYS,</span><br><span class="line">            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_OVERLAPPED, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (pTask-&gt;hFile == INVALID_HANDLE_VALUE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(pTask);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 可以使用hEvent来传递自定义数据</span></span><br><span class="line">        pTask-&gt;stOverlap.hEvent = (HANDLE)i;</span><br><span class="line">        <span class="comment">// 发起写入任务</span></span><br><span class="line">        g_dwTaskNum++; <span class="comment">// 发起1个</span></span><br><span class="line">        pTask-&gt;dwSize = <span class="built_in">strlen</span>(pTask-&gt;szBuf);</span><br><span class="line">        bRet = WriteFileEx(pTask-&gt;hFile, pTask-&gt;szBuf,</span><br><span class="line">            pTask-&gt;dwSize, &amp;pTask-&gt;stOverlap, CompletionRoutine);</span><br><span class="line">        <span class="keyword">if</span> (!bRet)</span><br><span class="line">        &#123;</span><br><span class="line">            dwErr = GetLastError();</span><br><span class="line">            <span class="keyword">if</span> (dwErr != ERROR_IO_PENDING)</span><br><span class="line">            &#123;</span><br><span class="line">                g_dwTaskNum--; <span class="comment">// 失败1个</span></span><br><span class="line">                CloseHandle(pTask-&gt;hFile);</span><br><span class="line">                <span class="built_in">free</span>(pTask);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环处理所有任务</span></span><br><span class="line">    DWORD dwRet = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 使线程进入alertable状态</span></span><br><span class="line">        dwRet = SleepEx(INFINITE, TRUE);</span><br><span class="line">        <span class="comment">// 一个APC操作已完成</span></span><br><span class="line">        <span class="keyword">if</span> (dwRet != WAIT_IO_COMPLETION)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> FALSE; <span class="comment">// 出错</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 全部操作已完成</span></span><br><span class="line">        <span class="keyword">if</span> (g_dwTaskFinish &gt;= g_dwTaskNum) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进过测试发现，只有把调用 <code>ReadFileEx</code> 的线程设置为 <code>alertable</code> 状态，才会处理 <code>APC</code> 任务，<br>而单独创建新线程设置 <code>alertable</code> 状态，不会处理 <code>APC</code> 任务，细节有待进一步的研究。</p>
]]></content>
      <categories>
        <category>网络相关</category>
      </categories>
      <tags>
        <tag>网络相关</tag>
      </tags>
  </entry>
  <entry>
    <title>重叠IO模型和完成端口(2)</title>
    <url>/2020/01/19/%E7%BD%91%E7%BB%9C%E7%9B%B8%E5%85%B3/%E9%87%8D%E5%8F%A0IO%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3-2/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>在网络操作中，也可以使用 <code>OVERLAPPED</code> 和 <code>APC</code> 的方式。一种是直接把 <code>socket</code> 当做文件对象来进行<br>读写操作。另一种是通过微软提供的 <code>WSAxxx</code> 系列函数来进行读写。我们这里先介绍 <code>SELECT模型</code>。</p>
<h4 id="网络操作-SELECT"><a href="#网络操作-SELECT" class="headerlink" title="网络操作(SELECT)"></a>网络操作(SELECT)</h4><p>在WINDOWS中使用 <code>SELECT模型</code> 对应函数如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    <span class="keyword">int</span>                  nfds,       <span class="comment">// 忽略，兼容UNIX用</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ fd_set               *readfds,   <span class="comment">// 检查可读性</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ fd_set               *writefds,  <span class="comment">// 检查可写性</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ fd_set               *exceptfds, <span class="comment">// 检查例外数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    <span class="keyword">const</span> struct timeval *timeout    <span class="comment">// 等待的超时时间</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>所有操作的检查，都是通过 <code>fd_set</code> 结构体来处理，如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">fd_set</span> &#123;</span></span><br><span class="line">  u_int  fd_count;</span><br><span class="line">  SOCKET fd_array[FD_SETSIZE];</span><br><span class="line">&#125; fd_set;</span><br></pre></td></tr></table></figure>

<p>结构体中的 <code>FD_SETSIZE</code> 值为 <code>64</code>，表示默认最大处理 <code>64</code> 个套接字，这个数值我们可以自行修改，<br>SDK提供了几个宏定义，来对 <code>fd_set</code> 结构体进行操作，如下所示</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FD_CLR(s, *set)：从set中删除套接字s</span><br><span class="line">FD_ISSET(s, *set)：检查s是否是set集合的一名成员；如果是，则返回TRUE</span><br><span class="line">FD_SET(s, *set)：将套接字s加入集合set</span><br><span class="line">FD_ZERO(*set)：将set初始化成空集合</span><br></pre></td></tr></table></figure>

<p>select函数参数中的 <code>readfds</code> <code>writefds</code> <code>exceptfds</code> 分别指向 <code>可读</code> <code>可写 异常</code> 对应的描述符集合。<br>这3个参数都是传入传出型参数，在调用select之前，我们把套接字通过 <code>FD_SET</code> 分别添加进 <code>readfds</code><br><code>writefds</code> <code>exceptfds</code> 描述符集合中，select会监听这些套接字。当有就绪的套接字时，select会修改<br>对应套接字的信息，而我们在下次使用时，需要重新再添加一遍原始的套接字，所以这种方法效率<br>相对较低，如下为一个简单的示例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">SelectTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="comment">// 创建服务端</span></span><br><span class="line">    SOCKET socketSrv = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (socketSrv == INVALID_SOCKET)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    SOCKADDR_IN addrSrv;</span><br><span class="line">    addrSrv.sin_family = AF_INET;</span><br><span class="line">    addrSrv.sin_addr.S_un.S_addr = htonl(INADDR_ANY);</span><br><span class="line">    addrSrv.sin_port = htons(<span class="number">45000</span>);</span><br><span class="line">    <span class="comment">// 设为非阻塞（有疑问，待验证）</span></span><br><span class="line">    u_long opt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ret = ioctlsocket(socketSrv, FIONBIO, &amp;opt);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        closesocket(socketSrv);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定</span></span><br><span class="line">    ret = bind(socketSrv, (SOCKADDR*)&amp;addrSrv, <span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        closesocket(socketSrv);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听</span></span><br><span class="line">    ret = listen(socketSrv, SOMAXCONN);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        closesocket(socketSrv);</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把服务端装入合集</span></span><br><span class="line">    fd_set allSockets;</span><br><span class="line">    FD_ZERO(&amp;allSockets);</span><br><span class="line">    FD_SET(socketSrv, &amp;allSockets);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 每次都要重新赋值</span></span><br><span class="line">        fd_set readSockets = allSockets;</span><br><span class="line">        fd_set writeSockets = allSockets;</span><br><span class="line">        fd_set errorSockets = allSockets;</span><br><span class="line">        <span class="comment">// 开始等待相关操作</span></span><br><span class="line">        ret = select(<span class="number">0</span>, &amp;readSockets, &amp;writeSockets, &amp;errorSockets, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 检查是否有错误</span></span><br><span class="line">        <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; errorSockets.fd_count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            FD_CLR(errorSockets.fd_array[i], &amp;allSockets);</span><br><span class="line">            closesocket(errorSockets.fd_array[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否有可写</span></span><br><span class="line">        <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; writeSockets.fd_count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            ret = send(writeSockets.fd_array[i], <span class="string">&quot;ok&quot;</span>, <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                FD_CLR(errorSockets.fd_array[i], &amp;allSockets);</span><br><span class="line">                closesocket(errorSockets.fd_array[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// do something ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查是否有可读</span></span><br><span class="line">        <span class="keyword">for</span> (u_int i = <span class="number">0</span>; i &lt; readSockets.fd_count; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (readSockets.fd_array[i] == socketSrv)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 接受连接并放入合集(检查是否超出上限)</span></span><br><span class="line">                <span class="keyword">if</span> (allSockets.fd_count &gt;= FD_SETSIZE) <span class="keyword">continue</span>;</span><br><span class="line">                SOCKET socketCli = accept(socketSrv, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">                <span class="keyword">if</span> (socketCli == INVALID_SOCKET) <span class="keyword">continue</span>;</span><br><span class="line">                FD_SET(socketCli, &amp;allSockets);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 假定数据不超过缓冲区</span></span><br><span class="line">                <span class="keyword">char</span> rcvBuf[<span class="number">1024</span>] = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">                ret = recv(readSockets.fd_array[i], rcvBuf, <span class="number">1024</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    FD_CLR(errorSockets.fd_array[i], &amp;allSockets);</span><br><span class="line">                    closesocket(errorSockets.fd_array[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// do something ...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    closesocket(socketSrv);</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="网络操作-OVERLAPPED-APC"><a href="#网络操作-OVERLAPPED-APC" class="headerlink" title="网络操作(OVERLAPPED)(APC)"></a>网络操作(OVERLAPPED)(APC)</h4><p>微软专门提供了一组 <code>WSAxxx</code> 网络异步操作函数，包括 <code>WSASend</code> <code>WSASendTo</code> <code>WSARecv</code> <code>WSARecvFrom</code> 等</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WSARecv</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    SOCKET                             s,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ LPWSABUF                           lpBuffers,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    DWORD                              dwBufferCount,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_   LPDWORD                            lpNumberOfBytesRecvd,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Inout_ LPDWORD                            lpFlags,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    LPWSAOVERLAPPED                    lpOverlapped,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_    LPWSAOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用 <code>WSAOVERLAPPED</code> 结构体，并搭配 <code>WSAEVENT</code> 和 <code>WSAWaitForMultipleEvents</code> 来实现异步处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">WSAOVERLAPPED</span> &#123;</span></span><br><span class="line">  ULONG_PTR Internal;</span><br><span class="line">  ULONG_PTR InternalHigh;</span><br><span class="line">  <span class="keyword">union</span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">      DWORD Offset;</span><br><span class="line">      DWORD OffsetHigh;</span><br><span class="line">    &#125;;</span><br><span class="line">    PVOID   Pointer;</span><br><span class="line">  &#125;;</span><br><span class="line">  HANDLE    hEvent;</span><br><span class="line">&#125; WSAOVERLAPPED, *LPWSAOVERLAPPED;</span><br></pre></td></tr></table></figure>

<p>完成函数 <code>WSAOVERLAPPED_COMPLETION_ROUTINE</code> 定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">VOID CALLBACK <span class="title">WSAOVERLAPPED_COMPLETION_ROUTINE</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ DWORD           dwError,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ DWORD           cbTransferred,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ LPWSAOVERLAPPED lpOverlapped,</span></span></span><br><span class="line"><span class="function"><span class="params">    _In_ DWORD           dwFlags</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>; <span class="comment">// 完成函数</span></span><br></pre></td></tr></table></figure>

<p>可以看到，WSA操作函数与文件操作函数结构基本一致，这里就不再提供示例代码，可以参考<br><a href="https://www.cnblogs.com/HPAHPA/p/7819498.html">https://www.cnblogs.com/HPAHPA/p/7819498.html</a> 写的文章。</p>
<h4 id="完成端口-IOCP"><a href="#完成端口-IOCP" class="headerlink" title="完成端口(IOCP)"></a>完成端口(IOCP)</h4><p>前边所述的各种方法，都或多或少存在一些缺陷，那么有没有比较完美的方法呢，那就是使用完成端口。<br>完成端口维护一个任务队列，使用少量的线程来发起任务和处理任务，既可以避免频繁的切换大量线程<br>上下文造成的资源浪费，又不受必须在任务发起线程设置 <code>alertable</code> 状态的限制。</p>
<p>创建完成端口的函数为 <code>CreateIoCompletionPort</code> 定义如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">HANDLE WINAPI <span class="title">CreateIoCompletionPort</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     HANDLE    FileHandle,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_opt_ HANDLE    ExistingCompletionPort,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     ULONG_PTR CompletionKey,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_     DWORD     NumberOfConcurrentThreads <span class="comment">// 并发执行最大线程数，一般是CPU核心数*2</span></span></span></span><br><span class="line"><span class="function"><span class="params">                                               <span class="comment">// 设为0则表示与系统中的处理器数量一样多</span></span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>使用多线程时，还要注意全局数据读写竞争，以及数据分块读写后，如何顺序重组的问题，我们这里先<br>只用一个工作线程，避开这些问题，只关注完成端口的原理。获取CPU核心数的代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD <span class="title">GetCpuCoreCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SYSTEM_INFO stInfo = &#123; <span class="number">0</span> &#125;;</span><br><span class="line">    GetSystemInfo(&amp;stInfo);</span><br><span class="line">    <span class="keyword">return</span> stInfo.dwNumberOfProcessors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在创建套接字时，如果使用 <code>WSASocket</code> 函数就，必须加上 <code>WSA_FLAG_OVERLAPPED</code> 标志，如果使用 <code>socket</code><br>函数，会自动的附加这个参数，不需要再专门标出。使用方式如下所示</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, <span class="literal">NULL</span>, <span class="number">0</span>, WSA_FLAG_OVERLAPPED);</span><br><span class="line">socket(AF_INET, SOCK_STREAM, IPPROTO_TCP); <span class="comment">// 自带WSA_FLAG_OVERLAPPED标志</span></span><br></pre></td></tr></table></figure>

<p>接受连接请求有两个函数：分别是 <code>accept</code> 和 <code>AcceptEx</code>，在并发量比较小的时候，这两个函数效率没啥<br>区别，在并发量较大时，使用 <code>AcceptEx</code> 效率更高。需要注意的是 <code>AcceptEx</code> 是从 VISTA 才开始提供的，<br>如果要在 XP 系统下运行，就只能使用 <code>accept</code> 。我们先以 <code>accept</code> 为例</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;winsock2.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> comment(lib,<span class="meta-string">&quot;WS2_32.lib&quot;</span>)</span></span><br><span class="line"><span class="comment">// 结构体定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WSABUF_LEN 4096</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_DATA</span> &#123;</span></span><br><span class="line">    OVERLAPPED Overlapped;</span><br><span class="line">    SOCKET socketCli; <span class="comment">// 客户端</span></span><br><span class="line">    WSABUF wsabuf; <span class="comment">// 缓冲区指针</span></span><br><span class="line">    <span class="keyword">char</span> opCode; <span class="comment">// 0读,1写</span></span><br><span class="line">    <span class="keyword">char</span> buf[WSABUF_LEN]; <span class="comment">// 缓冲区</span></span><br><span class="line">&#125; IO_DATA, *PIO_DATA;</span><br><span class="line"><span class="comment">// 全局变量</span></span><br><span class="line">HANDLE g_hCompPort = <span class="literal">NULL</span>;</span><br><span class="line">SOCKET g_socketSrv = INVALID_SOCKET;</span><br><span class="line"><span class="comment">// 完成端口测试函数</span></span><br><span class="line"><span class="function">BOOL <span class="title">IOCPTest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 初始化</span></span><br><span class="line">    WSADATA wsaData;</span><br><span class="line">    WSAStartup(MAKEWORD(<span class="number">2</span>, <span class="number">2</span>), &amp;wsaData);</span><br><span class="line">    <span class="comment">// 创建SOCKET</span></span><br><span class="line">    g_socketSrv = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);</span><br><span class="line">    <span class="keyword">if</span> (INVALID_SOCKET == g_socketSrv)</span><br><span class="line">    &#123;</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定IP地址</span></span><br><span class="line">    SOCKADDR_IN addrSrv;</span><br><span class="line">    addrSrv.sin_family = AF_INET;</span><br><span class="line">    addrSrv.sin_addr.S_un.S_addr = INADDR_ANY;</span><br><span class="line">    addrSrv.sin_port = htons(<span class="number">45000</span>);</span><br><span class="line">    <span class="keyword">int</span> nRet = bind(g_socketSrv, (SOCKADDR*)&amp;addrSrv, <span class="keyword">sizeof</span>(SOCKADDR));</span><br><span class="line">    <span class="keyword">if</span> (nRet != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        closesocket(g_socketSrv);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 监听服务端</span></span><br><span class="line">    nRet = listen(g_socketSrv, SOMAXCONN);</span><br><span class="line">    <span class="keyword">if</span> (nRet != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        closesocket(g_socketSrv);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建完成端口</span></span><br><span class="line">    g_hCompPort = CreateIoCompletionPort(</span><br><span class="line">        INVALID_HANDLE_VALUE, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == g_hCompPort)</span><br><span class="line">    &#123;</span><br><span class="line">        closesocket(g_socketSrv);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定服务端</span></span><br><span class="line">    HANDLE hTemp = CreateIoCompletionPort(</span><br><span class="line">        (HANDLE)g_socketSrv, g_hCompPort, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == hTemp)</span><br><span class="line">    &#123;</span><br><span class="line">        closesocket(g_socketSrv);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建工作线程</span></span><br><span class="line">    HANDLE hThread = CreateThread(</span><br><span class="line">        <span class="literal">NULL</span>, <span class="number">0</span>, WorkerThreadProc, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">NULL</span> == hThread)</span><br><span class="line">    &#123;</span><br><span class="line">        closesocket(g_socketSrv);</span><br><span class="line">        WSACleanup();</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 循环接收连接请求</span></span><br><span class="line">    <span class="keyword">int</span> nErr = <span class="number">0</span>;</span><br><span class="line">    DWORD dwBytes = <span class="number">0</span>;</span><br><span class="line">    DWORD dwFlags = <span class="number">0</span>;</span><br><span class="line">    PIO_DATA pIoContext = <span class="literal">NULL</span>;</span><br><span class="line">    SOCKET socketCli = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (g_socketSrv)</span><br><span class="line">    &#123;</span><br><span class="line">        socketCli = accept(g_socketSrv, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (INVALID_SOCKET  == socketCli) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 绑定客户端，并作为key参数</span></span><br><span class="line">        hTemp = CreateIoCompletionPort(</span><br><span class="line">            (HANDLE)socketCli, g_hCompPort, (ULONG_PTR)socketCli, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (<span class="literal">NULL</span> == hTemp)</span><br><span class="line">        &#123;</span><br><span class="line">            closesocket(socketCli);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 初始化上下文</span></span><br><span class="line">        pIoContext = (PIO_DATA)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(IO_DATA));</span><br><span class="line">        <span class="keyword">if</span> (pIoContext == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            closesocket(socketCli);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">memset</span>(pIoContext, <span class="number">0</span>, <span class="keyword">sizeof</span>(IO_DATA));</span><br><span class="line">        pIoContext-&gt;opCode = <span class="number">0</span>; <span class="comment">// 读操作</span></span><br><span class="line">        pIoContext-&gt;wsabuf.buf = pIoContext-&gt;buf;</span><br><span class="line">        pIoContext-&gt;wsabuf.len = WSABUF_LEN;</span><br><span class="line">        pIoContext-&gt;socketCli = socketCli;</span><br><span class="line">        <span class="comment">// 发起接收请求</span></span><br><span class="line">        dwBytes = <span class="number">0</span>, dwFlags = <span class="number">0</span>;</span><br><span class="line">        nRet = WSARecv(socketCli, &amp;pIoContext-&gt;wsabuf, <span class="number">1</span>,</span><br><span class="line">                &amp;dwBytes, &amp;dwFlags, &amp;pIoContext-&gt;Overlapped, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (nRet != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nErr = WSAGetLastError();</span><br><span class="line">            <span class="keyword">if</span> (ERROR_IO_PENDING != nErr)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">free</span>(pIoContext);</span><br><span class="line">                closesocket(socketCli);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    CloseHandle(g_hCompPort);</span><br><span class="line">    closesocket(g_socketSrv);</span><br><span class="line">    WSACleanup();</span><br><span class="line">    <span class="keyword">return</span> TRUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 Worker 线程中，最关键的函数就是 <code>GetQueuedCompletionStatus</code>，功能就是等待任务队列中的任务<br>完成，并取出已经完成的任务信息，这个函数的定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL WINAPI <span class="title">GetQueuedCompletionStatus</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  HANDLE       CompletionPort,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_ LPDWORD      lpNumberOfBytes,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_ PULONG_PTR   lpCompletionKey,</span></span></span><br><span class="line"><span class="function"><span class="params">  _Out_ LPOVERLAPPED *lpOverlapped,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_  DWORD        dwMilliseconds</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如下为工作线程处理读写任务的示例代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">WorkerThreadProc</span><span class="params">(LPVOID lpParam)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 循环获取任务队列</span></span><br><span class="line">    BOOL bRet = FALSE;</span><br><span class="line">    DWORD dwIoSize = <span class="number">0</span>;</span><br><span class="line">    SOCKET* lpCompKey = <span class="literal">NULL</span>;</span><br><span class="line">    LPOVERLAPPED lpOverlapped = <span class="literal">NULL</span>;</span><br><span class="line">    PIO_DATA pIoContext = <span class="literal">NULL</span>;</span><br><span class="line">    DWORD dwBytes = <span class="number">0</span>;</span><br><span class="line">    DWORD dwFlags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nRet = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nErr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        bRet = GetQueuedCompletionStatus(g_hCompPort, &amp;dwIoSize,</span><br><span class="line">            (PULONG_PTR)&amp;lpCompKey, (LPOVERLAPPED*)&amp;lpOverlapped, INFINITE);</span><br><span class="line">        <span class="keyword">if</span> (!bRet) <span class="keyword">break</span>; <span class="comment">// 出现错误</span></span><br><span class="line">        pIoContext = CONTAINING_RECORD(lpOverlapped, IO_DATA, Overlapped);</span><br><span class="line">        <span class="keyword">if</span> (dwIoSize == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 连接已关闭</span></span><br><span class="line">            closesocket(pIoContext-&gt;socketCli);</span><br><span class="line">            <span class="built_in">free</span>(pIoContext);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 读操作完成</span></span><br><span class="line">        <span class="keyword">if</span> (pIoContext-&gt;opCode == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;recv:%s\n&quot;</span>, pIoContext-&gt;buf);</span><br><span class="line">            <span class="comment">// 发起发送请求</span></span><br><span class="line">            pIoContext-&gt;opCode = <span class="number">1</span>; <span class="comment">// 写操作</span></span><br><span class="line">            <span class="built_in">memset</span>(&amp;pIoContext-&gt;Overlapped, <span class="number">0</span>, <span class="keyword">sizeof</span>(OVERLAPPED));</span><br><span class="line">            strcpy_s(pIoContext-&gt;buf, WSABUF_LEN, <span class="string">&quot;200 OK&quot;</span>);</span><br><span class="line">            pIoContext-&gt;wsabuf.len = <span class="built_in">strlen</span>(pIoContext-&gt;buf);</span><br><span class="line">            dwBytes = <span class="number">0</span>, dwFlags = <span class="number">0</span>;</span><br><span class="line">            nRet = WSASend(pIoContext-&gt;socketCli, &amp;pIoContext-&gt;wsabuf, <span class="number">1</span>,</span><br><span class="line">                &amp;dwBytes, dwFlags, &amp;pIoContext-&gt;Overlapped, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (nRet != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nErr = WSAGetLastError();</span><br><span class="line">                <span class="keyword">if</span> (ERROR_IO_PENDING != nErr)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">free</span>(pIoContext);</span><br><span class="line">                    closesocket(pIoContext-&gt;socketCli);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 写操作完成</span></span><br><span class="line">        <span class="keyword">if</span> (pIoContext-&gt;opCode == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;send:%s\n&quot;</span>, pIoContext-&gt;buf);</span><br><span class="line">            <span class="comment">// 发起接收请求</span></span><br><span class="line">            pIoContext-&gt;opCode = <span class="number">0</span>; <span class="comment">// 读操作</span></span><br><span class="line">            <span class="built_in">memset</span>(&amp;pIoContext-&gt;Overlapped, <span class="number">0</span>, <span class="keyword">sizeof</span>(OVERLAPPED));</span><br><span class="line">            <span class="built_in">memset</span>(pIoContext-&gt;buf, <span class="number">0</span>, WSABUF_LEN);</span><br><span class="line">            pIoContext-&gt;wsabuf.len = WSABUF_LEN;</span><br><span class="line">            dwBytes = <span class="number">0</span>, dwFlags = <span class="number">0</span>;</span><br><span class="line">            nRet = WSARecv(pIoContext-&gt;socketCli, &amp;pIoContext-&gt;wsabuf, <span class="number">1</span>,</span><br><span class="line">                &amp;dwBytes, &amp;dwFlags, &amp;pIoContext-&gt;Overlapped, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (nRet != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                nErr = WSAGetLastError();</span><br><span class="line">                <span class="keyword">if</span> (ERROR_IO_PENDING != nErr)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">free</span>(pIoContext);</span><br><span class="line">                    closesocket(pIoContext-&gt;socketCli);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：这里只简单描述了完成端口工作的情况，实际在使用中还有大量的细节需要处理。<br>本文参考了 <a href="https://blog.csdn.net/piggyxp/article/details/6922277">https://blog.csdn.net/piggyxp/article/details/6922277</a> 的博客文章</p>
]]></content>
      <categories>
        <category>网络相关</category>
      </categories>
      <tags>
        <tag>网络相关</tag>
      </tags>
  </entry>
</search>
